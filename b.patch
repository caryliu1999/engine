diff --git a/cocos/core/3d/builtin/init.ts b/cocos/core/3d/builtin/init.ts
index 9e57fb760..6d7f4ef1b 100644
--- a/cocos/core/3d/builtin/init.ts
+++ b/cocos/core/3d/builtin/init.ts
@@ -32,6 +32,9 @@ import { Device } from '../../gfx';
 import effects from './effects';
 import { legacyCC } from '../../global-exports';
 import { getDeviceShaderVersion } from '../../renderer/core/program-lib';
+import { ccbitmask } from '../../value-types/bitmask';
+import { EffectAsset } from '../../assets';
+import { AssetTable } from '../../load-pipeline/asset-table';
 
 class BuiltinResMgr {
     protected _device: Device | null = null;
@@ -291,6 +294,23 @@ class BuiltinResMgr {
         spineTwoColorMtl.initialize({ defines: { USE_TEXTURE: true, CC_USE_EMBEDDED_ALPHA: true, IS_GRAY: false }, effectName: 'spine-two-colored' });
         resources[spineTwoColorMtl._uuid] = spineTwoColorMtl;
     }
+
+    public _initDeferredMaterial () {
+        // builtin deferred material
+        cc.resources.load('shader/builtin-deferred', cc.EffectAsset, (err, ass) => {
+            const builtinDeferredMtl = new legacyCC.Material();
+            builtinDeferredMtl._uuid = 'builtin-deferred-material';
+            builtinDeferredMtl.initialize({effectAsset: ass});
+            this._resources[builtinDeferredMtl._uuid] = builtinDeferredMtl;
+        });
+
+        cc.resources.load('shader/builtin-postprocess', cc.EffectAsset, (err, bss) => {
+            const builtinPostProcessMtl = new legacyCC.Material();
+            builtinPostProcessMtl._uuid = 'builtin-post-process-material';
+            builtinPostProcessMtl.initialize({effectAsset: bss});
+            this._resources[builtinPostProcessMtl._uuid] = builtinPostProcessMtl;
+        });
+    }
 }
 
 const builtinResMgr = legacyCC.builtinResMgr = new BuiltinResMgr();
diff --git a/cocos/core/game.ts b/cocos/core/game.ts
index 03e1c827f..8d8f7c752 100644
--- a/cocos/core/game.ts
+++ b/cocos/core/game.ts
@@ -43,6 +43,7 @@ import { bindingMappingInfo } from './pipeline/define';
 import { SplashScreen } from './splash-screen';
 import { RenderPipeline } from './pipeline';
 import { Node } from './scene-graph/node';
+import { builtinResMgr } from './3d/builtin/init';
 
 
 interface ISceneInfo {
@@ -963,6 +964,7 @@ export class Game extends EventTarget {
         if (!renderPipeline) {
             this._setRenderPipeline();
         } else {
+            builtinResMgr._initDeferredMaterial();
             return new Promise<RenderPipeline>((resolve, reject) => {
             	legacyCC.assetManager.loadAny(renderPipeline, (err, asset) => {
                     return (err || !(asset instanceof RenderPipeline)) ? reject(err) : resolve(asset);
diff --git a/cocos/core/pipeline/deferred/lighting-stage.ts b/cocos/core/pipeline/deferred/lighting-stage.ts
index abd5e3c47..82f0285b1 100644
--- a/cocos/core/pipeline/deferred/lighting-stage.ts
+++ b/cocos/core/pipeline/deferred/lighting-stage.ts
@@ -21,11 +21,12 @@ import { PipelineStateManager } from '../pipeline-state-manager';
 import { PipelineState } from '../../gfx/pipeline-state';
 import { sphere, intersect } from '../../geometry';
 import { Vec3 } from '../../math';
-import { Buffer, BufferUsageBit, MemoryUsageBit, BufferInfo, BufferViewInfo, DescriptorSet, DescriptorSetLayoutInfo, 
+import { Buffer, BufferUsageBit, MemoryUsageBit, BufferInfo, BufferViewInfo, DescriptorSet, DescriptorSetLayoutInfo,
     DescriptorSetLayout, DescriptorSetInfo } from '../../gfx';
 import { UBOForwardLight } from '../define';
 import { ClearFlag } from '../../gfx/define';
 import { SRGBToLinear } from '../pipeline-funcs';
+import { builtinResMgr } from '../../3d/builtin/init';
 
 const colors: Color[] = [ new Color(0, 0, 0, 1) ];
 const LIGHTINGPASS_INDEX = 1;
@@ -38,7 +39,7 @@ const LIGHTINGPASS_INDEX = 1;
 export class LightingStage extends RenderStage {
 
     private _deferredLitsBufs: Buffer = null!;
-    private _maxDeferredLights = 10;
+    private _maxDeferredLights = UBODeferredLight::LIGHTS_PER_PASS;
     private _lightBufferData!: Float32Array;
     private _lightBufferStride: number = 0;
     private _lightBufferElementCount: number = 0;
@@ -88,7 +89,7 @@ export class LightingStage extends RenderStage {
 
         this._deferredMaterial = val;
     }
-    
+
     constructor () {
         super();
     }
@@ -100,7 +101,7 @@ export class LightingStage extends RenderStage {
         }
         return true;
     }
-    
+
     public gatherLights(view: RenderView) {
         const pipeline = this._pipeline as DeferredPipeline;
         const cmdBuff = pipeline.commandBuffers[0];
@@ -139,7 +140,7 @@ export class LightingStage extends RenderStage {
                 }
 
                 this._lightBufferData.set(_vec4Array, idx * fieldLenth + totalFieldLenth * 1);
-                
+
                 _vec4Array[0] = light.size;
                 _vec4Array[1] = light.range;
                 _vec4Array[2] = 0.0;
@@ -190,7 +191,7 @@ export class LightingStage extends RenderStage {
     public activate (pipeline: DeferredPipeline, flow: LightingFlow) {
         super.activate(pipeline, flow);
 
-        const device = pipeline.device;        
+        const device = pipeline.device;
 
         // init descriptorSet
         this._lightBufferStride = Math.ceil(UBOForwardLight.SIZE / device.uboOffsetAlignment) * device.uboOffsetAlignment;
@@ -202,11 +203,11 @@ export class LightingStage extends RenderStage {
             this._lightBufferStride * this._maxDeferredLights,
             this._lightBufferStride,
         ));
-            
+
         let len = this._lightBufferElementCount * this._maxDeferredLights + 0;
         const deferredLitsBufView = device.createBuffer(new BufferViewInfo(this._deferredLitsBufs, 0, len * 4));
-        this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._maxDeferredLights + 0);  
-        
+        this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._maxDeferredLights + 0);
+
         const layoutInfo = new DescriptorSetLayoutInfo(localDescriptorSetLayout.bindings);
         this._descriptorSetLayout = device.createDescriptorSetLayout(layoutInfo);
         this._descriptorSet = device.createDescriptorSet(new DescriptorSetInfo(this._descriptorSetLayout));
@@ -250,7 +251,7 @@ export class LightingStage extends RenderStage {
 
         // light信息
         this.gatherLights(view);
-        this._descriptorSet.update()        
+        this._descriptorSet.update();
         this._planarQueue.gatherShadowPasses(view, cmdBuff);
         cmdBuff.bindDescriptorSet(SetIndex.LOCAL, this._descriptorSet);
 
@@ -263,7 +264,7 @@ export class LightingStage extends RenderStage {
         this._renderArea!.y = vp.y * h;
         this._renderArea!.width = vp.width * w * pipeline.shadingScale;
         this._renderArea!.height = vp.height * h * pipeline.shadingScale;
-        
+
         if (camera.clearFlag & ClearFlag.COLOR) {
             if (pipeline.isHDR) {
                 SRGBToLinear(colors[0], camera.clearColor);
@@ -289,8 +290,11 @@ export class LightingStage extends RenderStage {
         cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);
 
         // Lighting
-        const pass = this._deferredMaterial!.passes[LIGHTINGPASS_INDEX];
-        const shader = ShaderPool.get(this._deferredMaterial!.passes[LIGHTINGPASS_INDEX].getShaderVariant());
+        //const pass = this._deferredMaterial!.passes[LIGHTINGPASS_INDEX];
+        //const shader = ShaderPool.get(this._deferredMaterial!.passes[LIGHTINGPASS_INDEX].getShaderVariant());
+        const builinDeferred = builtinResMgr.get<Material>('builtin-deferred-material');
+        const pass = builinDeferred.passes[1];
+        const shader = ShaderPool.get(pass.getShaderVariant());
 
         const inputAssembler = pipeline.quadIA;
         var pso:PipelineState|null = null;
@@ -305,7 +309,7 @@ export class LightingStage extends RenderStage {
             cmdBuff.bindInputAssembler(inputAssembler);
             cmdBuff.draw(inputAssembler);
         }
-        
+
         // planarQueue
         this._planarQueue.recordCommandBuffer(device, renderPass, cmdBuff);
 
diff --git a/cocos/core/pipeline/deferred/postprocess-stage.ts b/cocos/core/pipeline/deferred/postprocess-stage.ts
index d07855ead..324048c74 100644
--- a/cocos/core/pipeline/deferred/postprocess-stage.ts
+++ b/cocos/core/pipeline/deferred/postprocess-stage.ts
@@ -14,6 +14,7 @@ import { Material } from '../../assets/material';
 import { ShaderPool } from '../../renderer/core/memory-pools';
 import { PipelineStateManager } from '../pipeline-state-manager';
 import { PipelineState } from '../../gfx/pipeline-state';
+import { builtinResMgr } from '../../3d/builtin/init';
 
 const colors: Color[] = [ new Color(0, 0, 0, 1) ];
 const POSTPROCESSPASS_INDEX = 0;
@@ -45,7 +46,7 @@ export class PostprocessStage extends RenderStage {
 
         this._postprocessMaterial = val;
     }
-    
+
     constructor () {
         super();
     }
@@ -56,7 +57,7 @@ export class PostprocessStage extends RenderStage {
     }
 
     public activate (pipeline: DeferredPipeline, flow: LightingFlow) {
-        super.activate(pipeline, flow);   
+        super.activate(pipeline, flow);
     }
 
     public destroy () {
@@ -67,7 +68,7 @@ export class PostprocessStage extends RenderStage {
         const device = pipeline.device;
 
         const cmdBuff = pipeline.commandBuffers[0];
-  
+
         const camera = view.camera;
         const vp = camera.viewport;
         this._renderArea!.x = vp.x * camera.width;
@@ -84,8 +85,11 @@ export class PostprocessStage extends RenderStage {
         cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);
 
         // Postprocess
-        const pass = this._postprocessMaterial!.passes[POSTPROCESSPASS_INDEX];
-        const shader = ShaderPool.get(this._postprocessMaterial!.passes[POSTPROCESSPASS_INDEX].getShaderVariant());
+        //const pass = this._postprocessMaterial!.passes[POSTPROCESSPASS_INDEX];
+        //const shader = ShaderPool.get(this._postprocessMaterial!.passes[POSTPROCESSPASS_INDEX].getShaderVariant());
+        const builtinPostProcess = builtinResMgr.get<Material>('builtin-post-process-material');
+        const pass = builtinPostProcess.passes[0];
+        const shader = ShaderPool.get(pass.getShaderVariant());
 
         const inputAssembler = pipeline.quadIA;
         var pso:PipelineState|null = null;
diff --git a/cocos/core/renderer/core/memory-pools.ts b/cocos/core/renderer/core/memory-pools.ts
index d30567a9b..a60f062f7 100644
--- a/cocos/core/renderer/core/memory-pools.ts
+++ b/cocos/core/renderer/core/memory-pools.ts
@@ -946,16 +946,28 @@ export const NodePool = new BufferPool<PoolType.NODE, typeof NodeView, INodeView
 export enum RootView {
     CUMULATIVE_TIME,
     FRAME_TIME,
+    DEFERRED_LIGHT_PASS,
+    DEFERRED_LIGHT_PASS_SHADER,
+    DEFERRED_POST_PASS,
+    DEFERRED_POST_PASS_SHADER,
     COUNT
 }
 interface IRootViewType extends BufferTypeManifest<typeof RootView> {
     [RootView.CUMULATIVE_TIME]: number;
     [RootView.FRAME_TIME]: number;
+    [RootView.DEFERRED_LIGHT_PASS]: PassHandle;
+    [RootView.DEFERRED_LIGHT_PASS_SHADER]: ShaderHandle;
+    [RootView.DEFERRED_POST_PASS]: PassHandle;
+    [RootView.DEFERRED_POST_PASS_SHADER]: ShaderHandle;
     [RootView.COUNT]: never;
 }
 const rootViewDataType: BufferDataTypeManifest<typeof RootView> = {
     [RootView.CUMULATIVE_TIME]: BufferDataType.FLOAT32,
     [RootView.FRAME_TIME]: BufferDataType.FLOAT32,
+    [RootView.DEFERRED_LIGHT_PASS]: BufferDataType.UINT32,
+    [RootView.DEFERRED_LIGHT_PASS_SHADER]: BufferDataType.UINT32,
+    [RootView.DEFERRED_POST_PASS]: BufferDataType.UINT32,
+    [RootView.DEFERRED_POST_PASS_SHADER]: BufferDataType.UINT32,
     [RootView.COUNT]: BufferDataType.NEVER,
 };
 // Theoretically we only have to declare the type view here while all the other arguments can be inferred.
diff --git a/cocos/core/root.ts b/cocos/core/root.ts
index c904ab4e9..7ed343955 100644
--- a/cocos/core/root.ts
+++ b/cocos/core/root.ts
@@ -42,7 +42,8 @@ import { UI } from './renderer/ui/ui';
 import { legacyCC } from './global-exports';
 import { RenderWindow, IRenderWindowInfo } from './renderer/core/render-window';
 import { ColorAttachment, DepthStencilAttachment, RenderPassInfo, StoreOp, Device } from './gfx';
-import { RootHandle, RootPool, RootView, NULL_HANDLE } from './renderer/core/memory-pools';
+import { RootHandle, RootPool, RootView, NULL_HANDLE, LightHandle, PassHandle, ShaderHandle } from './renderer/core/memory-pools';
+import { Material } from "./assets";
 
 /**
  * @zh
@@ -154,6 +155,22 @@ export class Root {
         return RootPool.get(this._poolHandle, RootView.FRAME_TIME);
     }
 
+    public get deferredLightPassHandle (): PassHandle {
+        return RootPool.get(this._poolHandle, RootView.DEFERRED_LIGHT_PASS);
+    }
+
+    public get deferredLightPassShaderHandle (): ShaderHandle {
+        return RootPool.get(this._poolHandle, RootView.DEFERRED_LIGHT_PASS_SHADER);
+    }
+
+    public get deferredPostPassHandle (): PassHandle {
+        return RootPool.get(this._poolHandle, RootView.DEFERRED_POST_PASS);
+    }
+
+    public get deferredPostPassShaderHandle(): ShaderHandle  {
+        return RootPool.get(this._poolHandle, RootView.DEFERRED_POST_PASS_SHADER);
+    }
+
     /**
      * @zh
      * 一秒内的累计帧数
@@ -240,6 +257,7 @@ export class Root {
      */
     public initialize (info: IRootInfo): Promise<void> {
         this._poolHandle = RootPool.alloc();
+
         const colorAttachment = new ColorAttachment();
         const depthStencilAttachment = new DepthStencilAttachment();
         depthStencilAttachment.depthStoreOp = StoreOp.DISCARD;
@@ -259,6 +277,16 @@ export class Root {
                 const width = legacyCC.game.canvas.width;
                 const height = legacyCC.game.canvas.height;
                 this.resize(width, height);
+
+                const builinDeferred = builtinResMgr.get<Material>('builtin-deferred-material');
+                const passLit = builinDeferred.passes[1];
+                RootPool.set(this._poolHandle, RootView.DEFERRED_LIGHT_PASS, passLit.handle);
+                RootPool.set(this._poolHandle, RootView.DEFERRED_LIGHT_PASS_SHADER, passLit.getShaderVariant());
+
+                const builtinPostProcess = builtinResMgr.get<Material>('builtin-post-process-material');
+                const passPost = builtinPostProcess.passes[0];
+                RootPool.set(this._poolHandle, RootView.DEFERRED_POST_PASS, passPost.handle);
+                RootPool.set(this._poolHandle, RootView.DEFERRED_POST_PASS_SHADER, passPost.getShaderVariant());
             }, this);
         });
     }
