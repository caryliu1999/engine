(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.effects = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  // tslint:disable
  // absolute essential effects
  var _default = [{
    "name": "builtin-billboard",
    "_uuid": "711ebe11-f673-4cd9-9a83-63c60ba54c5b",
    "techniques": [{
      "name": "add",
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 1,
            "blendSrcAlpha": 2,
            "blendDstAlpha": 1
          }]
        },
        "program": "builtin-billboard|vert:vs_main|tinted-fs:add",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        },
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "mainTiling_Offset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "tintColor": {
            "value": [0.5, 0.5, 0.5, 0.5],
            "type": 16
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-billboard|vert:vs_main|tinted-fs:add",
      "hash": 2143664850,
      "glsl3": {
        "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nlayout(std140) uniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "glsl1": {
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      },
      "glsl4": {
        "vert": "\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(set = 1, binding = 1) uniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 3) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 2) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "stageFlags": 1,
        "members": [{
          "name": "mainTiling_Offset",
          "type": 16,
          "count": 1
        }, {
          "name": "frameTile_velLenScale",
          "type": 16,
          "count": 1
        }, {
          "name": "scale",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "builtin",
        "defines": [],
        "binding": 1,
        "stageFlags": 1,
        "members": [{
          "name": "cc_size_rotation",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "FragConstants",
        "defines": [],
        "binding": 2,
        "stageFlags": 16,
        "members": [{
          "name": "tintColor",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 3
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 1
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 2
      }]
    }]
  }, {
    "name": "builtin-graphics",
    "_uuid": "1c02ae6f-4492-4915-b8f8-7492a3b1e4cd",
    "techniques": [{
      "passes": [{
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 1,
            "blendDst": 4,
            "blendSrcAlpha": 1,
            "blendDstAlpha": 4
          }]
        },
        "rasterizerState": {
          "cullMode": 0
        },
        "program": "builtin-graphics|vs:vert|fs:frag",
        "depthStencilState": {
          "depthTest": false,
          "depthWrite": false
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-graphics|vs:vert|fs:frag",
      "hash": 3946667351,
      "glsl3": {
        "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin float a_dist;\nout float v_dist;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * cc_matWorld * pos;\n  v_color = a_color;\n  v_dist = a_dist;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nin vec4 v_color;\nin float v_dist;\nvec4 frag () {\n  vec4 o = v_color;\n    float aa = fwidth(v_dist);\n  float alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\n  o.rgb *= o.a;\n  o *= alpha;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute float a_dist;\nvarying float v_dist;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * cc_matWorld * pos;\n  v_color = a_color;\n  v_dist = a_dist;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\nvarying vec4 v_color;\nvarying float v_dist;\nvec4 frag () {\n  vec4 o = v_color;\n    #ifdef GL_OES_standard_derivatives\n      float aa = fwidth(v_dist);\n    #else\n      float aa = 0.05;\n    #endif\n  float alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\n  o.rgb *= o.a;\n  o *= alpha;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nlayout(location = 2) in float a_dist;\nlayout(location = 1) out float v_dist;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * cc_matWorld * pos;\n  v_color = a_color;\n  v_dist = a_dist;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nlayout(location = 0) in vec4 v_color;\nlayout(location = 1) in float v_dist;\nvec4 frag () {\n  vec4 o = v_color;\n    float aa = fwidth(v_dist);\n  float alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\n  o.rgb *= o.a;\n  o *= alpha;\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [],
      "blocks": [],
      "samplers": [],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 1
      }, {
        "name": "a_dist",
        "type": 13,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 11,
        "location": 2
      }]
    }]
  }, {
    "name": "builtin-particle-gpu",
    "_uuid": "971bdb23-3ff6-43eb-b422-1c30165a3663",
    "techniques": [{
      "name": "add",
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 1,
            "blendSrcAlpha": 2,
            "blendDstAlpha": 1
          }]
        },
        "program": "builtin-particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        },
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "mainTiling_Offset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "tintColor": {
            "value": [0.5, 0.5, 0.5, 0.5],
            "type": 16
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
      "hash": 3696836305,
      "glsl3": {
        "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(std140) uniform SampleConstants {\n  vec4 u_sampleInfo;\n};\nlayout(std140) uniform TickConstants {\n  vec4 u_worldRot;\n  vec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord;\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D color_over_time_tex0;\n  layout(std140) uniform ColorConstant {\n    int u_color_mode;\n  };\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D rotation_over_time_tex0;\n  layout(std140) uniform RotationConstant {\n    int u_rotation_mode;\n  };\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D size_over_time_tex0;\n  layout(std140) uniform SizeConstant {\n    int u_size_mode;\n  };\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D force_over_time_tex0;\n  layout(std140) uniform ForceConstant {\n    int u_force_mode;\n    int u_force_space;\n  };\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D velocity_over_time_tex0;\n  layout(std140) uniform VelocityConstant {\n    int u_velocity_mode;\n    int u_velocity_space;\n  };\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  uniform sampler2D texture_animation_tex0;\n  layout(std140) uniform AnimationConstant {\n    vec4 u_anim_info;\n  };\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "glsl1": {
        "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord;\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture2D(tex, coord);\n    vec4 b = texture2D(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture2D(tex, coord);\n    vec4 b = texture2D(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D color_over_time_tex0;\n  uniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D rotation_over_time_tex0;\n  uniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D size_over_time_tex0;\n  uniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D force_over_time_tex0;\n  uniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D velocity_over_time_tex0;\n  uniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  uniform sampler2D texture_animation_tex0;\n  uniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture2D(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      },
      "glsl4": {
        "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(set = 1, binding = 1) uniform SampleConstants {\n  vec4 u_sampleInfo;\n};\nlayout(set = 1, binding = 2) uniform TickConstants {\n  vec4 u_worldRot;\n  vec4 u_timeDelta;\n};\nlayout(location = 0) in vec4 a_position_starttime;\nlayout(location = 1) in vec4 a_size_uv;\nlayout(location = 2) in vec4 a_rotation_uv;\nlayout(location = 3) in vec4 a_color;\nlayout(location = 4) in vec4 a_dir_life;\nlayout(location = 5) in float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord;\n  layout(location = 7) in vec3 a_texCoord3;\n  layout(location = 8) in vec3 a_normal;\n  layout(location = 9) in vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 10) uniform sampler2D color_over_time_tex0;\n  layout(set = 1, binding = 3) uniform ColorConstant {\n    int u_color_mode;\n  };\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 11) uniform sampler2D rotation_over_time_tex0;\n  layout(set = 1, binding = 4) uniform RotationConstant {\n    int u_rotation_mode;\n  };\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 12) uniform sampler2D size_over_time_tex0;\n  layout(set = 1, binding = 5) uniform SizeConstant {\n    int u_size_mode;\n  };\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 13) uniform sampler2D force_over_time_tex0;\n  layout(set = 1, binding = 6) uniform ForceConstant {\n    int u_force_mode;\n    int u_force_space;\n  };\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 14) uniform sampler2D velocity_over_time_tex0;\n  layout(set = 1, binding = 7) uniform VelocityConstant {\n    int u_velocity_mode;\n    int u_velocity_space;\n  };\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  layout(set = 1, binding = 15) uniform sampler2D texture_animation_tex0;\n  layout(set = 1, binding = 8) uniform AnimationConstant {\n    vec4 u_anim_info;\n  };\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 16) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 9) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_RENDER_MODE",
        "type": "number",
        "range": [0, 4]
      }, {
        "name": "COLOR_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "ROTATION_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "SIZE_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "FORCE_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "VELOCITY_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "TEXTURE_ANIMATION_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "CC_USE_WORLD_SPACE",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "stageFlags": 1,
        "members": [{
          "name": "mainTiling_Offset",
          "type": 16,
          "count": 1
        }, {
          "name": "frameTile_velLenScale",
          "type": 16,
          "count": 1
        }, {
          "name": "scale",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "SampleConstants",
        "defines": [],
        "binding": 1,
        "stageFlags": 1,
        "members": [{
          "name": "u_sampleInfo",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "TickConstants",
        "defines": [],
        "binding": 2,
        "stageFlags": 1,
        "members": [{
          "name": "u_worldRot",
          "type": 16,
          "count": 1
        }, {
          "name": "u_timeDelta",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "ColorConstant",
        "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
        "binding": 3,
        "stageFlags": 1,
        "members": [{
          "name": "u_color_mode",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "RotationConstant",
        "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
        "binding": 4,
        "stageFlags": 1,
        "members": [{
          "name": "u_rotation_mode",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "SizeConstant",
        "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
        "binding": 5,
        "stageFlags": 1,
        "members": [{
          "name": "u_size_mode",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "ForceConstant",
        "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
        "binding": 6,
        "stageFlags": 1,
        "members": [{
          "name": "u_force_mode",
          "type": 5,
          "count": 1
        }, {
          "name": "u_force_space",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "VelocityConstant",
        "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
        "binding": 7,
        "stageFlags": 1,
        "members": [{
          "name": "u_velocity_mode",
          "type": 5,
          "count": 1
        }, {
          "name": "u_velocity_space",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "AnimationConstant",
        "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
        "binding": 8,
        "stageFlags": 1,
        "members": [{
          "name": "u_anim_info",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "FragConstants",
        "defines": [],
        "binding": 9,
        "stageFlags": 16,
        "members": [{
          "name": "tintColor",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "color_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
        "stageFlags": 1,
        "binding": 10
      }, {
        "name": "rotation_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
        "stageFlags": 1,
        "binding": 11
      }, {
        "name": "size_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
        "stageFlags": 1,
        "binding": 12
      }, {
        "name": "force_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
        "stageFlags": 1,
        "binding": 13
      }, {
        "name": "velocity_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
        "stageFlags": 1,
        "binding": 14
      }, {
        "name": "texture_animation_tex0",
        "type": 28,
        "count": 1,
        "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
        "stageFlags": 1,
        "binding": 15
      }, {
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 16
      }],
      "attributes": [{
        "name": "a_position_starttime",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 0
      }, {
        "name": "a_size_uv",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 1
      }, {
        "name": "a_rotation_uv",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 2
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 3
      }, {
        "name": "a_dir_life",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 4
      }, {
        "name": "a_rndSeed",
        "type": 13,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 11,
        "location": 5
      }, {
        "name": "a_texCoord",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "stageFlags": 1,
        "format": 32,
        "location": 6
      }, {
        "name": "a_texCoord3",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "stageFlags": 1,
        "format": 32,
        "location": 7
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "stageFlags": 1,
        "format": 32,
        "location": 8
      }, {
        "name": "a_color1",
        "type": 16,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "stageFlags": 1,
        "format": 44,
        "location": 9
      }]
    }]
  }, {
    "name": "builtin-particle-trail",
    "_uuid": "17debcc3-0a6b-4b8a-b00b-dc58b885581e",
    "techniques": [{
      "name": "add",
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 1,
            "blendSrcAlpha": 2,
            "blendDstAlpha": 1
          }]
        },
        "program": "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        },
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "mainTiling_Offset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "frameTile_velLenScale": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "tintColor": {
            "value": [0.5, 0.5, 0.5, 0.5],
            "type": 16
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
      "hash": 4115155772,
      "glsl3": {
        "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\n  precision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  in vec2 uv;\n  in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    in vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  layout(std140) uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "glsl1": {
        "vert": "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\n  precision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  varying vec2 uv;\n  varying vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    varying vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform vec4 tintColor;\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nvoid main() { gl_FragColor = add(); }"
      },
      "glsl4": {
        "vert": "\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  layout(location = 2) out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\n  precision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  layout(location = 0) in vec2 uv;\n  layout(location = 1) in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    layout(location = 2) in vec3 vBarycentric;\n  #endif\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n  layout(set = 1, binding = 1) uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_RENDER_MODE",
        "type": "number",
        "range": [0, 4]
      }, {
        "name": "CC_DRAW_WIRE_FRAME",
        "type": "boolean"
      }, {
        "name": "CC_USE_WORLD_SPACE",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "stageFlags": 1,
        "members": [{
          "name": "mainTiling_Offset",
          "type": 16,
          "count": 1
        }, {
          "name": "frameTile_velLenScale",
          "type": 16,
          "count": 1
        }, {
          "name": "scale",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "FragConstants",
        "defines": [],
        "binding": 1,
        "stageFlags": 16,
        "members": [{
          "name": "tintColor",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 2
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_texCoord",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 1
      }, {
        "name": "a_texCoord1",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 2
      }, {
        "name": "a_texCoord2",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 3
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 4
      }]
    }]
  }, {
    "name": "builtin-particle",
    "_uuid": "d1346436-ac96-4271-b863-1f4fdead95b0",
    "techniques": [{
      "name": "add",
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 1,
            "blendSrcAlpha": 2,
            "blendDstAlpha": 1
          }]
        },
        "program": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        },
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "mainTiling_Offset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "tintColor": {
            "value": [0.5, 0.5, 0.5, 0.5],
            "type": 16
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
      "hash": 66662317,
      "glsl3": {
        "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      },
      "glsl4": {
        "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 5) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 5) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_RENDER_MODE",
        "type": "number",
        "range": [0, 4]
      }, {
        "name": "CC_USE_WORLD_SPACE",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "stageFlags": 1,
        "members": [{
          "name": "mainTiling_Offset",
          "type": 16,
          "count": 1
        }, {
          "name": "frameTile_velLenScale",
          "type": 16,
          "count": 1
        }, {
          "name": "scale",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "FragConstants",
        "defines": [],
        "binding": 1,
        "stageFlags": 16,
        "members": [{
          "name": "tintColor",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 2
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_texCoord",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 1
      }, {
        "name": "a_texCoord1",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 2
      }, {
        "name": "a_texCoord2",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 3
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 4
      }, {
        "name": "a_color1",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "stageFlags": 1,
        "format": 32,
        "location": 5
      }, {
        "name": "a_texCoord3",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "stageFlags": 1,
        "format": 32,
        "location": 6
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "stageFlags": 1,
        "format": 32,
        "location": 7
      }]
    }]
  }, {
    "name": "builtin-sprite",
    "_uuid": "60f7195c-ec2a-45eb-ba94-8955f60e81d0",
    "techniques": [{
      "passes": [{
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 4,
            "blendDstAlpha": 4
          }]
        },
        "rasterizerState": {
          "cullMode": 0
        },
        "program": "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
        "depthStencilState": {
          "depthTest": false,
          "depthWrite": false
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
      "hash": 2679078392,
      "glsl3": {
        "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec4 CCSampleTexture(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n    return texture(tex, uv);\n#endif\n}\nin vec4 color;\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleTexture(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec4 CCSampleTexture(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\n    return texture2D(tex, uv);\n#endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleTexture(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec4 CCSampleTexture(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n    return texture(tex, uv);\n#endif\n}\nlayout(location = 0) in vec4 color;\n#if USE_TEXTURE\n  layout(location = 1) in vec2 uv0;\n  layout(set = 2, binding = 10) uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleTexture(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": ["USE_LOCAL"]
          }],
          "samplers": [{
            "name": "cc_spriteTexture",
            "defines": ["USE_TEXTURE"]
          }]
        }
      },
      "defines": [{
        "name": "USE_LOCAL",
        "type": "boolean"
      }, {
        "name": "USE_PIXEL_ALIGNMENT",
        "type": "boolean"
      }, {
        "name": "CC_USE_EMBEDDED_ALPHA",
        "type": "boolean"
      }, {
        "name": "USE_TEXTURE",
        "type": "boolean"
      }, {
        "name": "IS_GRAY",
        "type": "boolean"
      }],
      "blocks": [],
      "samplers": [],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 1
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 2
      }]
    }]
  }, {
    "name": "builtin-standard",
    "_uuid": "1baf0fc9-befa-459c-8bdd-af1a450a0319",
    "techniques": [{
      "name": "opaque",
      "passes": [{
        "program": "builtin-standard|standard-vs:vert|standard-fs:frag",
        "properties": {
          "tilingOffset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "mainColor": {
            "value": [1, 1, 1, 1],
            "type": 16,
            "handleInfo": ["albedo", 0, 16]
          },
          "albedoScale": {
            "value": [1, 1, 1],
            "type": 15,
            "handleInfo": ["albedoScaleAndCutoff", 0, 15]
          },
          "alphaThreshold": {
            "value": [0.5],
            "type": 13,
            "handleInfo": ["albedoScaleAndCutoff", 3, 13]
          },
          "occlusion": {
            "value": [1],
            "type": 13,
            "handleInfo": ["pbrParams", 0, 13]
          },
          "roughness": {
            "value": [0.8],
            "type": 13,
            "handleInfo": ["pbrParams", 1, 13]
          },
          "metallic": {
            "value": [0.6],
            "type": 13,
            "handleInfo": ["pbrParams", 2, 13]
          },
          "normalStrenth": {
            "value": [1],
            "type": 13,
            "handleInfo": ["pbrParams", 3, 13]
          },
          "emissive": {
            "value": [0, 0, 0, 1],
            "type": 16
          },
          "emissiveScale": {
            "value": [1, 1, 1],
            "type": 15,
            "handleInfo": ["emissiveScaleParam", 0, 15]
          },
          "mainTexture": {
            "value": "grey",
            "type": 28,
            "handleInfo": ["albedoMap", 0, 28]
          },
          "normalMap": {
            "value": "normal",
            "type": 28
          },
          "pbrMap": {
            "value": "grey",
            "type": 28
          },
          "metallicRoughnessMap": {
            "value": "grey",
            "type": 28
          },
          "occlusionMap": {
            "value": "white",
            "type": 28
          },
          "emissiveMap": {
            "value": "grey",
            "type": 28
          },
          "albedo": {
            "type": 16,
            "value": [1, 1, 1, 1]
          },
          "albedoScaleAndCutoff": {
            "type": 16,
            "value": [1, 1, 1, 0.5]
          },
          "pbrParams": {
            "type": 16,
            "value": [1, 0.8, 0.6, 1]
          },
          "emissiveScaleParam": {
            "type": 16,
            "value": [1, 1, 1, 0]
          },
          "albedoMap": {
            "type": 28,
            "value": "grey"
          }
        }
      }, {
        "phase": "forward-add",
        "propertyIndex": 0,
        "embeddedMacros": {
          "CC_FORWARD_ADD": true
        },
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 1,
            "blendDst": 1,
            "blendSrcAlpha": 0,
            "blendDstAlpha": 1
          }]
        },
        "program": "builtin-standard|standard-vs:vert|standard-fs:frag",
        "depthStencilState": {
          "depthFunc": 2,
          "depthTest": true,
          "depthWrite": false
        },
        "properties": {
          "tilingOffset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "mainColor": {
            "value": [1, 1, 1, 1],
            "type": 16,
            "handleInfo": ["albedo", 0, 16]
          },
          "albedoScale": {
            "value": [1, 1, 1],
            "type": 15,
            "handleInfo": ["albedoScaleAndCutoff", 0, 15]
          },
          "alphaThreshold": {
            "value": [0.5],
            "type": 13,
            "handleInfo": ["albedoScaleAndCutoff", 3, 13]
          },
          "occlusion": {
            "value": [1],
            "type": 13,
            "handleInfo": ["pbrParams", 0, 13]
          },
          "roughness": {
            "value": [0.8],
            "type": 13,
            "handleInfo": ["pbrParams", 1, 13]
          },
          "metallic": {
            "value": [0.6],
            "type": 13,
            "handleInfo": ["pbrParams", 2, 13]
          },
          "normalStrenth": {
            "value": [1],
            "type": 13,
            "handleInfo": ["pbrParams", 3, 13]
          },
          "emissive": {
            "value": [0, 0, 0, 1],
            "type": 16
          },
          "emissiveScale": {
            "value": [1, 1, 1],
            "type": 15,
            "handleInfo": ["emissiveScaleParam", 0, 15]
          },
          "mainTexture": {
            "value": "grey",
            "type": 28,
            "handleInfo": ["albedoMap", 0, 28]
          },
          "normalMap": {
            "value": "normal",
            "type": 28
          },
          "pbrMap": {
            "value": "grey",
            "type": 28
          },
          "metallicRoughnessMap": {
            "value": "grey",
            "type": 28
          },
          "occlusionMap": {
            "value": "white",
            "type": 28
          },
          "emissiveMap": {
            "value": "grey",
            "type": 28
          },
          "albedo": {
            "type": 16,
            "value": [1, 1, 1, 1]
          },
          "albedoScaleAndCutoff": {
            "type": 16,
            "value": [1, 1, 1, 0.5]
          },
          "pbrParams": {
            "type": 16,
            "value": [1, 0.8, 0.6, 1]
          },
          "emissiveScaleParam": {
            "type": 16,
            "value": [1, 1, 1, 0]
          },
          "albedoMap": {
            "type": 28,
            "value": "grey"
          }
        }
      }, {
        "phase": "shadow-add",
        "propertyIndex": 0,
        "rasterizerState": {
          "cullMode": 1
        },
        "program": "builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag"
      }]
    }],
    "shaders": [{
      "name": "builtin-standard|standard-vs:vert|standard-fs:frag",
      "hash": 967558702,
      "glsl3": {
        "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexID;\n    }\nlayout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(std140) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(std140) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(std140) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\nout vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if USE_VERTEX_COLOR\n  in vec3 a_color;\n  out vec3 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\nout float v_fog_factor;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec2 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\n      v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n#else\n      v_luv = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n#endif\n}\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_fog_factor = CC_TRANSFER_FOG(matWorld * In.position);\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n    v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec2 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\n#if CC_FORWARD_ADD\nlayout(std140) uniform CCForwardLight {\n  highp vec4 cc_lightPos[1];\n  vec4 cc_lightColor[1];\n  vec4 cc_lightSizeRangeAngle[1];\n  vec4 cc_lightDir[1];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < 1; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\nin vec4 v_shadowPos;\nuniform sampler2D cc_shadowMap;\nvec4 CCGetShadowFactorX1 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float depth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\nvec4 CCGetShadowFactorX5 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float depth = 0.0;\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth /= 5.0;\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\nvec4 CCGetShadowFactorX9 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float depth = 0.0;\n  for (int i = -1; i <= 1; i++) {\n    for (int j = -1; j <= 1; j++) {\n      depth += dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    }\n  }\n  depth /= 9.0;\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\nvec4 CCGetShadowFactorX25 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float depth = 0.0;\n  for (int i = -2; i <= 2; i++) {\n    for (int j = -2; j <= 2; j++) {\n      depth += dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    }\n  }\n  depth /= 25.0;\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\n  #endif\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L+V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.001);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightmap = texture(cc_lightingMap, v_luv);\n      finalColor = lightmap.a * lightmap.rgb + (1.0 - lightmap.a) * finalColor;\n    #endif\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    finalColor *= (diffuseContrib + specularContrib);\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    finalColor += (ambDiff.rgb * diffuse);\n    #if CC_USE_IBL\n      vec3 R = normalize(reflect(-V, N));\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n      finalColor += env * cc_ambientSky.w * specular;\n    #endif\n    finalColor = finalColor * s.occlusion;\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n      vec4 shadow = vec4(1.0);\n      float pcf = cc_shadowPCF.x + 0.001;\n      if (pcf > 3.0) {shadow = CCGetShadowFactorX25();}\n      else if (3.0 > pcf && pcf > 2.0) {shadow = CCGetShadowFactorX9();}\n      else if (2.0 > pcf && pcf > 1.0) {shadow = CCGetShadowFactorX5();}\n      else {shadow = CCGetShadowFactorX1();}\n      finalColor = shadow.rgb * shadow.a + finalColor * (1.0 - shadow.a);\n    #endif\n    return vec4(finalColor, s.albedo.a);\n  }\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\nin float v_fog_factor;\n#if USE_VERTEX_COLOR\n  in vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n            int pixelIndex = elementIndex;\n            vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n            vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n            return texture2D(tex, uv);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture2D(tex, x)),\n            decode32(texture2D(tex, y)),\n            decode32(texture2D(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\n#endif\nuniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\nvarying vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if USE_VERTEX_COLOR\n  attribute vec3 a_color;\n  varying vec3 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying float v_fog_factor;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec2 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\n      v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n#else\n      v_luv = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n#endif\n}\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_fog_factor = CC_TRANSFER_FOG(matWorld * In.position);\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n    v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform lowp vec4 cc_shadowColor;\nuniform lowp vec4 cc_shadowPCF;\nuniform lowp vec4 cc_shadowSize;\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec2 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\n#if CC_FORWARD_ADD\nuniform highp vec4 cc_lightPos[1];\nuniform vec4 cc_lightColor[1];\nuniform vec4 cc_lightSizeRangeAngle[1];\nuniform vec4 cc_lightDir[1];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < 1; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\nvarying vec4 v_shadowPos;\nuniform sampler2D cc_shadowMap;\nvec4 CCGetShadowFactorX1 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float depth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\nvec4 CCGetShadowFactorX5 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float depth = 0.0;\n  depth += dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth /= 5.0;\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\nvec4 CCGetShadowFactorX9 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float depth = 0.0;\n  for (int i = -1; i <= 1; i++) {\n    for (int j = -1; j <= 1; j++) {\n      depth += dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    }\n  }\n  depth /= 9.0;\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\nvec4 CCGetShadowFactorX25 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float depth = 0.0;\n  for (int i = -2; i <= 2; i++) {\n    for (int j = -2; j <= 2; j++) {\n      depth += dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    }\n  }\n  depth /= 25.0;\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\n  #endif\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L+V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.001);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightmap = texture2D(cc_lightingMap, v_luv);\n      finalColor = lightmap.a * lightmap.rgb + (1.0 - lightmap.a) * finalColor;\n    #endif\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    finalColor *= (diffuseContrib + specularContrib);\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    finalColor += (ambDiff.rgb * diffuse);\n    #if CC_USE_IBL\n      vec3 R = normalize(reflect(-V, N));\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n      finalColor += env * cc_ambientSky.w * specular;\n    #endif\n    finalColor = finalColor * s.occlusion;\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n      vec4 shadow = vec4(1.0);\n      float pcf = cc_shadowPCF.x + 0.001;\n      if (pcf > 3.0) {shadow = CCGetShadowFactorX25();}\n      else if (3.0 > pcf && pcf > 2.0) {shadow = CCGetShadowFactorX9();}\n      else if (2.0 > pcf && pcf > 1.0) {shadow = CCGetShadowFactorX5();}\n      else {shadow = CCGetShadowFactorX1();}\n      finalColor = shadow.rgb * shadow.a + finalColor * (1.0 - shadow.a);\n    #endif\n    return vec4(finalColor, s.albedo.a);\n  }\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\nvarying float v_fog_factor;\n#if USE_VERTEX_COLOR\n  varying vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\n#ifdef GL_EXT_shader_explicit_arithmetic_types_int16\n#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable\n#endif\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexIndex;\n    }\nlayout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u16vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    layout(location = 7) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(set = 2, binding = 3) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(set = 2, binding = 3) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\nlayout(location = 0) out vec4 v_shadowPos;\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec3 a_color;\n  layout(location = 1) out vec3 v_color;\n#endif\nlayout(location = 2) out vec3 v_position;\nlayout(location = 3) out vec3 v_normal;\nlayout(location = 4) out vec2 v_uv;\nlayout(location = 5) out vec2 v_uv1;\nlayout(location = 6) out float v_fog_factor;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec2 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\n      v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n#else\n      v_luv = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n#endif\n}\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_fog_factor = CC_TRANSFER_FOG(matWorld * In.position);\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n    v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if CC_USE_IBL\nlayout(set = 0, binding = 3) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec2 v_luv;\nlayout(set = 2, binding = 9) uniform sampler2D cc_lightingMap;\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\n#if CC_FORWARD_ADD\nlayout(set = 2, binding = 1) uniform CCForwardLight {\n  highp vec4 cc_lightPos[1];\n  vec4 cc_lightColor[1];\n  vec4 cc_lightSizeRangeAngle[1];\n  vec4 cc_lightDir[1];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < 1; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\nlayout(location = 0) in vec4 v_shadowPos;\nlayout(set = 0, binding = 4) uniform sampler2D cc_shadowMap;\nvec4 CCGetShadowFactorX1 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float depth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\nvec4 CCGetShadowFactorX5 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float depth = 0.0;\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth += dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  depth /= 5.0;\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\nvec4 CCGetShadowFactorX9 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float depth = 0.0;\n  for (int i = -1; i <= 1; i++) {\n    for (int j = -1; j <= 1; j++) {\n      depth += dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    }\n  }\n  depth /= 9.0;\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\nvec4 CCGetShadowFactorX25 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float depth = 0.0;\n  for (int i = -2; i <= 2; i++) {\n    for (int j = -2; j <= 2; j++) {\n      depth += dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    }\n  }\n  depth /= 25.0;\n  if (depth < (clipPos.z - 0.001)) return cc_shadowColor;\n  else return vec4(0);\n}\n  #endif\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L+V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.001);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightmap = texture(cc_lightingMap, v_luv);\n      finalColor = lightmap.a * lightmap.rgb + (1.0 - lightmap.a) * finalColor;\n    #endif\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    finalColor *= (diffuseContrib + specularContrib);\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    finalColor += (ambDiff.rgb * diffuse);\n    #if CC_USE_IBL\n      vec3 R = normalize(reflect(-V, N));\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n      finalColor += env * cc_ambientSky.w * specular;\n    #endif\n    finalColor = finalColor * s.occlusion;\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n      vec4 shadow = vec4(1.0);\n      float pcf = cc_shadowPCF.x + 0.001;\n      if (pcf > 3.0) {shadow = CCGetShadowFactorX25();}\n      else if (3.0 > pcf && pcf > 2.0) {shadow = CCGetShadowFactorX9();}\n      else if (2.0 > pcf && pcf > 1.0) {shadow = CCGetShadowFactorX5();}\n      else {shadow = CCGetShadowFactorX1();}\n      finalColor = shadow.rgb * shadow.a + finalColor * (1.0 - shadow.a);\n    #endif\n    return vec4(finalColor, s.albedo.a);\n  }\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(location = 2) in vec3 v_position;\nlayout(location = 4) in vec2 v_uv;\nlayout(location = 5) in vec2 v_uv1;\nlayout(location = 3) in vec3 v_normal;\nlayout(location = 6) in float v_fog_factor;\n#if USE_VERTEX_COLOR\n  layout(location = 1) in vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }, {
            "name": "CCShadow",
            "defines": []
          }],
          "samplers": [{
            "name": "cc_environment",
            "defines": ["CC_USE_IBL"]
          }, {
            "name": "cc_shadowMap",
            "defines": ["!CC_FORWARD_ADD", "CC_RECEIVE_SHADOW"]
          }]
        },
        "locals": {
          "blocks": [{
            "name": "CCMorph",
            "defines": ["CC_USE_MORPH"]
          }, {
            "name": "CCSkinningTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinningAnimation",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinning",
            "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCLocalBatched",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"]
          }, {
            "name": "CCLocal",
            "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
          }, {
            "name": "CCForwardLight",
            "defines": ["CC_FORWARD_ADD"]
          }],
          "samplers": [{
            "name": "cc_PositionDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
          }, {
            "name": "cc_NormalDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
          }, {
            "name": "cc_TangentDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
          }, {
            "name": "cc_jointTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "cc_lightingMap",
            "defines": ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
          }]
        }
      },
      "defines": [{
        "name": "CC_USE_MORPH",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_COUNT",
        "type": "number",
        "range": [2, 8]
      }, {
        "name": "CC_SUPPORT_FLOAT_TEXTURE",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_PRECOMPUTED",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_POSITION",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_NORMAL",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_TANGENT",
        "type": "boolean"
      }, {
        "name": "CC_USE_SKINNING",
        "type": "boolean"
      }, {
        "name": "CC_USE_BAKED_ANIMATION",
        "type": "boolean"
      }, {
        "name": "USE_INSTANCING",
        "type": "boolean"
      }, {
        "name": "USE_BATCHING",
        "type": "boolean"
      }, {
        "name": "USE_LIGHTMAP",
        "type": "boolean"
      }, {
        "name": "CC_USE_FOG",
        "type": "number",
        "range": [0, 4]
      }, {
        "name": "CC_FORWARD_ADD",
        "type": "boolean"
      }, {
        "name": "USE_VERTEX_COLOR",
        "type": "boolean"
      }, {
        "name": "USE_NORMAL_MAP",
        "type": "boolean"
      }, {
        "name": "HAS_SECOND_UV",
        "type": "boolean"
      }, {
        "name": "CC_USE_IBL",
        "type": "number",
        "range": [0, 2]
      }, {
        "name": "CC_RECEIVE_SHADOW",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }, {
        "name": "USE_ALBEDO_MAP",
        "type": "boolean"
      }, {
        "name": "ALBEDO_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "NORMAL_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "PBR_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "USE_PBR_MAP",
        "type": "boolean"
      }, {
        "name": "USE_METALLIC_ROUGHNESS_MAP",
        "type": "boolean"
      }, {
        "name": "USE_OCCLUSION_MAP",
        "type": "boolean"
      }, {
        "name": "USE_EMISSIVE_MAP",
        "type": "boolean"
      }, {
        "name": "EMISSIVE_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "USE_ALPHA_TEST",
        "type": "boolean"
      }, {
        "name": "ALPHA_TEST_CHANNEL",
        "type": "string",
        "options": ["a", "r"]
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "stageFlags": 17,
        "members": [{
          "name": "tilingOffset",
          "type": 16,
          "count": 1
        }, {
          "name": "albedo",
          "type": 16,
          "count": 1
        }, {
          "name": "albedoScaleAndCutoff",
          "type": 16,
          "count": 1
        }, {
          "name": "pbrParams",
          "type": 16,
          "count": 1
        }, {
          "name": "emissive",
          "type": 16,
          "count": 1
        }, {
          "name": "emissiveScaleParam",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "albedoMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_ALBEDO_MAP"],
        "stageFlags": 16,
        "binding": 1
      }, {
        "name": "normalMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_NORMAL_MAP"],
        "stageFlags": 16,
        "binding": 2
      }, {
        "name": "pbrMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_PBR_MAP"],
        "stageFlags": 16,
        "binding": 3
      }, {
        "name": "metallicRoughnessMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_METALLIC_ROUGHNESS_MAP"],
        "stageFlags": 16,
        "binding": 4
      }, {
        "name": "occlusionMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_OCCLUSION_MAP"],
        "stageFlags": 16,
        "binding": 5
      }, {
        "name": "emissiveMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_EMISSIVE_MAP"],
        "stageFlags": 16,
        "binding": 6
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 1
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 2
      }, {
        "name": "a_tangent",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 3
      }, {
        "name": "a_vertexId",
        "type": 13,
        "count": 1,
        "defines": ["CC_USE_MORPH"],
        "stageFlags": 1,
        "format": 11,
        "location": 6
      }, {
        "name": "a_joints",
        "type": 12,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "stageFlags": 1,
        "format": 42,
        "location": 4
      }, {
        "name": "a_weights",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "stageFlags": 1,
        "format": 44,
        "location": 5
      }, {
        "name": "a_jointAnimInfo",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 7
      }, {
        "name": "a_matWorld0",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 8
      }, {
        "name": "a_matWorld1",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 9
      }, {
        "name": "a_matWorld2",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 10
      }, {
        "name": "a_lightingMapUVParam",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 11
      }, {
        "name": "a_dyn_batch_id",
        "type": 13,
        "count": 1,
        "defines": ["!USE_INSTANCING", "USE_BATCHING"],
        "stageFlags": 1,
        "format": 11,
        "location": 12
      }, {
        "name": "a_color",
        "type": 15,
        "count": 1,
        "defines": ["USE_VERTEX_COLOR"],
        "stageFlags": 1,
        "format": 32,
        "location": 13
      }, {
        "name": "a_texCoord1",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 14
      }]
    }, {
      "name": "builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
      "hash": 1431638625,
      "glsl3": {
        "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexID;\n    }\nlayout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(std140) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(std140) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(std140) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n            int pixelIndex = elementIndex;\n            vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n            vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n            return texture2D(tex, uv);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture2D(tex, x)),\n            decode32(texture2D(tex, y)),\n            decode32(texture2D(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\nuniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\n#ifdef GL_EXT_shader_explicit_arithmetic_types_int16\n#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable\n#endif\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexIndex;\n    }\nlayout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u16vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    layout(location = 7) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(set = 2, binding = 3) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(set = 2, binding = 3) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCShadow",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCMorph",
            "defines": ["CC_USE_MORPH"]
          }, {
            "name": "CCSkinningTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinningAnimation",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinning",
            "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCLocalBatched",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"]
          }, {
            "name": "CCLocal",
            "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
          }],
          "samplers": [{
            "name": "cc_PositionDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
          }, {
            "name": "cc_NormalDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
          }, {
            "name": "cc_TangentDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
          }, {
            "name": "cc_jointTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }]
        }
      },
      "defines": [{
        "name": "CC_USE_MORPH",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_COUNT",
        "type": "number",
        "range": [2, 8]
      }, {
        "name": "CC_SUPPORT_FLOAT_TEXTURE",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_PRECOMPUTED",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_POSITION",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_NORMAL",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_TANGENT",
        "type": "boolean"
      }, {
        "name": "CC_USE_SKINNING",
        "type": "boolean"
      }, {
        "name": "CC_USE_BAKED_ANIMATION",
        "type": "boolean"
      }, {
        "name": "USE_INSTANCING",
        "type": "boolean"
      }, {
        "name": "USE_BATCHING",
        "type": "boolean"
      }, {
        "name": "USE_LIGHTMAP",
        "type": "boolean"
      }, {
        "name": "HAS_SECOND_UV",
        "type": "boolean"
      }, {
        "name": "USE_ALBEDO_MAP",
        "type": "boolean"
      }, {
        "name": "ALBEDO_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "USE_ALPHA_TEST",
        "type": "boolean"
      }, {
        "name": "ALPHA_TEST_CHANNEL",
        "type": "string",
        "options": ["a", "r"]
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "stageFlags": 17,
        "members": [{
          "name": "tilingOffset",
          "type": 16,
          "count": 1
        }, {
          "name": "albedo",
          "type": 16,
          "count": 1
        }, {
          "name": "albedoScaleAndCutoff",
          "type": 16,
          "count": 1
        }, {
          "name": "pbrParams",
          "type": 16,
          "count": 1
        }, {
          "name": "emissive",
          "type": 16,
          "count": 1
        }, {
          "name": "emissiveScaleParam",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "albedoMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_ALBEDO_MAP"],
        "stageFlags": 16,
        "binding": 1
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 1
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 2
      }, {
        "name": "a_tangent",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 3
      }, {
        "name": "a_vertexId",
        "type": 13,
        "count": 1,
        "defines": ["CC_USE_MORPH"],
        "stageFlags": 1,
        "format": 11,
        "location": 6
      }, {
        "name": "a_joints",
        "type": 12,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "stageFlags": 1,
        "format": 42,
        "location": 4
      }, {
        "name": "a_weights",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "stageFlags": 1,
        "format": 44,
        "location": 5
      }, {
        "name": "a_jointAnimInfo",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 7
      }, {
        "name": "a_matWorld0",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 8
      }, {
        "name": "a_matWorld1",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 9
      }, {
        "name": "a_matWorld2",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 10
      }, {
        "name": "a_lightingMapUVParam",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 11
      }, {
        "name": "a_dyn_batch_id",
        "type": 13,
        "count": 1,
        "defines": ["!USE_INSTANCING", "USE_BATCHING"],
        "stageFlags": 1,
        "format": 11,
        "location": 12
      }, {
        "name": "a_texCoord1",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 13
      }]
    }]
  }, {
    "name": "builtin-terrain",
    "_uuid": "1d08ef62-a503-4ce2-8b9a-46c90873f7d3",
    "techniques": [{
      "name": "opaque",
      "passes": [{
        "program": "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
        "properties": {
          "UVScale": {
            "value": [1, 1, 1, 1],
            "type": 16
          },
          "lightMapUVParam": {
            "value": [0, 0, 0, 0],
            "type": 16
          },
          "weightMap": {
            "value": "black",
            "type": 28
          },
          "detailMap0": {
            "value": "grey",
            "type": 28
          },
          "detailMap1": {
            "value": "grey",
            "type": 28
          },
          "detailMap2": {
            "value": "grey",
            "type": 28
          },
          "detailMap3": {
            "value": "grey",
            "type": 28
          },
          "lightMap": {
            "value": "grey",
            "type": 28
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
      "hash": 298856331,
      "glsl3": {
        "vert": "\n  precision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n  in vec3 a_position;\n  in vec3 a_normal;\n  in vec2 a_texCoord;\n  out vec2 uvw;\n  out vec2 uv0;\n  out vec2 uv1;\n  out vec2 uv2;\n  out vec2 uv3;\n  out vec2 luv;\n  out vec3 diffuse;\n  out float factor_fog;\n  layout(std140) uniform TexCoords {\n    vec4 UVScale;\n    vec4 lightMapUVParam;\n  };\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    factor_fog = CC_TRANSFER_FOG(vec4(worldPos, 1));\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  in vec2 uvw;\n  in vec2 uv0;\n  in vec2 uv1;\n  in vec2 uv2;\n  in vec2 uv3;\n  in vec3 diffuse;\n  in vec2 luv;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\n  uniform sampler2D lightMap;\n  in float factor_fog;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n    color += texture(detailMap3, uv3) * w.a;\n  #else\n    color = texture(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, factor_fog), color.a);\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\n  precision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform highp mat4 cc_matWorld;\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n  attribute vec3 a_position;\n  attribute vec3 a_normal;\n  attribute vec2 a_texCoord;\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec2 luv;\n  varying vec3 diffuse;\n  varying float factor_fog;\n  uniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    factor_fog = CC_TRANSFER_FOG(vec4(worldPos, 1));\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec3 diffuse;\n  varying vec2 luv;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\n  uniform sampler2D lightMap;\n  varying float factor_fog;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture2D(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n    color += texture2D(detailMap3, uv3) * w.a;\n  #else\n    color = texture2D(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture2D(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, factor_fog), color.a);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\n  precision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n  layout(location = 0) in vec3 a_position;\n  layout(location = 1) in vec3 a_normal;\n  layout(location = 2) in vec2 a_texCoord;\n  layout(location = 0) out vec2 uvw;\n  layout(location = 1) out vec2 uv0;\n  layout(location = 2) out vec2 uv1;\n  layout(location = 3) out vec2 uv2;\n  layout(location = 4) out vec2 uv3;\n  layout(location = 5) out vec2 luv;\n  layout(location = 6) out vec3 diffuse;\n  layout(location = 7) out float factor_fog;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 UVScale;\n    vec4 lightMapUVParam;\n  };\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    factor_fog = CC_TRANSFER_FOG(vec4(worldPos, 1));\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  layout(location = 0) in vec2 uvw;\n  layout(location = 1) in vec2 uv0;\n  layout(location = 2) in vec2 uv1;\n  layout(location = 3) in vec2 uv2;\n  layout(location = 4) in vec2 uv3;\n  layout(location = 6) in vec3 diffuse;\n  layout(location = 5) in vec2 luv;\n  layout(set = 1, binding = 1) uniform sampler2D weightMap;\n  layout(set = 1, binding = 2) uniform sampler2D detailMap0;\n  layout(set = 1, binding = 3) uniform sampler2D detailMap1;\n  layout(set = 1, binding = 4) uniform sampler2D detailMap2;\n  layout(set = 1, binding = 5) uniform sampler2D detailMap3;\n  layout(set = 1, binding = 6) uniform sampler2D lightMap;\n  layout(location = 7) in float factor_fog;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n    color += texture(detailMap3, uv3) * w.a;\n  #else\n    color = texture(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, factor_fog), color.a);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_USE_FOG",
        "type": "number",
        "range": [0, 4]
      }, {
        "name": "CC_FORWARD_ADD",
        "type": "boolean"
      }, {
        "name": "LIGHT_MAP",
        "type": "number",
        "range": [0, 3]
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }, {
        "name": "LAYERS",
        "type": "number",
        "range": [0, 4]
      }],
      "blocks": [{
        "name": "TexCoords",
        "defines": [],
        "binding": 0,
        "stageFlags": 1,
        "members": [{
          "name": "UVScale",
          "type": 16,
          "count": 1
        }, {
          "name": "lightMapUVParam",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "weightMap",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 1
      }, {
        "name": "detailMap0",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 2
      }, {
        "name": "detailMap1",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 3
      }, {
        "name": "detailMap2",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 4
      }, {
        "name": "detailMap3",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 5
      }, {
        "name": "lightMap",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 6
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 1
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 2
      }]
    }]
  }, {
    "name": "builtin-unlit",
    "_uuid": "a3cd009f-0ab0-420d-9278-b9fdab939bbc",
    "techniques": [{
      "name": "opaque",
      "passes": [{
        "program": "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "tilingOffset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "mainColor": {
            "value": [1, 1, 1, 1],
            "type": 16
          },
          "colorScale": {
            "value": [1, 1, 1],
            "type": 15,
            "handleInfo": ["colorScaleAndCutoff", 0, 15]
          },
          "alphaThreshold": {
            "value": [0.5],
            "type": 13,
            "handleInfo": ["colorScaleAndCutoff", 3, 13]
          },
          "color": {
            "type": 16,
            "handleInfo": ["mainColor", 0, 16]
          },
          "colorScaleAndCutoff": {
            "type": 16,
            "value": [1, 1, 1, 0.5]
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
      "hash": 2713860986,
      "glsl3": {
        "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexID;\n    }\nlayout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(std140) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(std140) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(std140) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n#if USE_VERTEX_COLOR\n  in lowp vec4 a_color;\n  out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nout float factor_fog;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  factor_fog = CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nin float factor_fog;\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, factor_fog), o.a);\n  return CCFragOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n            int pixelIndex = elementIndex;\n            vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n            vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n            return texture2D(tex, uv);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture2D(tex, x)),\n            decode32(texture2D(tex, y)),\n            decode32(texture2D(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n#if USE_VERTEX_COLOR\n  attribute lowp vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform vec4 tilingOffset;\n#endif\nvarying float factor_fog;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  factor_fog = CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvarying float factor_fog;\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, factor_fog), o.a);\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\n#ifdef GL_EXT_shader_explicit_arithmetic_types_int16\n#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable\n#endif\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexIndex;\n    }\nlayout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u16vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    layout(location = 7) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(set = 2, binding = 3) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(set = 2, binding = 3) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n#if USE_VERTEX_COLOR\n  layout(location = 13) in lowp vec4 a_color;\n  layout(location = 0) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  layout(location = 1) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nlayout(location = 2) out float factor_fog;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  factor_fog = CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  layout(location = 1) in vec2 v_uv;\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 0) in lowp vec4 v_color;\n#endif\nlayout(location = 2) in float factor_fog;\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, factor_fog), o.a);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCMorph",
            "defines": ["CC_USE_MORPH"]
          }, {
            "name": "CCSkinningTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinningAnimation",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinning",
            "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCLocalBatched",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"]
          }, {
            "name": "CCLocal",
            "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
          }],
          "samplers": [{
            "name": "cc_PositionDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
          }, {
            "name": "cc_NormalDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
          }, {
            "name": "cc_TangentDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
          }, {
            "name": "cc_jointTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }]
        }
      },
      "defines": [{
        "name": "CC_USE_MORPH",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_COUNT",
        "type": "number",
        "range": [2, 8]
      }, {
        "name": "CC_SUPPORT_FLOAT_TEXTURE",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_PRECOMPUTED",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_POSITION",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_NORMAL",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_TANGENT",
        "type": "boolean"
      }, {
        "name": "CC_USE_SKINNING",
        "type": "boolean"
      }, {
        "name": "CC_USE_BAKED_ANIMATION",
        "type": "boolean"
      }, {
        "name": "USE_INSTANCING",
        "type": "boolean"
      }, {
        "name": "USE_BATCHING",
        "type": "boolean"
      }, {
        "name": "USE_LIGHTMAP",
        "type": "boolean"
      }, {
        "name": "CC_USE_FOG",
        "type": "number",
        "range": [0, 4]
      }, {
        "name": "CC_FORWARD_ADD",
        "type": "boolean"
      }, {
        "name": "USE_VERTEX_COLOR",
        "type": "boolean"
      }, {
        "name": "USE_TEXTURE",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }, {
        "name": "USE_ALPHA_TEST",
        "type": "boolean"
      }, {
        "name": "ALPHA_TEST_CHANNEL",
        "type": "string",
        "options": ["a", "r", "g", "b"]
      }],
      "blocks": [{
        "name": "TexCoords",
        "defines": ["USE_TEXTURE"],
        "binding": 0,
        "stageFlags": 1,
        "members": [{
          "name": "tilingOffset",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "Constant",
        "defines": [],
        "binding": 1,
        "stageFlags": 16,
        "members": [{
          "name": "mainColor",
          "type": 16,
          "count": 1
        }, {
          "name": "colorScaleAndCutoff",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": ["USE_TEXTURE"],
        "stageFlags": 16,
        "binding": 2
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 1
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 2
      }, {
        "name": "a_tangent",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 3
      }, {
        "name": "a_vertexId",
        "type": 13,
        "count": 1,
        "defines": ["CC_USE_MORPH"],
        "stageFlags": 1,
        "format": 11,
        "location": 6
      }, {
        "name": "a_joints",
        "type": 12,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "stageFlags": 1,
        "format": 42,
        "location": 4
      }, {
        "name": "a_weights",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "stageFlags": 1,
        "format": 44,
        "location": 5
      }, {
        "name": "a_jointAnimInfo",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 7
      }, {
        "name": "a_matWorld0",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 8
      }, {
        "name": "a_matWorld1",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 9
      }, {
        "name": "a_matWorld2",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 10
      }, {
        "name": "a_lightingMapUVParam",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 11
      }, {
        "name": "a_dyn_batch_id",
        "type": 13,
        "count": 1,
        "defines": ["!USE_INSTANCING", "USE_BATCHING"],
        "stageFlags": 1,
        "format": 11,
        "location": 12
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": ["USE_VERTEX_COLOR"],
        "stageFlags": 1,
        "format": 44,
        "location": 13
      }]
    }]
  }, {
    "name": "pipeline/planar-shadow",
    "_uuid": "9361fd90-ba52-4f84-aa93-6e878fd576ca",
    "techniques": [{
      "passes": [{
        "phase": "planarShadow",
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 4,
            "blendDstAlpha": 4
          }]
        },
        "program": "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false,
          "stencilTestFront": true,
          "stencilFuncFront": 5,
          "stencilPassOpFront": 2,
          "stencilRefBack": 128,
          "stencilRefFront": 128,
          "stencilReadMaskBack": 128,
          "stencilReadMaskFront": 128,
          "stencilWriteMaskBack": 128,
          "stencilWriteMaskFront": 128
        }
      }]
    }],
    "shaders": [{
      "name": "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
      "hash": 870436315,
      "glsl3": {
        "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexID;\n    }\nlayout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(std140) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(std140) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(std140) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n            int pixelIndex = elementIndex;\n            vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n            vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n            return texture2D(tex, uv);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture2D(tex, x)),\n            decode32(texture2D(tex, y)),\n            decode32(texture2D(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nuniform highp mat4 cc_matLightPlaneProj;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\n#ifdef GL_EXT_shader_explicit_arithmetic_types_int16\n#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable\n#endif\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexIndex;\n    }\nlayout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u16vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    layout(location = 7) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(set = 2, binding = 3) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(set = 2, binding = 3) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }, {
            "name": "CCShadow",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCMorph",
            "defines": ["CC_USE_MORPH"]
          }, {
            "name": "CCSkinningTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinningAnimation",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinning",
            "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCLocalBatched",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"]
          }, {
            "name": "CCLocal",
            "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
          }],
          "samplers": [{
            "name": "cc_PositionDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
          }, {
            "name": "cc_NormalDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
          }, {
            "name": "cc_TangentDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
          }, {
            "name": "cc_jointTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }]
        }
      },
      "defines": [{
        "name": "CC_USE_MORPH",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_COUNT",
        "type": "number",
        "range": [2, 8]
      }, {
        "name": "CC_SUPPORT_FLOAT_TEXTURE",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_PRECOMPUTED",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_POSITION",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_NORMAL",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_TANGENT",
        "type": "boolean"
      }, {
        "name": "CC_USE_SKINNING",
        "type": "boolean"
      }, {
        "name": "CC_USE_BAKED_ANIMATION",
        "type": "boolean"
      }, {
        "name": "USE_INSTANCING",
        "type": "boolean"
      }, {
        "name": "USE_BATCHING",
        "type": "boolean"
      }, {
        "name": "USE_LIGHTMAP",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [],
      "samplers": [],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 1
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 2
      }, {
        "name": "a_tangent",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 3
      }, {
        "name": "a_vertexId",
        "type": 13,
        "count": 1,
        "defines": ["CC_USE_MORPH"],
        "stageFlags": 1,
        "format": 11,
        "location": 6
      }, {
        "name": "a_joints",
        "type": 12,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "stageFlags": 1,
        "format": 42,
        "location": 4
      }, {
        "name": "a_weights",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "stageFlags": 1,
        "format": 44,
        "location": 5
      }, {
        "name": "a_jointAnimInfo",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 7
      }, {
        "name": "a_matWorld0",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 8
      }, {
        "name": "a_matWorld1",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 9
      }, {
        "name": "a_matWorld2",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 10
      }, {
        "name": "a_lightingMapUVParam",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
        "stageFlags": 1,
        "format": 44,
        "isInstanced": true,
        "location": 11
      }, {
        "name": "a_dyn_batch_id",
        "type": 13,
        "count": 1,
        "defines": ["!USE_INSTANCING", "USE_BATCHING"],
        "stageFlags": 1,
        "format": 11,
        "location": 12
      }]
    }]
  }, {
    "name": "pipeline/skybox",
    "_uuid": "511d2633-09a7-4bdd-ac42-f778032124b3",
    "techniques": [{
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "program": "pipeline/skybox|sky-vs:vert|sky-fs:frag",
        "priority": 245,
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        }
      }]
    }],
    "shaders": [{
      "name": "pipeline/skybox|sky-vs:vert|sky-fs:frag",
      "hash": 629379420,
      "glsl3": {
        "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nout mediump vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_matProj[0][0] / cc_matProj[1][1] * cc_cameraPos.w, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin mediump vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nvarying mediump vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_matProj[0][0] / cc_matProj[1][1] * cc_cameraPos.w, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying mediump vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\nlayout(location = 0) out mediump vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_matProj[0][0] / cc_matProj[1][1] * cc_cameraPos.w, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 0, binding = 3) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(location = 0) in mediump vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": [{
            "name": "cc_environment",
            "defines": []
          }]
        },
        "locals": {
          "blocks": [],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_USE_IBL",
        "type": "number",
        "range": [0, 2]
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }, {
        "name": "USE_RGBE_CUBEMAP",
        "type": "boolean"
      }],
      "blocks": [],
      "samplers": [],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 1
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 2
      }, {
        "name": "a_tangent",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 3
      }]
    }]
  }, {
    "name": "util/profiler",
    "_uuid": "871c3b6c-7379-419d-bda3-794b239ab90d",
    "techniques": [{
      "passes": [{
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 4,
            "blendDstAlpha": 4
          }]
        },
        "rasterizerState": {
          "cullMode": 0
        },
        "program": "util/profiler|profiler-vs:vert|profiler-fs:frag",
        "depthStencilState": {
          "depthTest": false,
          "depthWrite": false
        }
      }]
    }],
    "shaders": [{
      "name": "util/profiler|profiler-vs:vert|profiler-fs:frag",
      "hash": 4021376818,
      "glsl3": {
        "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nlayout(std140) uniform Constants {\n  vec4 offset;\n};\nlayout(std140) uniform PerFrameInfo {\n  vec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy;\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture(mainTexture, v_uv));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision mediump float;\nuniform mediump vec4 cc_screenSize;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy;\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 offset;\n};\nlayout(set = 1, binding = 1) uniform PerFrameInfo {\n  vec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy;\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "stageFlags": 1,
        "members": [{
          "name": "offset",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "PerFrameInfo",
        "defines": [],
        "binding": 1,
        "stageFlags": 1,
        "members": [{
          "name": "digits",
          "type": 16,
          "count": 20
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 2
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 32,
        "location": 0
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 44,
        "location": 1
      }]
    }]
  }, {
    "name": "util/splash-screen",
    "_uuid": "970b0598-bcb0-4714-91fb-2e81440dccd8",
    "techniques": [{
      "passes": [{
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 4,
            "blendDstAlpha": 4
          }]
        },
        "rasterizerState": {
          "cullMode": 0
        },
        "program": "util/splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
        "depthStencilState": {
          "depthTest": false,
          "depthWrite": false
        }
      }]
    }],
    "shaders": [{
      "name": "util/splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
      "hash": 2106901053,
      "glsl3": {
        "vert": "\nprecision mediump float;\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nlayout(std140) uniform splashFrag {\n  float u_precent;\n};\nvec4 frag () {\n  vec4 color = texture(mainTexture, v_uv);\n  float precent = clamp(u_precent, 0.0, 1.0);\n  color.xyz *= precent;\n  return color;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nuniform float u_precent;\nvec4 frag () {\n  vec4 color = texture2D(mainTexture, v_uv);\n  float precent = clamp(u_precent, 0.0, 1.0);\n  color.xyz *= precent;\n  return color;\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "glsl4": {
        "vert": "\nprecision mediump float;\nlayout(location = 0) in vec2 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 0) out vec2 v_uv;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 0) uniform splashFrag {\n  float u_precent;\n};\nvec4 frag () {\n  vec4 color = texture(mainTexture, v_uv);\n  float precent = clamp(u_precent, 0.0, 1.0);\n  color.xyz *= precent;\n  return color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [],
          "samplers": []
        },
        "locals": {
          "blocks": [],
          "samplers": []
        }
      },
      "defines": [],
      "blocks": [{
        "name": "splashFrag",
        "defines": [],
        "binding": 0,
        "stageFlags": 16,
        "members": [{
          "name": "u_precent",
          "type": 13,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "stageFlags": 16,
        "binding": 1
      }],
      "attributes": [{
        "name": "a_position",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 0
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "stageFlags": 1,
        "format": 21,
        "location": 1
      }]
    }]
  }];
  _exports.default = _default;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImU6L2QwMDQ1MjUyMC9HaXRodWIvZW5naW5lL2NvY29zL2NvcmUvM2QvYnVpbHRpbi9lZmZlY3RzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO2lCQUNlLENBQ2I7QUFDRSxZQUFRLG1CQURWO0FBRUUsYUFBUyxzQ0FGWDtBQUdFLGtCQUFjLENBQ1o7QUFBRSxjQUFRLEtBQVY7QUFBaUIsZ0JBQVUsQ0FBQztBQUFFLDJCQUFtQjtBQUFFLHNCQUFZO0FBQWQsU0FBckI7QUFBd0Msc0JBQWM7QUFBRSxxQkFBVyxDQUFDO0FBQUUscUJBQVMsSUFBWDtBQUFpQix3QkFBWSxDQUE3QjtBQUFnQyx3QkFBWSxDQUE1QztBQUErQyw2QkFBaUIsQ0FBaEU7QUFBbUUsNkJBQWlCO0FBQXBGLFdBQUQ7QUFBYixTQUF0RDtBQUFnSyxtQkFBVyw4Q0FBM0s7QUFBMk4sNkJBQXFCO0FBQUUsdUJBQWEsSUFBZjtBQUFxQix3QkFBYztBQUFuQyxTQUFoUDtBQUE0UixzQkFBYztBQUFFLHlCQUFlO0FBQUUscUJBQVMsTUFBWDtBQUFtQixvQkFBUTtBQUEzQixXQUFqQjtBQUFrRCwrQkFBcUI7QUFBRSxxQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBWDtBQUF5QixvQkFBUTtBQUFqQyxXQUF2RTtBQUE4Ryx1QkFBYTtBQUFFLHFCQUFTLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLENBQVg7QUFBaUMsb0JBQVE7QUFBekM7QUFBM0g7QUFBMVMsT0FBRDtBQUEzQixLQURZLENBSGhCO0FBTUUsZUFBVyxDQUNUO0FBQ0UsY0FBUSw4Q0FEVjtBQUVFLGNBQVEsVUFGVjtBQUdFLGVBQVM7QUFDUCw2ekpBRE87QUFFUDtBQUZPLE9BSFg7QUFPRSxlQUFTO0FBQ1AsdW1JQURPO0FBRVA7QUFGTyxPQVBYO0FBV0UsZUFBUztBQUNQLDg5SkFETztBQUVQO0FBRk8s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O0FBQStELHNCQUFjLENBQTdFO0FBQWdGLGtCQUFVLEVBQTFGO0FBQThGLG9CQUFZO0FBQTFHLE9BRlk7QUE1QmhCLEtBRFM7QUFOYixHQXh4QmEsQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlXHJcbi8vIGFic29sdXRlIGVzc2VudGlhbCBlZmZlY3RzXHJcbmV4cG9ydCBkZWZhdWx0IFtcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJidWlsdGluLWJpbGxib2FyZFwiLFxyXG4gICAgXCJfdXVpZFwiOiBcIjcxMWViZTExLWY2NzMtNGNkOS05YTgzLTYzYzYwYmE1NGM1YlwiLFxyXG4gICAgXCJ0ZWNobmlxdWVzXCI6IFtcclxuICAgICAgeyBcIm5hbWVcIjogXCJhZGRcIiwgXCJwYXNzZXNcIjogW3sgXCJyYXN0ZXJpemVyU3RhdGVcIjogeyBcImN1bGxNb2RlXCI6IDAgfSwgXCJibGVuZFN0YXRlXCI6IHsgXCJ0YXJnZXRzXCI6IFt7IFwiYmxlbmRcIjogdHJ1ZSwgXCJibGVuZFNyY1wiOiAyLCBcImJsZW5kRHN0XCI6IDEsIFwiYmxlbmRTcmNBbHBoYVwiOiAyLCBcImJsZW5kRHN0QWxwaGFcIjogMSB9XSB9LCBcInByb2dyYW1cIjogXCJidWlsdGluLWJpbGxib2FyZHx2ZXJ0OnZzX21haW58dGludGVkLWZzOmFkZFwiLCBcImRlcHRoU3RlbmNpbFN0YXRlXCI6IHsgXCJkZXB0aFRlc3RcIjogdHJ1ZSwgXCJkZXB0aFdyaXRlXCI6IGZhbHNlIH0sIFwicHJvcGVydGllc1wiOiB7IFwibWFpblRleHR1cmVcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjggfSwgXCJtYWluVGlsaW5nX09mZnNldFwiOiB7IFwidmFsdWVcIjogWzEsIDEsIDAsIDBdLCBcInR5cGVcIjogMTYgfSwgXCJ0aW50Q29sb3JcIjogeyBcInZhbHVlXCI6IFswLjUsIDAuNSwgMC41LCAwLjVdLCBcInR5cGVcIjogMTYgfSB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1iaWxsYm9hcmR8dmVydDp2c19tYWlufHRpbnRlZC1mczphZGRcIixcclxuICAgICAgICBcImhhc2hcIjogMjE0MzY2NDg1MCxcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDb25zdGFudHMge1xcbiAgdmVjNCBtYWluVGlsaW5nX09mZnNldDtcXG4gIHZlYzQgZnJhbWVUaWxlX3ZlbExlblNjYWxlO1xcbiAgdmVjNCBzY2FsZTtcXG59O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NMb2NhbCB7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZElUO1xcbiAgaGlnaHAgdmVjNCBjY19saWdodGluZ01hcFVWUGFyYW07XFxufTtcXG52ZWM0IHF1YXRlcm5pb25Gcm9tQXhpcyAodmVjMyB4QXhpcyx2ZWMzIHlBeGlzLHZlYzMgekF4aXMpe1xcbiAgbWF0MyBtID0gbWF0Myh4QXhpcyx5QXhpcyx6QXhpcyk7XFxuICBmbG9hdCB0cmFjZSA9IG1bMF1bMF0gKyBtWzFdWzFdICsgbVsyXVsyXTtcXG4gIHZlYzQgcXVhdDtcXG4gIGlmICh0cmFjZSA+IDAuKSB7XFxuICAgIGZsb2F0IHMgPSAwLjUgLyBzcXJ0KHRyYWNlICsgMS4wKTtcXG4gICAgcXVhdC53ID0gMC4yNSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzJdWzFdIC0gbVsxXVsyXSkgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsyXSAtIG1bMl1bMF0pICogcztcXG4gICAgcXVhdC56ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAqIHM7XFxuICB9IGVsc2UgaWYgKChtWzBdWzBdID4gbVsxXVsxXSkgJiYgKG1bMF1bMF0gPiBtWzJdWzJdKSkge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzBdWzBdIC0gbVsxXVsxXSAtIG1bMl1bMl0pO1xcbiAgICBxdWF0LncgPSAobVsyXVsxXSAtIG1bMV1bMl0pIC8gcztcXG4gICAgcXVhdC54ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueSA9IChtWzBdWzFdICsgbVsxXVswXSkgLyBzO1xcbiAgICBxdWF0LnogPSAobVswXVsyXSArIG1bMl1bMF0pIC8gcztcXG4gIH0gZWxzZSBpZiAobVsxXVsxXSA+IG1bMl1bMl0pIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsxXVsxXSAtIG1bMF1bMF0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzFdICsgbVsxXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAwLjI1ICogcztcXG4gICAgcXVhdC56ID0gKG1bMV1bMl0gKyBtWzJdWzFdKSAvIHM7XFxuICB9IGVsc2Uge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzJdWzJdIC0gbVswXVswXSAtIG1bMV1bMV0pO1xcbiAgICBxdWF0LncgPSAobVsxXVswXSAtIG1bMF1bMV0pIC8gcztcXG4gICAgcXVhdC54ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICAgIHF1YXQueSA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgICBxdWF0LnogPSAwLjI1ICogcztcXG4gIH1cXG4gIGZsb2F0IGxlbiA9IHF1YXQueCAqIHF1YXQueCArIHF1YXQueSAqIHF1YXQueSArIHF1YXQueiAqIHF1YXQueiArIHF1YXQudyAqIHF1YXQudztcXG4gIGlmIChsZW4gPiAwLikge1xcbiAgICBsZW4gPSAxLiAvIHNxcnQobGVuKTtcXG4gICAgcXVhdC54ID0gcXVhdC54ICogbGVuO1xcbiAgICBxdWF0LnkgPSBxdWF0LnkgKiBsZW47XFxuICAgIHF1YXQueiA9IHF1YXQueiAqIGxlbjtcXG4gICAgcXVhdC53ID0gcXVhdC53ICogbGVuO1xcbiAgfVxcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbnZlYzQgcXVhdGVybmlvbkZyb21FdWxlciAodmVjMyBhbmdsZSl7XFxuICBmbG9hdCB4ID0gYW5nbGUueCAvIDIuO1xcbiAgZmxvYXQgeSA9IGFuZ2xlLnkgLyAyLjtcXG4gIGZsb2F0IHogPSBhbmdsZS56IC8gMi47XFxuICBmbG9hdCBzeCA9IHNpbih4KTtcXG4gIGZsb2F0IGN4ID0gY29zKHgpO1xcbiAgZmxvYXQgc3kgPSBzaW4oeSk7XFxuICBmbG9hdCBjeSA9IGNvcyh5KTtcXG4gIGZsb2F0IHN6ID0gc2luKHopO1xcbiAgZmxvYXQgY3ogPSBjb3Moeik7XFxuICB2ZWM0IHF1YXQgPSB2ZWM0KDApO1xcbiAgcXVhdC54ID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xcbiAgcXVhdC55ID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xcbiAgcXVhdC56ID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xcbiAgcXVhdC53ID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbnZlYzQgcXVhdE11bHRpcGx5ICh2ZWM0IGEsIHZlYzQgYil7XFxuICB2ZWM0IHF1YXQ7XFxuICBxdWF0LnggPSBhLnggKiBiLncgKyBhLncgKiBiLnggKyBhLnkgKiBiLnogLSBhLnogKiBiLnk7XFxuICBxdWF0LnkgPSBhLnkgKiBiLncgKyBhLncgKiBiLnkgKyBhLnogKiBiLnggLSBhLnggKiBiLno7XFxuICBxdWF0LnogPSBhLnogKiBiLncgKyBhLncgKiBiLnogKyBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxuICBxdWF0LncgPSBhLncgKiBiLncgLSBhLnggKiBiLnggLSBhLnkgKiBiLnkgLSBhLnogKiBiLno7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudm9pZCByb3RhdGVWZWNGcm9tUXVhdCAoaW5vdXQgdmVjMyB2LCB2ZWM0IHEpe1xcbiAgZmxvYXQgaXggPSBxLncgKiB2LnggKyBxLnkgKiB2LnogLSBxLnogKiB2Lnk7XFxuICBmbG9hdCBpeSA9IHEudyAqIHYueSArIHEueiAqIHYueCAtIHEueCAqIHYuejtcXG4gIGZsb2F0IGl6ID0gcS53ICogdi56ICsgcS54ICogdi55IC0gcS55ICogdi54O1xcbiAgZmxvYXQgaXcgPSAtcS54ICogdi54IC0gcS55ICogdi55IC0gcS56ICogdi56O1xcbiAgdi54ID0gaXggKiBxLncgKyBpdyAqIC1xLnggKyBpeSAqIC1xLnogLSBpeiAqIC1xLnk7XFxuICB2LnkgPSBpeSAqIHEudyArIGl3ICogLXEueSArIGl6ICogLXEueCAtIGl4ICogLXEuejtcXG4gIHYueiA9IGl6ICogcS53ICsgaXcgKiAtcS56ICsgaXggKiAtcS55IC0gaXkgKiAtcS54O1xcbn1cXG52ZWMzIHJvdGF0ZUluTG9jYWxTcGFjZSAodmVjMyBwb3MsIHZlYzMgeEF4aXMsIHZlYzMgeUF4aXMsIHZlYzMgekF4aXMsIHZlYzQgcSl7XFxuICB2ZWM0IHZpZXdRdWF0ID0gcXVhdGVybmlvbkZyb21BeGlzKHhBeGlzLCB5QXhpcywgekF4aXMpO1xcbiAgdmVjNCByb3RRdWF0ID0gcXVhdE11bHRpcGx5KHZpZXdRdWF0LCBxKTtcXG4gIHJvdGF0ZVZlY0Zyb21RdWF0KHBvcywgcm90UXVhdCk7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIHJvdGF0ZUNvcm5lciAoaW5vdXQgdmVjMiBjb3JuZXIsIGZsb2F0IGFuZ2xlKXtcXG4gIGZsb2F0IHhPUyA9IGNvcyhhbmdsZSkgKiBjb3JuZXIueCAtIHNpbihhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGZsb2F0IHlPUyA9IHNpbihhbmdsZSkgKiBjb3JuZXIueCArIGNvcyhhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGNvcm5lci54ID0geE9TO1xcbiAgY29ybmVyLnkgPSB5T1M7XFxufVxcbm91dCBtZWRpdW1wIHZlYzIgdXY7XFxub3V0IG1lZGl1bXAgdmVjNCBjb2xvcjtcXG52b2lkIGNvbXB1dGVWZXJ0UG9zIChpbm91dCB2ZWM0IHBvcywgdmVjMiB2ZXJ0T2Zmc2V0LCB2ZWM0IHEsIHZlYzMgc1xcbiAgLCBtYXQ0IHZpZXdJbnZcXG4pIHtcXG4gIHZlYzMgdmlld1NwYWNlVmVydCA9IHZlYzModmVydE9mZnNldC54ICogcy54LCB2ZXJ0T2Zmc2V0LnkgKiBzLnksIDAuKTtcXG4gIHZlYzMgY2FtWCA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMF0sIHZpZXdJbnZbMV1bMF0sIHZpZXdJbnZbMl1bMF0pKTtcXG4gIHZlYzMgY2FtWSA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMV0sIHZpZXdJbnZbMV1bMV0sIHZpZXdJbnZbMl1bMV0pKTtcXG4gIHZlYzMgY2FtWiA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMl0sIHZpZXdJbnZbMV1bMl0sIHZpZXdJbnZbMl1bMl0pKTtcXG4gIHBvcy54eXogKz0gcm90YXRlSW5Mb2NhbFNwYWNlKHZpZXdTcGFjZVZlcnQsIGNhbVgsIGNhbVksIGNhbVosIHEpO1xcbn1cXG5pbiB2ZWMzIGFfcG9zaXRpb247XFxuaW4gdmVjMiBhX3RleENvb3JkO1xcbmluIHZlYzQgYV9jb2xvcjtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIGJ1aWx0aW4ge1xcbiAgdmVjNCBjY19zaXplX3JvdGF0aW9uO1xcbn07XFxudmVjNCB2c19tYWluKCkge1xcbiAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb24sIDEpO1xcbiAgcG9zID0gY2NfbWF0V29ybGQgKiBwb3M7XFxuICB2ZWMyIHZlcnRPZmZzZXQgPSBhX3RleENvb3JkLnh5IC0gMC41O1xcbiAgY29tcHV0ZVZlcnRQb3MocG9zLCB2ZXJ0T2Zmc2V0LCBxdWF0ZXJuaW9uRnJvbUV1bGVyKHZlYzMoMC4sIDAuLCBjY19zaXplX3JvdGF0aW9uLnopKSwgdmVjMyhjY19zaXplX3JvdGF0aW9uLnh5LCAwLiksIGNjX21hdFZpZXdJbnYpO1xcbiAgcG9zID0gY2NfbWF0Vmlld1Byb2ogKiBwb3M7XFxuICB1diA9IGFfdGV4Q29vcmQueHk7XFxuICBjb2xvciA9IGFfY29sb3I7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdnNfbWFpbigpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG5pbiB2ZWMyIHV2O1xcbmluIHZlYzQgY29sb3I7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFpblRleHR1cmU7XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBGcmFnQ29uc3RhbnRzIHtcXG4gIHZlYzQgdGludENvbG9yO1xcbn07XFxudmVjNCBhZGQgKCkge1xcbiAgdmVjNCBjb2wgPSAyLjAgKiBjb2xvciAqIHRpbnRDb2xvciAqIHRleHR1cmUobWFpblRleHR1cmUsIHV2KTtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY29sKTtcXG59XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gYWRkKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXc7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXdJbnY7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG52ZWM0IHF1YXRlcm5pb25Gcm9tQXhpcyAodmVjMyB4QXhpcyx2ZWMzIHlBeGlzLHZlYzMgekF4aXMpe1xcbiAgbWF0MyBtID0gbWF0Myh4QXhpcyx5QXhpcyx6QXhpcyk7XFxuICBmbG9hdCB0cmFjZSA9IG1bMF1bMF0gKyBtWzFdWzFdICsgbVsyXVsyXTtcXG4gIHZlYzQgcXVhdDtcXG4gIGlmICh0cmFjZSA+IDAuKSB7XFxuICAgIGZsb2F0IHMgPSAwLjUgLyBzcXJ0KHRyYWNlICsgMS4wKTtcXG4gICAgcXVhdC53ID0gMC4yNSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzJdWzFdIC0gbVsxXVsyXSkgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsyXSAtIG1bMl1bMF0pICogcztcXG4gICAgcXVhdC56ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAqIHM7XFxuICB9IGVsc2UgaWYgKChtWzBdWzBdID4gbVsxXVsxXSkgJiYgKG1bMF1bMF0gPiBtWzJdWzJdKSkge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzBdWzBdIC0gbVsxXVsxXSAtIG1bMl1bMl0pO1xcbiAgICBxdWF0LncgPSAobVsyXVsxXSAtIG1bMV1bMl0pIC8gcztcXG4gICAgcXVhdC54ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueSA9IChtWzBdWzFdICsgbVsxXVswXSkgLyBzO1xcbiAgICBxdWF0LnogPSAobVswXVsyXSArIG1bMl1bMF0pIC8gcztcXG4gIH0gZWxzZSBpZiAobVsxXVsxXSA+IG1bMl1bMl0pIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsxXVsxXSAtIG1bMF1bMF0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzFdICsgbVsxXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAwLjI1ICogcztcXG4gICAgcXVhdC56ID0gKG1bMV1bMl0gKyBtWzJdWzFdKSAvIHM7XFxuICB9IGVsc2Uge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzJdWzJdIC0gbVswXVswXSAtIG1bMV1bMV0pO1xcbiAgICBxdWF0LncgPSAobVsxXVswXSAtIG1bMF1bMV0pIC8gcztcXG4gICAgcXVhdC54ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICAgIHF1YXQueSA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgICBxdWF0LnogPSAwLjI1ICogcztcXG4gIH1cXG4gIGZsb2F0IGxlbiA9IHF1YXQueCAqIHF1YXQueCArIHF1YXQueSAqIHF1YXQueSArIHF1YXQueiAqIHF1YXQueiArIHF1YXQudyAqIHF1YXQudztcXG4gIGlmIChsZW4gPiAwLikge1xcbiAgICBsZW4gPSAxLiAvIHNxcnQobGVuKTtcXG4gICAgcXVhdC54ID0gcXVhdC54ICogbGVuO1xcbiAgICBxdWF0LnkgPSBxdWF0LnkgKiBsZW47XFxuICAgIHF1YXQueiA9IHF1YXQueiAqIGxlbjtcXG4gICAgcXVhdC53ID0gcXVhdC53ICogbGVuO1xcbiAgfVxcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbnZlYzQgcXVhdGVybmlvbkZyb21FdWxlciAodmVjMyBhbmdsZSl7XFxuICBmbG9hdCB4ID0gYW5nbGUueCAvIDIuO1xcbiAgZmxvYXQgeSA9IGFuZ2xlLnkgLyAyLjtcXG4gIGZsb2F0IHogPSBhbmdsZS56IC8gMi47XFxuICBmbG9hdCBzeCA9IHNpbih4KTtcXG4gIGZsb2F0IGN4ID0gY29zKHgpO1xcbiAgZmxvYXQgc3kgPSBzaW4oeSk7XFxuICBmbG9hdCBjeSA9IGNvcyh5KTtcXG4gIGZsb2F0IHN6ID0gc2luKHopO1xcbiAgZmxvYXQgY3ogPSBjb3Moeik7XFxuICB2ZWM0IHF1YXQgPSB2ZWM0KDApO1xcbiAgcXVhdC54ID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xcbiAgcXVhdC55ID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xcbiAgcXVhdC56ID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xcbiAgcXVhdC53ID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbnZlYzQgcXVhdE11bHRpcGx5ICh2ZWM0IGEsIHZlYzQgYil7XFxuICB2ZWM0IHF1YXQ7XFxuICBxdWF0LnggPSBhLnggKiBiLncgKyBhLncgKiBiLnggKyBhLnkgKiBiLnogLSBhLnogKiBiLnk7XFxuICBxdWF0LnkgPSBhLnkgKiBiLncgKyBhLncgKiBiLnkgKyBhLnogKiBiLnggLSBhLnggKiBiLno7XFxuICBxdWF0LnogPSBhLnogKiBiLncgKyBhLncgKiBiLnogKyBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxuICBxdWF0LncgPSBhLncgKiBiLncgLSBhLnggKiBiLnggLSBhLnkgKiBiLnkgLSBhLnogKiBiLno7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudm9pZCByb3RhdGVWZWNGcm9tUXVhdCAoaW5vdXQgdmVjMyB2LCB2ZWM0IHEpe1xcbiAgZmxvYXQgaXggPSBxLncgKiB2LnggKyBxLnkgKiB2LnogLSBxLnogKiB2Lnk7XFxuICBmbG9hdCBpeSA9IHEudyAqIHYueSArIHEueiAqIHYueCAtIHEueCAqIHYuejtcXG4gIGZsb2F0IGl6ID0gcS53ICogdi56ICsgcS54ICogdi55IC0gcS55ICogdi54O1xcbiAgZmxvYXQgaXcgPSAtcS54ICogdi54IC0gcS55ICogdi55IC0gcS56ICogdi56O1xcbiAgdi54ID0gaXggKiBxLncgKyBpdyAqIC1xLnggKyBpeSAqIC1xLnogLSBpeiAqIC1xLnk7XFxuICB2LnkgPSBpeSAqIHEudyArIGl3ICogLXEueSArIGl6ICogLXEueCAtIGl4ICogLXEuejtcXG4gIHYueiA9IGl6ICogcS53ICsgaXcgKiAtcS56ICsgaXggKiAtcS55IC0gaXkgKiAtcS54O1xcbn1cXG52ZWMzIHJvdGF0ZUluTG9jYWxTcGFjZSAodmVjMyBwb3MsIHZlYzMgeEF4aXMsIHZlYzMgeUF4aXMsIHZlYzMgekF4aXMsIHZlYzQgcSl7XFxuICB2ZWM0IHZpZXdRdWF0ID0gcXVhdGVybmlvbkZyb21BeGlzKHhBeGlzLCB5QXhpcywgekF4aXMpO1xcbiAgdmVjNCByb3RRdWF0ID0gcXVhdE11bHRpcGx5KHZpZXdRdWF0LCBxKTtcXG4gIHJvdGF0ZVZlY0Zyb21RdWF0KHBvcywgcm90UXVhdCk7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIHJvdGF0ZUNvcm5lciAoaW5vdXQgdmVjMiBjb3JuZXIsIGZsb2F0IGFuZ2xlKXtcXG4gIGZsb2F0IHhPUyA9IGNvcyhhbmdsZSkgKiBjb3JuZXIueCAtIHNpbihhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGZsb2F0IHlPUyA9IHNpbihhbmdsZSkgKiBjb3JuZXIueCArIGNvcyhhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGNvcm5lci54ID0geE9TO1xcbiAgY29ybmVyLnkgPSB5T1M7XFxufVxcbnZhcnlpbmcgbWVkaXVtcCB2ZWMyIHV2O1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IGNvbG9yO1xcbnZvaWQgY29tcHV0ZVZlcnRQb3MgKGlub3V0IHZlYzQgcG9zLCB2ZWMyIHZlcnRPZmZzZXQsIHZlYzQgcSwgdmVjMyBzXFxuICAsIG1hdDQgdmlld0ludlxcbikge1xcbiAgdmVjMyB2aWV3U3BhY2VWZXJ0ID0gdmVjMyh2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSwgMC4pO1xcbiAgdmVjMyBjYW1YID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVswXSwgdmlld0ludlsxXVswXSwgdmlld0ludlsyXVswXSkpO1xcbiAgdmVjMyBjYW1ZID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsxXSwgdmlld0ludlsxXVsxXSwgdmlld0ludlsyXVsxXSkpO1xcbiAgdmVjMyBjYW1aID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsyXSwgdmlld0ludlsxXVsyXSwgdmlld0ludlsyXVsyXSkpO1xcbiAgcG9zLnh5eiArPSByb3RhdGVJbkxvY2FsU3BhY2Uodmlld1NwYWNlVmVydCwgY2FtWCwgY2FtWSwgY2FtWiwgcSk7XFxufVxcbmF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbnVuaWZvcm0gdmVjNCBjY19zaXplX3JvdGF0aW9uO1xcbnZlYzQgdnNfbWFpbigpIHtcXG4gIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAxKTtcXG4gIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgdmVjMiB2ZXJ0T2Zmc2V0ID0gYV90ZXhDb29yZC54eSAtIDAuNTtcXG4gIGNvbXB1dGVWZXJ0UG9zKHBvcywgdmVydE9mZnNldCwgcXVhdGVybmlvbkZyb21FdWxlcih2ZWMzKDAuLCAwLiwgY2Nfc2l6ZV9yb3RhdGlvbi56KSksIHZlYzMoY2Nfc2l6ZV9yb3RhdGlvbi54eSwgMC4pLCBjY19tYXRWaWV3SW52KTtcXG4gIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgdXYgPSBhX3RleENvb3JkLnh5O1xcbiAgY29sb3IgPSBhX2NvbG9yO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZzX21haW4oKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG51bmlmb3JtIHZlYzQgdGludENvbG9yO1xcbnZlYzQgYWRkICgpIHtcXG4gIHZlYzQgY29sID0gMi4wICogY29sb3IgKiB0aW50Q29sb3IgKiB0ZXh0dXJlMkQobWFpblRleHR1cmUsIHV2KTtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY29sKTtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBhZGQoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xzbDRcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDApIHVuaWZvcm0gQ29uc3RhbnRzIHtcXG4gIHZlYzQgbWFpblRpbGluZ19PZmZzZXQ7XFxuICB2ZWM0IGZyYW1lVGlsZV92ZWxMZW5TY2FsZTtcXG4gIHZlYzQgc2NhbGU7XFxufTtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbnZlYzQgcXVhdGVybmlvbkZyb21BeGlzICh2ZWMzIHhBeGlzLHZlYzMgeUF4aXMsdmVjMyB6QXhpcyl7XFxuICBtYXQzIG0gPSBtYXQzKHhBeGlzLHlBeGlzLHpBeGlzKTtcXG4gIGZsb2F0IHRyYWNlID0gbVswXVswXSArIG1bMV1bMV0gKyBtWzJdWzJdO1xcbiAgdmVjNCBxdWF0O1xcbiAgaWYgKHRyYWNlID4gMC4pIHtcXG4gICAgZmxvYXQgcyA9IDAuNSAvIHNxcnQodHJhY2UgKyAxLjApO1xcbiAgICBxdWF0LncgPSAwLjI1IC8gcztcXG4gICAgcXVhdC54ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAqIHM7XFxuICAgIHF1YXQueSA9IChtWzBdWzJdIC0gbVsyXVswXSkgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVswXSAtIG1bMF1bMV0pICogcztcXG4gIH0gZWxzZSBpZiAoKG1bMF1bMF0gPiBtWzFdWzFdKSAmJiAobVswXVswXSA+IG1bMl1bMl0pKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMF1bMF0gLSBtWzFdWzFdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzJdWzFdIC0gbVsxXVsyXSkgLyBzO1xcbiAgICBxdWF0LnggPSAwLjI1ICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueiA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgfSBlbHNlIGlmIChtWzFdWzFdID4gbVsyXVsyXSkge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzFdWzFdIC0gbVswXVswXSAtIG1bMl1bMl0pO1xcbiAgICBxdWF0LncgPSAobVswXVsyXSAtIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC54ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueSA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gIH0gZWxzZSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMl1bMl0gLSBtWzBdWzBdIC0gbVsxXVsxXSk7XFxuICAgIHF1YXQudyA9IChtWzFdWzBdIC0gbVswXVsxXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsyXSArIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gKG1bMV1bMl0gKyBtWzJdWzFdKSAvIHM7XFxuICAgIHF1YXQueiA9IDAuMjUgKiBzO1xcbiAgfVxcbiAgZmxvYXQgbGVuID0gcXVhdC54ICogcXVhdC54ICsgcXVhdC55ICogcXVhdC55ICsgcXVhdC56ICogcXVhdC56ICsgcXVhdC53ICogcXVhdC53O1xcbiAgaWYgKGxlbiA+IDAuKSB7XFxuICAgIGxlbiA9IDEuIC8gc3FydChsZW4pO1xcbiAgICBxdWF0LnggPSBxdWF0LnggKiBsZW47XFxuICAgIHF1YXQueSA9IHF1YXQueSAqIGxlbjtcXG4gICAgcXVhdC56ID0gcXVhdC56ICogbGVuO1xcbiAgICBxdWF0LncgPSBxdWF0LncgKiBsZW47XFxuICB9XFxuICByZXR1cm4gcXVhdDtcXG59XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUV1bGVyICh2ZWMzIGFuZ2xlKXtcXG4gIGZsb2F0IHggPSBhbmdsZS54IC8gMi47XFxuICBmbG9hdCB5ID0gYW5nbGUueSAvIDIuO1xcbiAgZmxvYXQgeiA9IGFuZ2xlLnogLyAyLjtcXG4gIGZsb2F0IHN4ID0gc2luKHgpO1xcbiAgZmxvYXQgY3ggPSBjb3MoeCk7XFxuICBmbG9hdCBzeSA9IHNpbih5KTtcXG4gIGZsb2F0IGN5ID0gY29zKHkpO1xcbiAgZmxvYXQgc3ogPSBzaW4oeik7XFxuICBmbG9hdCBjeiA9IGNvcyh6KTtcXG4gIHZlYzQgcXVhdCA9IHZlYzQoMCk7XFxuICBxdWF0LnggPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XFxuICBxdWF0LnkgPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XFxuICBxdWF0LnogPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XFxuICBxdWF0LncgPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudmVjNCBxdWF0TXVsdGlwbHkgKHZlYzQgYSwgdmVjNCBiKXtcXG4gIHZlYzQgcXVhdDtcXG4gIHF1YXQueCA9IGEueCAqIGIudyArIGEudyAqIGIueCArIGEueSAqIGIueiAtIGEueiAqIGIueTtcXG4gIHF1YXQueSA9IGEueSAqIGIudyArIGEudyAqIGIueSArIGEueiAqIGIueCAtIGEueCAqIGIuejtcXG4gIHF1YXQueiA9IGEueiAqIGIudyArIGEudyAqIGIueiArIGEueCAqIGIueSAtIGEueSAqIGIueDtcXG4gIHF1YXQudyA9IGEudyAqIGIudyAtIGEueCAqIGIueCAtIGEueSAqIGIueSAtIGEueiAqIGIuejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG52b2lkIHJvdGF0ZVZlY0Zyb21RdWF0IChpbm91dCB2ZWMzIHYsIHZlYzQgcSl7XFxuICBmbG9hdCBpeCA9IHEudyAqIHYueCArIHEueSAqIHYueiAtIHEueiAqIHYueTtcXG4gIGZsb2F0IGl5ID0gcS53ICogdi55ICsgcS56ICogdi54IC0gcS54ICogdi56O1xcbiAgZmxvYXQgaXogPSBxLncgKiB2LnogKyBxLnggKiB2LnkgLSBxLnkgKiB2Lng7XFxuICBmbG9hdCBpdyA9IC1xLnggKiB2LnggLSBxLnkgKiB2LnkgLSBxLnogKiB2Lno7XFxuICB2LnggPSBpeCAqIHEudyArIGl3ICogLXEueCArIGl5ICogLXEueiAtIGl6ICogLXEueTtcXG4gIHYueSA9IGl5ICogcS53ICsgaXcgKiAtcS55ICsgaXogKiAtcS54IC0gaXggKiAtcS56O1xcbiAgdi56ID0gaXogKiBxLncgKyBpdyAqIC1xLnogKyBpeCAqIC1xLnkgLSBpeSAqIC1xLng7XFxufVxcbnZlYzMgcm90YXRlSW5Mb2NhbFNwYWNlICh2ZWMzIHBvcywgdmVjMyB4QXhpcywgdmVjMyB5QXhpcywgdmVjMyB6QXhpcywgdmVjNCBxKXtcXG4gIHZlYzQgdmlld1F1YXQgPSBxdWF0ZXJuaW9uRnJvbUF4aXMoeEF4aXMsIHlBeGlzLCB6QXhpcyk7XFxuICB2ZWM0IHJvdFF1YXQgPSBxdWF0TXVsdGlwbHkodmlld1F1YXQsIHEpO1xcbiAgcm90YXRlVmVjRnJvbVF1YXQocG9zLCByb3RRdWF0KTtcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgcm90YXRlQ29ybmVyIChpbm91dCB2ZWMyIGNvcm5lciwgZmxvYXQgYW5nbGUpe1xcbiAgZmxvYXQgeE9TID0gY29zKGFuZ2xlKSAqIGNvcm5lci54IC0gc2luKGFuZ2xlKSAqIGNvcm5lci55O1xcbiAgZmxvYXQgeU9TID0gc2luKGFuZ2xlKSAqIGNvcm5lci54ICsgY29zKGFuZ2xlKSAqIGNvcm5lci55O1xcbiAgY29ybmVyLnggPSB4T1M7XFxuICBjb3JuZXIueSA9IHlPUztcXG59XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IG1lZGl1bXAgdmVjMiB1djtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBvdXQgbWVkaXVtcCB2ZWM0IGNvbG9yO1xcbnZvaWQgY29tcHV0ZVZlcnRQb3MgKGlub3V0IHZlYzQgcG9zLCB2ZWMyIHZlcnRPZmZzZXQsIHZlYzQgcSwgdmVjMyBzXFxuICAsIG1hdDQgdmlld0ludlxcbikge1xcbiAgdmVjMyB2aWV3U3BhY2VWZXJ0ID0gdmVjMyh2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSwgMC4pO1xcbiAgdmVjMyBjYW1YID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVswXSwgdmlld0ludlsxXVswXSwgdmlld0ludlsyXVswXSkpO1xcbiAgdmVjMyBjYW1ZID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsxXSwgdmlld0ludlsxXVsxXSwgdmlld0ludlsyXVsxXSkpO1xcbiAgdmVjMyBjYW1aID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsyXSwgdmlld0ludlsxXVsyXSwgdmlld0ludlsyXVsyXSkpO1xcbiAgcG9zLnh5eiArPSByb3RhdGVJbkxvY2FsU3BhY2Uodmlld1NwYWNlVmVydCwgY2FtWCwgY2FtWSwgY2FtWiwgcSk7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzMgYV9wb3NpdGlvbjtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMyIGFfdGV4Q29vcmQ7XFxubGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjNCBhX2NvbG9yO1xcbmxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMSkgdW5pZm9ybSBidWlsdGluIHtcXG4gIHZlYzQgY2Nfc2l6ZV9yb3RhdGlvbjtcXG59O1xcbnZlYzQgdnNfbWFpbigpIHtcXG4gIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAxKTtcXG4gIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgdmVjMiB2ZXJ0T2Zmc2V0ID0gYV90ZXhDb29yZC54eSAtIDAuNTtcXG4gIGNvbXB1dGVWZXJ0UG9zKHBvcywgdmVydE9mZnNldCwgcXVhdGVybmlvbkZyb21FdWxlcih2ZWMzKDAuLCAwLiwgY2Nfc2l6ZV9yb3RhdGlvbi56KSksIHZlYzMoY2Nfc2l6ZV9yb3RhdGlvbi54eSwgMC4pLCBjY19tYXRWaWV3SW52KTtcXG4gIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgdXYgPSBhX3RleENvb3JkLnh5O1xcbiAgY29sb3IgPSBhX2NvbG9yO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZzX21haW4oKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWMyIHV2O1xcbmxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzQgY29sb3I7XFxubGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSAzKSB1bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDIpIHVuaWZvcm0gRnJhZ0NvbnN0YW50cyB7XFxuICB2ZWM0IHRpbnRDb2xvcjtcXG59O1xcbnZlYzQgYWRkICgpIHtcXG4gIHZlYzQgY29sID0gMi4wICogY29sb3IgKiB0aW50Q29sb3IgKiB0ZXh0dXJlKG1haW5UZXh0dXJlLCB1dik7XFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNvbCk7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGFkZCgpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NMb2NhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZpbmVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0hEUlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJibG9ja3NcIjogW1xyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkNvbnN0YW50c1wiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAwLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGlsaW5nX09mZnNldFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcImZyYW1lVGlsZV92ZWxMZW5TY2FsZVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInNjYWxlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcImJ1aWx0aW5cIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwiY2Nfc2l6ZV9yb3RhdGlvblwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJGcmFnQ29uc3RhbnRzXCIsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDIsIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ0aW50Q29sb3JcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGV4dHVyZVwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMTYsIFwiYmluZGluZ1wiOiAzIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcG9zaXRpb25cIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZFwiLCBcInR5cGVcIjogMTQsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMjEsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2NvbG9yXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJsb2NhdGlvblwiOiAyIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tZ3JhcGhpY3NcIixcclxuICAgIFwiX3V1aWRcIjogXCIxYzAyYWU2Zi00NDkyLTQ5MTUtYjhmOC03NDkyYTNiMWU0Y2RcIixcclxuICAgIFwidGVjaG5pcXVlc1wiOiBbXHJcbiAgICAgIHsgXCJwYXNzZXNcIjogW3sgXCJibGVuZFN0YXRlXCI6IHsgXCJ0YXJnZXRzXCI6IFt7IFwiYmxlbmRcIjogdHJ1ZSwgXCJibGVuZFNyY1wiOiAxLCBcImJsZW5kRHN0XCI6IDQsIFwiYmxlbmRTcmNBbHBoYVwiOiAxLCBcImJsZW5kRHN0QWxwaGFcIjogNCB9XSB9LCBcInJhc3Rlcml6ZXJTdGF0ZVwiOiB7IFwiY3VsbE1vZGVcIjogMCB9LCBcInByb2dyYW1cIjogXCJidWlsdGluLWdyYXBoaWNzfHZzOnZlcnR8ZnM6ZnJhZ1wiLCBcImRlcHRoU3RlbmNpbFN0YXRlXCI6IHsgXCJkZXB0aFRlc3RcIjogZmFsc2UsIFwiZGVwdGhXcml0ZVwiOiBmYWxzZSB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1ncmFwaGljc3x2czp2ZXJ0fGZzOmZyYWdcIixcclxuICAgICAgICBcImhhc2hcIjogMzk0NjY2NzM1MSxcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NMb2NhbCB7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZElUO1xcbiAgaGlnaHAgdmVjNCBjY19saWdodGluZ01hcFVWUGFyYW07XFxufTtcXG5pbiB2ZWMzIGFfcG9zaXRpb247XFxuaW4gdmVjNCBhX2NvbG9yO1xcbm91dCB2ZWM0IHZfY29sb3I7XFxuaW4gZmxvYXQgYV9kaXN0O1xcbm91dCBmbG9hdCB2X2Rpc3Q7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAxKTtcXG4gIHBvcyA9IGNjX21hdFZpZXdQcm9qICogY2NfbWF0V29ybGQgKiBwb3M7XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gIHZfZGlzdCA9IGFfZGlzdDtcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaW4gdmVjNCB2X2NvbG9yO1xcbmluIGZsb2F0IHZfZGlzdDtcXG52ZWM0IGZyYWcgKCkge1xcbiAgdmVjNCBvID0gdl9jb2xvcjtcXG4gICAgZmxvYXQgYWEgPSBmd2lkdGgodl9kaXN0KTtcXG4gIGZsb2F0IGFscGhhID0gMS4gLSBzbW9vdGhzdGVwKC1hYSwgMC4sIGFicyh2X2Rpc3QpIC0gMS4wKTtcXG4gIG8ucmdiICo9IG8uYTtcXG4gIG8gKj0gYWxwaGE7XFxuICByZXR1cm4gbztcXG59XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsMVwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9kaXN0O1xcbnZhcnlpbmcgZmxvYXQgdl9kaXN0O1xcbnZlYzQgdmVydCAoKSB7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbiwgMSk7XFxuICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIGNjX21hdFdvcmxkICogcG9zO1xcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICB2X2Rpc3QgPSBhX2Rpc3Q7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxuI2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcbiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzOiBlbmFibGVcXG4jZW5kaWZcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X2Rpc3Q7XFxudmVjNCBmcmFnICgpIHtcXG4gIHZlYzQgbyA9IHZfY29sb3I7XFxuICAgICNpZmRlZiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXG4gICAgICBmbG9hdCBhYSA9IGZ3aWR0aCh2X2Rpc3QpO1xcbiAgICAjZWxzZVxcbiAgICAgIGZsb2F0IGFhID0gMC4wNTtcXG4gICAgI2VuZGlmXFxuICBmbG9hdCBhbHBoYSA9IDEuIC0gc21vb3Roc3RlcCgtYWEsIDAuLCBhYnModl9kaXN0KSAtIDEuMCk7XFxuICBvLnJnYiAqPSBvLmE7XFxuICBvICo9IGFscGhhO1xcbiAgcmV0dXJuIG87XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsNFwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzMgYV9wb3NpdGlvbjtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWM0IGFfY29sb3I7XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgdl9jb2xvcjtcXG5sYXlvdXQobG9jYXRpb24gPSAyKSBpbiBmbG9hdCBhX2Rpc3Q7XFxubGF5b3V0KGxvY2F0aW9uID0gMSkgb3V0IGZsb2F0IHZfZGlzdDtcXG52ZWM0IHZlcnQgKCkge1xcbiAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb24sIDEpO1xcbiAgcG9zID0gY2NfbWF0Vmlld1Byb2ogKiBjY19tYXRXb3JsZCAqIHBvcztcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgdl9kaXN0ID0gYV9kaXN0O1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWM0IHZfY29sb3I7XFxubGF5b3V0KGxvY2F0aW9uID0gMSkgaW4gZmxvYXQgdl9kaXN0O1xcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IG8gPSB2X2NvbG9yO1xcbiAgICBmbG9hdCBhYSA9IGZ3aWR0aCh2X2Rpc3QpO1xcbiAgZmxvYXQgYWxwaGEgPSAxLiAtIHNtb290aHN0ZXAoLWFhLCAwLiwgYWJzKHZfZGlzdCkgLSAxLjApO1xcbiAgby5yZ2IgKj0gby5hO1xcbiAgbyAqPSBhbHBoYTtcXG4gIHJldHVybiBvO1xcbn1cXG5sYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJ1aWx0aW5zXCI6IHtcclxuICAgICAgICAgIFwiZ2xvYmFsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDR2xvYmFsXCIsIFwiZGVmaW5lc1wiOiBbXSB9XSwgXCJzYW1wbGVyc1wiOiBbXSB9LFxyXG4gICAgICAgICAgXCJsb2NhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0xvY2FsXCIsIFwiZGVmaW5lc1wiOiBbXSB9XSwgXCJzYW1wbGVyc1wiOiBbXSB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRlZmluZXNcIjogW10sXHJcbiAgICAgICAgXCJibG9ja3NcIjogW10sXHJcbiAgICAgICAgXCJzYW1wbGVyc1wiOiBbXSxcclxuICAgICAgICBcImF0dHJpYnV0ZXNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3Bvc2l0aW9uXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfY29sb3JcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQ0LCBcImxvY2F0aW9uXCI6IDEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9kaXN0XCIsIFwidHlwZVwiOiAxMywgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAxMSwgXCJsb2NhdGlvblwiOiAyIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tcGFydGljbGUtZ3B1XCIsXHJcbiAgICBcIl91dWlkXCI6IFwiOTcxYmRiMjMtM2ZmNi00M2ViLWI0MjItMWMzMDE2NWEzNjYzXCIsXHJcbiAgICBcInRlY2huaXF1ZXNcIjogW1xyXG4gICAgICB7IFwibmFtZVwiOiBcImFkZFwiLCBcInBhc3Nlc1wiOiBbeyBcInJhc3Rlcml6ZXJTdGF0ZVwiOiB7IFwiY3VsbE1vZGVcIjogMCB9LCBcImJsZW5kU3RhdGVcIjogeyBcInRhcmdldHNcIjogW3sgXCJibGVuZFwiOiB0cnVlLCBcImJsZW5kU3JjXCI6IDIsIFwiYmxlbmREc3RcIjogMSwgXCJibGVuZFNyY0FscGhhXCI6IDIsIFwiYmxlbmREc3RBbHBoYVwiOiAxIH1dIH0sIFwicHJvZ3JhbVwiOiBcImJ1aWx0aW4tcGFydGljbGUtZ3B1fHBhcnRpY2xlLXZzLWdwdTpncHZzX21haW58dGludGVkLWZzOmFkZFwiLCBcImRlcHRoU3RlbmNpbFN0YXRlXCI6IHsgXCJkZXB0aFRlc3RcIjogdHJ1ZSwgXCJkZXB0aFdyaXRlXCI6IGZhbHNlIH0sIFwicHJvcGVydGllc1wiOiB7IFwibWFpblRleHR1cmVcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjggfSwgXCJtYWluVGlsaW5nX09mZnNldFwiOiB7IFwidmFsdWVcIjogWzEsIDEsIDAsIDBdLCBcInR5cGVcIjogMTYgfSwgXCJ0aW50Q29sb3JcIjogeyBcInZhbHVlXCI6IFswLjUsIDAuNSwgMC41LCAwLjVdLCBcInR5cGVcIjogMTYgfSB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1wYXJ0aWNsZS1ncHV8cGFydGljbGUtdnMtZ3B1OmdwdnNfbWFpbnx0aW50ZWQtZnM6YWRkXCIsXHJcbiAgICAgICAgXCJoYXNoXCI6IDM2OTY4MzYzMDUsXHJcbiAgICAgICAgXCJnbHNsM1wiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnZlYzQgcXVhdGVybmlvbkZyb21BeGlzICh2ZWMzIHhBeGlzLHZlYzMgeUF4aXMsdmVjMyB6QXhpcyl7XFxuICBtYXQzIG0gPSBtYXQzKHhBeGlzLHlBeGlzLHpBeGlzKTtcXG4gIGZsb2F0IHRyYWNlID0gbVswXVswXSArIG1bMV1bMV0gKyBtWzJdWzJdO1xcbiAgdmVjNCBxdWF0O1xcbiAgaWYgKHRyYWNlID4gMC4pIHtcXG4gICAgZmxvYXQgcyA9IDAuNSAvIHNxcnQodHJhY2UgKyAxLjApO1xcbiAgICBxdWF0LncgPSAwLjI1IC8gcztcXG4gICAgcXVhdC54ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAqIHM7XFxuICAgIHF1YXQueSA9IChtWzBdWzJdIC0gbVsyXVswXSkgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVswXSAtIG1bMF1bMV0pICogcztcXG4gIH0gZWxzZSBpZiAoKG1bMF1bMF0gPiBtWzFdWzFdKSAmJiAobVswXVswXSA+IG1bMl1bMl0pKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMF1bMF0gLSBtWzFdWzFdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzJdWzFdIC0gbVsxXVsyXSkgLyBzO1xcbiAgICBxdWF0LnggPSAwLjI1ICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueiA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgfSBlbHNlIGlmIChtWzFdWzFdID4gbVsyXVsyXSkge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzFdWzFdIC0gbVswXVswXSAtIG1bMl1bMl0pO1xcbiAgICBxdWF0LncgPSAobVswXVsyXSAtIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC54ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueSA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gIH0gZWxzZSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMl1bMl0gLSBtWzBdWzBdIC0gbVsxXVsxXSk7XFxuICAgIHF1YXQudyA9IChtWzFdWzBdIC0gbVswXVsxXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsyXSArIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gKG1bMV1bMl0gKyBtWzJdWzFdKSAvIHM7XFxuICAgIHF1YXQueiA9IDAuMjUgKiBzO1xcbiAgfVxcbiAgZmxvYXQgbGVuID0gcXVhdC54ICogcXVhdC54ICsgcXVhdC55ICogcXVhdC55ICsgcXVhdC56ICogcXVhdC56ICsgcXVhdC53ICogcXVhdC53O1xcbiAgaWYgKGxlbiA+IDAuKSB7XFxuICAgIGxlbiA9IDEuIC8gc3FydChsZW4pO1xcbiAgICBxdWF0LnggPSBxdWF0LnggKiBsZW47XFxuICAgIHF1YXQueSA9IHF1YXQueSAqIGxlbjtcXG4gICAgcXVhdC56ID0gcXVhdC56ICogbGVuO1xcbiAgICBxdWF0LncgPSBxdWF0LncgKiBsZW47XFxuICB9XFxuICByZXR1cm4gcXVhdDtcXG59XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUV1bGVyICh2ZWMzIGFuZ2xlKXtcXG4gIGZsb2F0IHggPSBhbmdsZS54IC8gMi47XFxuICBmbG9hdCB5ID0gYW5nbGUueSAvIDIuO1xcbiAgZmxvYXQgeiA9IGFuZ2xlLnogLyAyLjtcXG4gIGZsb2F0IHN4ID0gc2luKHgpO1xcbiAgZmxvYXQgY3ggPSBjb3MoeCk7XFxuICBmbG9hdCBzeSA9IHNpbih5KTtcXG4gIGZsb2F0IGN5ID0gY29zKHkpO1xcbiAgZmxvYXQgc3ogPSBzaW4oeik7XFxuICBmbG9hdCBjeiA9IGNvcyh6KTtcXG4gIHZlYzQgcXVhdCA9IHZlYzQoMCk7XFxuICBxdWF0LnggPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XFxuICBxdWF0LnkgPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XFxuICBxdWF0LnogPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XFxuICBxdWF0LncgPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XFxuICByZXR1cm4gcXVhdDtcXG59XFxubWF0NCBtYXRyaXhGcm9tUlQgKHZlYzQgcSwgdmVjMyBwKXtcXG4gIGZsb2F0IHgyID0gcS54ICsgcS54O1xcbiAgZmxvYXQgeTIgPSBxLnkgKyBxLnk7XFxuICBmbG9hdCB6MiA9IHEueiArIHEuejtcXG4gIGZsb2F0IHh4ID0gcS54ICogeDI7XFxuICBmbG9hdCB4eSA9IHEueCAqIHkyO1xcbiAgZmxvYXQgeHogPSBxLnggKiB6MjtcXG4gIGZsb2F0IHl5ID0gcS55ICogeTI7XFxuICBmbG9hdCB5eiA9IHEueSAqIHoyO1xcbiAgZmxvYXQgenogPSBxLnogKiB6MjtcXG4gIGZsb2F0IHd4ID0gcS53ICogeDI7XFxuICBmbG9hdCB3eSA9IHEudyAqIHkyO1xcbiAgZmxvYXQgd3ogPSBxLncgKiB6MjtcXG4gIHJldHVybiBtYXQ0KFxcbiAgICAxLiAtICh5eSArIHp6KSwgeHkgKyB3eiwgeHogLSB3eSwgMCxcXG4gICAgeHkgLSB3eiwgMS4gLSAoeHggKyB6eiksIHl6ICsgd3gsIDAsXFxuICAgIHh6ICsgd3ksIHl6IC0gd3gsIDEuIC0gKHh4ICsgeXkpLCAwLFxcbiAgICBwLngsIHAueSwgcC56LCAxXFxuICApO1xcbn1cXG5tYXQ0IG1hdEZyb21SVFMgKHZlYzQgcSwgdmVjMyB0LCB2ZWMzIHMpe1xcbiAgZmxvYXQgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcXG4gIGZsb2F0IHgyID0geCArIHg7XFxuICBmbG9hdCB5MiA9IHkgKyB5O1xcbiAgZmxvYXQgejIgPSB6ICsgejtcXG4gIGZsb2F0IHh4ID0geCAqIHgyO1xcbiAgZmxvYXQgeHkgPSB4ICogeTI7XFxuICBmbG9hdCB4eiA9IHggKiB6MjtcXG4gIGZsb2F0IHl5ID0geSAqIHkyO1xcbiAgZmxvYXQgeXogPSB5ICogejI7XFxuICBmbG9hdCB6eiA9IHogKiB6MjtcXG4gIGZsb2F0IHd4ID0gdyAqIHgyO1xcbiAgZmxvYXQgd3kgPSB3ICogeTI7XFxuICBmbG9hdCB3eiA9IHcgKiB6MjtcXG4gIGZsb2F0IHN4ID0gcy54O1xcbiAgZmxvYXQgc3kgPSBzLnk7XFxuICBmbG9hdCBzeiA9IHMuejtcXG4gIHJldHVybiBtYXQ0KCgxLiAtICh5eSArIHp6KSkgKiBzeCwgKHh5ICsgd3opICogc3gsICh4eiAtIHd5KSAqIHN4LCAwLFxcbiAgICAoeHkgLSB3eikgKiBzeSwgKDEuIC0gKHh4ICsgenopKSAqIHN5LCAoeXogKyB3eCkgKiBzeSwgMCxcXG4gICAgKHh6ICsgd3kpICogc3osICh5eiAtIHd4KSAqIHN6LCAoMS4gLSAoeHggKyB5eSkpICogc3osIDAsXFxuICAgIHQueCwgdC55LCB0LnosIDEpO1xcbn1cXG52ZWM0IHF1YXRNdWx0aXBseSAodmVjNCBhLCB2ZWM0IGIpe1xcbiAgdmVjNCBxdWF0O1xcbiAgcXVhdC54ID0gYS54ICogYi53ICsgYS53ICogYi54ICsgYS55ICogYi56IC0gYS56ICogYi55O1xcbiAgcXVhdC55ID0gYS55ICogYi53ICsgYS53ICogYi55ICsgYS56ICogYi54IC0gYS54ICogYi56O1xcbiAgcXVhdC56ID0gYS56ICogYi53ICsgYS53ICogYi56ICsgYS54ICogYi55IC0gYS55ICogYi54O1xcbiAgcXVhdC53ID0gYS53ICogYi53IC0gYS54ICogYi54IC0gYS55ICogYi55IC0gYS56ICogYi56O1xcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbnZvaWQgcm90YXRlVmVjRnJvbVF1YXQgKGlub3V0IHZlYzMgdiwgdmVjNCBxKXtcXG4gIGZsb2F0IGl4ID0gcS53ICogdi54ICsgcS55ICogdi56IC0gcS56ICogdi55O1xcbiAgZmxvYXQgaXkgPSBxLncgKiB2LnkgKyBxLnogKiB2LnggLSBxLnggKiB2Lno7XFxuICBmbG9hdCBpeiA9IHEudyAqIHYueiArIHEueCAqIHYueSAtIHEueSAqIHYueDtcXG4gIGZsb2F0IGl3ID0gLXEueCAqIHYueCAtIHEueSAqIHYueSAtIHEueiAqIHYuejtcXG4gIHYueCA9IGl4ICogcS53ICsgaXcgKiAtcS54ICsgaXkgKiAtcS56IC0gaXogKiAtcS55O1xcbiAgdi55ID0gaXkgKiBxLncgKyBpdyAqIC1xLnkgKyBpeiAqIC1xLnggLSBpeCAqIC1xLno7XFxuICB2LnogPSBpeiAqIHEudyArIGl3ICogLXEueiArIGl4ICogLXEueSAtIGl5ICogLXEueDtcXG59XFxudmVjMyByb3RhdGVJbkxvY2FsU3BhY2UgKHZlYzMgcG9zLCB2ZWMzIHhBeGlzLCB2ZWMzIHlBeGlzLCB2ZWMzIHpBeGlzLCB2ZWM0IHEpe1xcbiAgdmVjNCB2aWV3UXVhdCA9IHF1YXRlcm5pb25Gcm9tQXhpcyh4QXhpcywgeUF4aXMsIHpBeGlzKTtcXG4gIHZlYzQgcm90UXVhdCA9IHF1YXRNdWx0aXBseSh2aWV3UXVhdCwgcSk7XFxuICByb3RhdGVWZWNGcm9tUXVhdChwb3MsIHJvdFF1YXQpO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCByb3RhdGVDb3JuZXIgKGlub3V0IHZlYzIgY29ybmVyLCBmbG9hdCBhbmdsZSl7XFxuICBmbG9hdCB4T1MgPSBjb3MoYW5nbGUpICogY29ybmVyLnggLSBzaW4oYW5nbGUpICogY29ybmVyLnk7XFxuICBmbG9hdCB5T1MgPSBzaW4oYW5nbGUpICogY29ybmVyLnggKyBjb3MoYW5nbGUpICogY29ybmVyLnk7XFxuICBjb3JuZXIueCA9IHhPUztcXG4gIGNvcm5lci55ID0geU9TO1xcbn1cXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENvbnN0YW50cyB7XFxuICB2ZWM0IG1haW5UaWxpbmdfT2Zmc2V0O1xcbiAgdmVjNCBmcmFtZVRpbGVfdmVsTGVuU2NhbGU7XFxuICB2ZWM0IHNjYWxlO1xcbn07XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbm91dCBtZWRpdW1wIHZlYzIgdXY7XFxub3V0IG1lZGl1bXAgdmVjNCBjb2xvcjtcXG52b2lkIGNvbXB1dGVWZXJ0UG9zIChpbm91dCB2ZWM0IHBvcywgdmVjMiB2ZXJ0T2Zmc2V0LCB2ZWM0IHEsIHZlYzMgc1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICwgbWF0NCB2aWV3SW52XFxuI2VuZGlmXFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICwgdmVjMyBleWVcXG4gICwgdmVjNCB2ZWxvY2l0eVxcbiAgLCBmbG9hdCB2ZWxvY2l0eVNjYWxlXFxuICAsIGZsb2F0IGxlbmd0aFNjYWxlXFxuICAsIGZsb2F0IHhJbmRleFxcbiNlbmRpZlxcbikge1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzBdLCB2aWV3SW52WzFdWzBdLCB2aWV3SW52WzJdWzBdKSk7XFxuICB2ZWMzIGNhbVkgPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzFdLCB2aWV3SW52WzFdWzFdLCB2aWV3SW52WzJdWzFdKSk7XFxuICB2ZWMzIGNhbVogPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzJdLCB2aWV3SW52WzFdWzJdLCB2aWV3SW52WzJdWzJdKSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjYW1aLCBxKTtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICB2ZWMzIGNhbVJpZ2h0ID0gbm9ybWFsaXplKGNyb3NzKHBvcy54eXogLSBleWUsIHZlbG9jaXR5Lnh5eikpICogcy54O1xcbiAgdmVjMyBjYW1VcCA9IHZlbG9jaXR5Lnh5eiAqIHZlbG9jaXR5U2NhbGUgKyBub3JtYWxpemUodmVsb2NpdHkueHl6KSAqIGxlbmd0aFNjYWxlICogcy55O1xcbiAgcG9zLnh5eiArPSAoY2FtUmlnaHQgKiBhYnModmVydE9mZnNldC54KSAqIHNpZ24odmVydE9mZnNldC55KSkgLSBjYW1VcCAqIHhJbmRleDtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAyXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSB2ZWMzKDEsIDAsIDApO1xcbiAgdmVjMyBjYW1ZID0gdmVjMygwLCAwLCAtMSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjcm9zcyhjYW1YLCBjYW1ZKSwgcSk7XFxuI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgdmVjMiB2aWV3U3BhY2VWZXJ0ID0gdmVjMih2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSk7XFxuICByb3RhdGVDb3JuZXIodmlld1NwYWNlVmVydCwgcS56KTtcXG4gIHZlYzMgY2FtWCA9IG5vcm1hbGl6ZSh2ZWMzKGNjX21hdFZpZXdbMF1bMF0sIGNjX21hdFZpZXdbMV1bMF0sIGNjX21hdFZpZXdbMl1bMF0pKTtcXG4gIHZlYzMgY2FtWSA9IHZlYzMoMCwgMSwgMCk7XFxuICB2ZWMzIG9mZnNldCA9IGNhbVggKiB2aWV3U3BhY2VWZXJ0LnggKyBjYW1ZICogdmlld1NwYWNlVmVydC55O1xcbiAgcG9zLnh5eiArPSBvZmZzZXQ7XFxuI2Vsc2VcXG4gIHBvcy54ICs9IHZlcnRPZmZzZXQueDtcXG4gIHBvcy55ICs9IHZlcnRPZmZzZXQueTtcXG4jZW5kaWZcXG59XFxudmVjMiBjb21wdXRlVVYgKGZsb2F0IGZyYW1lSW5kZXgsIHZlYzIgdmVydEluZGV4LCB2ZWMyIGZyYW1lVGlsZSl7XFxuICB2ZWMyIGFuaVVWID0gdmVjMigwLCBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnkpKTtcXG4gIGFuaVVWLnggPSBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnggKiBmcmFtZVRpbGUueSAtIGFuaVVWLnkgKiBmcmFtZVRpbGUueCk7XFxuI2lmIENDX1JFTkRFUl9NT0RFICE9IDRcXG4gIHZlcnRJbmRleC55ID0gMS4gLSB2ZXJ0SW5kZXgueTtcXG4jZW5kaWZcXG4gIHJldHVybiAoYW5pVVYueHkgKyB2ZXJ0SW5kZXgpIC8gdmVjMihmcmFtZVRpbGUueCwgZnJhbWVUaWxlLnkpO1xcbn1cXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIFNhbXBsZUNvbnN0YW50cyB7XFxuICB2ZWM0IHVfc2FtcGxlSW5mbztcXG59O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gVGlja0NvbnN0YW50cyB7XFxuICB2ZWM0IHVfd29ybGRSb3Q7XFxuICB2ZWM0IHVfdGltZURlbHRhO1xcbn07XFxuaW4gdmVjNCBhX3Bvc2l0aW9uX3N0YXJ0dGltZTtcXG5pbiB2ZWM0IGFfc2l6ZV91djtcXG5pbiB2ZWM0IGFfcm90YXRpb25fdXY7XFxuaW4gdmVjNCBhX2NvbG9yO1xcbmluIHZlYzQgYV9kaXJfbGlmZTtcXG5pbiBmbG9hdCBhX3JuZFNlZWQ7XFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDRcXG4gIGluIHZlYzMgYV90ZXhDb29yZDtcXG4gIGluIHZlYzMgYV90ZXhDb29yZDM7XFxuICBpbiB2ZWMzIGFfbm9ybWFsO1xcbiAgaW4gdmVjNCBhX2NvbG9yMTtcXG4jZW5kaWZcXG52ZWMzIHVucGFja0N1cnZlRGF0YSAoc2FtcGxlcjJEIHRleCwgdmVjMiBjb29yZCkge1xcbiAgICB2ZWM0IGEgPSB0ZXh0dXJlKHRleCwgY29vcmQpO1xcbiAgICB2ZWM0IGIgPSB0ZXh0dXJlKHRleCwgY29vcmQgKyB1X3NhbXBsZUluZm8ueSk7XFxuICAgIGZsb2F0IGMgPSBmcmFjdChjb29yZC54ICogdV9zYW1wbGVJbmZvLngpO1xcbiAgICByZXR1cm4gbWl4KGEueHl6LCBiLnh5eiwgYyk7XFxufVxcbnZlYzMgdW5wYWNrQ3VydmVEYXRhIChzYW1wbGVyMkQgdGV4LCB2ZWMyIGNvb3JkLCBvdXQgZmxvYXQgdykge1xcbiAgICB2ZWM0IGEgPSB0ZXh0dXJlKHRleCwgY29vcmQpO1xcbiAgICB2ZWM0IGIgPSB0ZXh0dXJlKHRleCwgY29vcmQgKyB1X3NhbXBsZUluZm8ueSk7XFxuICAgIGZsb2F0IGMgPSBmcmFjdChjb29yZC54ICogdV9zYW1wbGVJbmZvLngpO1xcbiAgICB3ID0gbWl4KGEudywgYi53LCBjKTtcXG4gICAgcmV0dXJuIG1peChhLnh5eiwgYi54eXosIGMpO1xcbn1cXG5mbG9hdCBwc2V1ZG9SYW5kb20gKGZsb2F0IHNlZWQpIHtcXG4gIHNlZWQgPSBtb2Qoc2VlZCwgMjMzMjgwLik7XFxuICBmbG9hdCBxID0gKHNlZWQgKiA5MzAxLiArIDQ5Mjk3LikgLyAyMzMyODAuO1xcbiAgcmV0dXJuIGZyYWN0KHEpO1xcbn1cXG4jaWYgQ09MT1JfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yX292ZXJfdGltZV90ZXgwO1xcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDb2xvckNvbnN0YW50IHtcXG4gICAgaW50IHVfY29sb3JfbW9kZTtcXG4gIH07XFxuI2VuZGlmXFxuI2lmIFJPVEFUSU9OX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICB1bmlmb3JtIHNhbXBsZXIyRCByb3RhdGlvbl9vdmVyX3RpbWVfdGV4MDtcXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gUm90YXRpb25Db25zdGFudCB7XFxuICAgIGludCB1X3JvdGF0aW9uX21vZGU7XFxuICB9O1xcbiNlbmRpZlxcbiNpZiBTSVpFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBzaXplX292ZXJfdGltZV90ZXgwO1xcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBTaXplQ29uc3RhbnQge1xcbiAgICBpbnQgdV9zaXplX21vZGU7XFxuICB9O1xcbiNlbmRpZlxcbiNpZiBGT1JDRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZm9yY2Vfb3Zlcl90aW1lX3RleDA7XFxuICBsYXlvdXQoc3RkMTQwKSB1bmlmb3JtIEZvcmNlQ29uc3RhbnQge1xcbiAgICBpbnQgdV9mb3JjZV9tb2RlO1xcbiAgICBpbnQgdV9mb3JjZV9zcGFjZTtcXG4gIH07XFxuI2VuZGlmXFxuI2lmIFZFTE9DSVRZX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICB1bmlmb3JtIHNhbXBsZXIyRCB2ZWxvY2l0eV9vdmVyX3RpbWVfdGV4MDtcXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gVmVsb2NpdHlDb25zdGFudCB7XFxuICAgIGludCB1X3ZlbG9jaXR5X21vZGU7XFxuICAgIGludCB1X3ZlbG9jaXR5X3NwYWNlO1xcbiAgfTtcXG4jZW5kaWZcXG4jaWYgVEVYVFVSRV9BTklNQVRJT05fTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZV9hbmltYXRpb25fdGV4MDtcXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gQW5pbWF0aW9uQ29uc3RhbnQge1xcbiAgICB2ZWM0IHVfYW5pbV9pbmZvO1xcbiAgfTtcXG4jZW5kaWZcXG5mbG9hdCByZXBlYXQgKGZsb2F0IHQsIGZsb2F0IGxlbmd0aCkge1xcbiAgcmV0dXJuIHQgLSBmbG9vcih0IC8gbGVuZ3RoKSAqIGxlbmd0aDtcXG59XFxudmVjNCByb3RhdGVRdWF0ICh2ZWM0IHAsIHZlYzQgcSkge1xcbiAgdmVjMyBpdiA9IGNyb3NzKHEueHl6LCBwLnh5eikgKyBxLncgKiBwLnh5ejtcXG4gIHZlYzMgcmVzID0gcC54eXogKyAyLjAgKiBjcm9zcyhxLnh5eiwgaXYpO1xcbiAgcmV0dXJuIHZlYzQocmVzLnh5eiwgcC53KTtcXG59XFxudmVjNCBncHZzX21haW4gKCkge1xcbiAgZmxvYXQgYWN0aXZlVGltZSA9IHVfdGltZURlbHRhLnggLSBhX3Bvc2l0aW9uX3N0YXJ0dGltZS53O1xcbiAgZmxvYXQgbm9ybWFsaXplZFRpbWUgPSBjbGFtcChhY3RpdmVUaW1lIC8gYV9kaXJfbGlmZS53LCAwLjAsIDEuMCk7XFxuICB2ZWMyIHRpbWVDb29yZDAgPSB2ZWMyKG5vcm1hbGl6ZWRUaW1lLCAwLik7XFxuICB2ZWMyIHRpbWVDb29yZDEgPSB2ZWMyKG5vcm1hbGl6ZWRUaW1lLCAxLik7XFxuICAjaWYgQ0NfUkVOREVSX01PREUgPT0gNFxcbiAgICB2ZWMyIHZlcnRJZHggPSB2ZWMyKGFfdGV4Q29vcmQueCwgYV90ZXhDb29yZC55KTtcXG4gICNlbHNlXFxuICAgIHZlYzIgdmVydElkeCA9IHZlYzIoYV9zaXplX3V2LncsIGFfcm90YXRpb25fdXYudyk7XFxuICAjZW5kaWZcXG4gIHZlYzQgdmVsb2NpdHkgPSB2ZWM0KGFfZGlyX2xpZmUueHl6LCAwLik7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbl9zdGFydHRpbWUueHl6LCAxLik7XFxuICB2ZWMzIHNpemUgPSBhX3NpemVfdXYueHl6O1xcbiAgI2lmIFNJWkVfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgaWYgKHVfc2l6ZV9tb2RlID09IDEpIHtcXG4gICAgICBzaXplICo9IHVucGFja0N1cnZlRGF0YShzaXplX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2ZWMzIHNpemVfMCA9IHVucGFja0N1cnZlRGF0YShzaXplX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgICB2ZWMzIHNpemVfMSA9IHVucGFja0N1cnZlRGF0YShzaXplX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfcyA9IHBzZXVkb1JhbmRvbShhX3JuZFNlZWQgKyAzOTgyNS4pO1xcbiAgICAgIHNpemUgKj0gbWl4KHNpemVfMCwgc2l6ZV8xLCBmYWN0b3Jfcyk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiAgdmVjMyBjb21wU2NhbGUgPSBzY2FsZS54eXogKiBzaXplO1xcbiAgI2lmIEZPUkNFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICAgIHZlYzMgZm9yY2VBbmltID0gdmVjMygwLik7XFxuICAgIGlmICh1X2ZvcmNlX21vZGUgPT0gMSkge1xcbiAgICAgIGZvcmNlQW5pbSA9IHVucGFja0N1cnZlRGF0YShmb3JjZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyBmb3JjZV8wID0gdW5wYWNrQ3VydmVEYXRhKGZvcmNlX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgICB2ZWMzIGZvcmNlXzEgPSB1bnBhY2tDdXJ2ZURhdGEoZm9yY2Vfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl9mID0gIHBzZXVkb1JhbmRvbShhX3JuZFNlZWQgKyAyMTIxNjUuKTtcXG4gICAgICBmb3JjZUFuaW0gPSBtaXgoZm9yY2VfMCwgZm9yY2VfMSwgZmFjdG9yX2YpO1xcbiAgICB9XFxuICAgIHZlYzQgZm9yY2VUcmFjayA9IHZlYzQoZm9yY2VBbmltLCAwLik7XFxuICAgIGlmICh1X2ZvcmNlX3NwYWNlID09IDApIHtcXG4gICAgICBmb3JjZVRyYWNrID0gcm90YXRlUXVhdChmb3JjZVRyYWNrLCB1X3dvcmxkUm90KTtcXG4gICAgfVxcbiAgICB2ZWxvY2l0eS54eXogKz0gZm9yY2VUcmFjay54eXo7XFxuICAjZW5kaWZcXG4gICNpZiBWRUxPQ0lUWV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgICBmbG9hdCBzcGVlZE1vZGlmaWVyMCA9IDEuO1xcbiAgICBmbG9hdCBzcGVlZE1vZGlmaWVyMSA9IDEuO1xcbiAgICB2ZWMzIHZlbG9jaXR5QW5pbSA9IHZlYzMoMC4pO1xcbiAgICBpZiAodV92ZWxvY2l0eV9tb2RlID09IDEpIHtcXG4gICAgICB2ZWxvY2l0eUFuaW0gPSB1bnBhY2tDdXJ2ZURhdGEodmVsb2NpdHlfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDAsIHNwZWVkTW9kaWZpZXIwKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2ZWMzIHZlY3RvcnlfMCA9IHVucGFja0N1cnZlRGF0YSh2ZWxvY2l0eV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCwgc3BlZWRNb2RpZmllcjApO1xcbiAgICAgIHZlYzMgdmVjdG9yeV8xID0gdW5wYWNrQ3VydmVEYXRhKHZlbG9jaXR5X292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxLCBzcGVlZE1vZGlmaWVyMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX3YgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgMTk3ODY2Lik7XFxuICAgICAgdmVsb2NpdHlBbmltID0gbWl4KHZlY3RvcnlfMCwgdmVjdG9yeV8xLCBmYWN0b3Jfdik7XFxuICAgICAgc3BlZWRNb2RpZmllcjAgPSBtaXgoc3BlZWRNb2RpZmllcjAsIHNwZWVkTW9kaWZpZXIxLCBmYWN0b3Jfdik7XFxuICAgIH1cXG4gICAgdmVjNCB2ZWxvY2l0eVRyYWNrID0gdmVjNCh2ZWxvY2l0eUFuaW0sIDAuKTtcXG4gICAgaWYgKHVfdmVsb2NpdHlfc3BhY2UgPT0gMCkge1xcbiAgICAgIHZlbG9jaXR5VHJhY2sgPSByb3RhdGVRdWF0KHZlbG9jaXR5VHJhY2ssIHVfd29ybGRSb3QpO1xcbiAgICB9XFxuICAgIHZlbG9jaXR5Lnh5eiArPSB2ZWxvY2l0eVRyYWNrLnh5ejtcXG4gICAgdmVsb2NpdHkueHl6ICo9IHNwZWVkTW9kaWZpZXIwO1xcbiAgI2VuZGlmXFxuICBwb3MueHl6ICs9IHZlbG9jaXR5Lnh5eiAqIG5vcm1hbGl6ZWRUaW1lICogYV9kaXJfbGlmZS53O1xcbiAgI2lmICFDQ19VU0VfV09STERfU1BBQ0VcXG4gICAgcG9zID0gY2NfbWF0V29ybGQgKiBwb3M7XFxuICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgdmVsb2NpdHkgPSByb3RhdGVRdWF0KHZlbG9jaXR5LCB1X3dvcmxkUm90KTtcXG4gICAgI2VuZGlmXFxuICAjZW5kaWZcXG4gIHZlYzMgcm90YXRpb24gPSBhX3JvdGF0aW9uX3V2Lnh5ejtcXG4gICNpZiBST1RBVElPTl9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgICBpZiAodV9yb3RhdGlvbl9tb2RlID09IDEpIHtcXG4gICAgICByb3RhdGlvbiArPSB1bnBhY2tDdXJ2ZURhdGEocm90YXRpb25fb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDApICogbm9ybWFsaXplZFRpbWUgKiBhX2Rpcl9saWZlLnc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyByb3RhdGlvbl8wID0gdW5wYWNrQ3VydmVEYXRhKHJvdGF0aW9uX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgICB2ZWMzIHJvdGF0aW9uXzEgPSB1bnBhY2tDdXJ2ZURhdGEocm90YXRpb25fb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl9yID0gcHNldWRvUmFuZG9tKGFfcm5kU2VlZCArIDEyNTI5Mi4pO1xcbiAgICAgIHJvdGF0aW9uICs9IG1peChyb3RhdGlvbl8wLCByb3RhdGlvbl8xLCBmYWN0b3JfcikgKiBub3JtYWxpemVkVGltZSAqIGFfZGlyX2xpZmUudztcXG4gICAgfVxcbiAgI2VuZGlmXFxuICAjaWYgQ09MT1JfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgaWYgKHVfY29sb3JfbW9kZSA9PSAxKSB7XFxuICAgICAgY29sb3IgPSBhX2NvbG9yICogdGV4dHVyZShjb2xvcl9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjNCBjb2xvcl8wID0gdGV4dHVyZShjb2xvcl9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjNCBjb2xvcl8xID0gdGV4dHVyZShjb2xvcl9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX2MgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgOTEwNDEuKTtcXG4gICAgICBjb2xvciA9IGFfY29sb3IgKiBtaXgoY29sb3JfMCwgY29sb3JfMSwgZmFjdG9yX2MpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICBjb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG4gICNpZiBDQ19SRU5ERVJfTU9ERSAhPSA0XFxuICAgIHZlYzIgY29ybmVyT2Zmc2V0ID0gdmVjMigodmVydElkeCAtIDAuNSkpO1xcbiAgICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMFxcbiAgICAgIHZlYzMgcm90RXVsZXIgPSByb3RhdGlvbi54eXo7XFxuICAgICNlbGlmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gdmVjMygwLik7XFxuICAgICNlbHNlXFxuICAgICAgdmVjMyByb3RFdWxlciA9IHZlYzMoMC4sIDAuLCByb3RhdGlvbi56KTtcXG4gICAgI2VuZGlmXFxuICAgIGNvbXB1dGVWZXJ0UG9zKHBvcywgY29ybmVyT2Zmc2V0LCBxdWF0ZXJuaW9uRnJvbUV1bGVyKHJvdEV1bGVyKSwgY29tcFNjYWxlXFxuICAgICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDAgfHwgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgICAgICAgLCBjY19tYXRWaWV3SW52XFxuICAgICAgI2VuZGlmXFxuICAgICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgICAgICwgY2NfY2FtZXJhUG9zLnh5elxcbiAgICAgICAgLCB2ZWxvY2l0eVxcbiAgICAgICAgLCBmcmFtZVRpbGVfdmVsTGVuU2NhbGUuelxcbiAgICAgICAgLCBmcmFtZVRpbGVfdmVsTGVuU2NhbGUud1xcbiAgICAgICAgLCBhX3NpemVfdXYud1xcbiAgICAgICNlbmRpZlxcbiAgICApO1xcbiAgI2Vsc2VcXG4gICAgbWF0NCB4Zm9ybU5vU2NhbGUgPSBtYXRyaXhGcm9tUlQocXVhdGVybmlvbkZyb21FdWxlcihyb3RhdGlvbiksIHBvcy54eXopO1xcbiAgICBtYXQ0IHhmb3JtID0gbWF0RnJvbVJUUyhxdWF0ZXJuaW9uRnJvbUV1bGVyKHJvdGF0aW9uKSwgcG9zLnh5eiwgY29tcFNjYWxlKTtcXG4gICAgcG9zID0geGZvcm0gKiB2ZWM0KGFfdGV4Q29vcmQzLCAxKTtcXG4gICAgdmVjNCBub3JtYWwgPSB4Zm9ybU5vU2NhbGUgKiB2ZWM0KGFfbm9ybWFsLCAwKTtcXG4gICAgY29sb3IgKj0gYV9jb2xvcjE7XFxuICAjZW5kaWZcXG4gIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgZmxvYXQgZnJhbWVJbmRleCA9IDAuO1xcbiAgI2lmIFRFWFRVUkVfQU5JTUFUSU9OX01PRFVMRV9FTkFCTEVcXG4gICAgZmxvYXQgc3RhcnRGcmFtZSA9IDAuO1xcbiAgICB2ZWMzIGZyYW1lSW5mbyA9IHZlYzMoMC4pO1xcbiAgICBpZiAoaW50KHVfYW5pbV9pbmZvLngpID09IDEpIHtcXG4gICAgICBmcmFtZUluZm8gPSB1bnBhY2tDdXJ2ZURhdGEodGV4dHVyZV9hbmltYXRpb25fdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyBmcmFtZUluZm8wID0gdW5wYWNrQ3VydmVEYXRhKHRleHR1cmVfYW5pbWF0aW9uX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICAgIHZlYzMgZnJhbWVJbmZvMSA9IHVucGFja0N1cnZlRGF0YSh0ZXh0dXJlX2FuaW1hdGlvbl90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfdCA9IHBzZXVkb1JhbmRvbShhX3JuZFNlZWQgKyA5MDc5NC4pO1xcbiAgICAgIGZyYW1lSW5mbyA9IG1peChmcmFtZUluZm8wLCBmcmFtZUluZm8xLCBmYWN0b3JfdCk7XFxuICAgIH1cXG4gICAgc3RhcnRGcmFtZSA9IGZyYW1lSW5mby54IC8gdV9hbmltX2luZm8ueTtcXG4gICAgZnJhbWVJbmRleCA9IHJlcGVhdCh1X2FuaW1faW5mby56ICogKGZyYW1lSW5mby55ICsgc3RhcnRGcmFtZSksIDEuKTtcXG4gICNlbmRpZlxcbiAgdXYgPSBjb21wdXRlVVYoZnJhbWVJbmRleCwgdmVydElkeCwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLnh5KSAqIG1haW5UaWxpbmdfT2Zmc2V0Lnh5ICsgbWFpblRpbGluZ19PZmZzZXQuenc7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gZ3B2c19tYWluKCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbmluIHZlYzIgdXY7XFxuaW4gdmVjNCBjb2xvcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIEZyYWdDb25zdGFudHMge1xcbiAgdmVjNCB0aW50Q29sb3I7XFxufTtcXG52ZWM0IGFkZCAoKSB7XFxuICB2ZWM0IGNvbCA9IDIuMCAqIGNvbG9yICogdGludENvbG9yICogdGV4dHVyZShtYWluVGV4dHVyZSwgdXYpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2wpO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBhZGQoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xzbDFcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52ZWM0IHF1YXRlcm5pb25Gcm9tQXhpcyAodmVjMyB4QXhpcyx2ZWMzIHlBeGlzLHZlYzMgekF4aXMpe1xcbiAgbWF0MyBtID0gbWF0Myh4QXhpcyx5QXhpcyx6QXhpcyk7XFxuICBmbG9hdCB0cmFjZSA9IG1bMF1bMF0gKyBtWzFdWzFdICsgbVsyXVsyXTtcXG4gIHZlYzQgcXVhdDtcXG4gIGlmICh0cmFjZSA+IDAuKSB7XFxuICAgIGZsb2F0IHMgPSAwLjUgLyBzcXJ0KHRyYWNlICsgMS4wKTtcXG4gICAgcXVhdC53ID0gMC4yNSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzJdWzFdIC0gbVsxXVsyXSkgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsyXSAtIG1bMl1bMF0pICogcztcXG4gICAgcXVhdC56ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAqIHM7XFxuICB9IGVsc2UgaWYgKChtWzBdWzBdID4gbVsxXVsxXSkgJiYgKG1bMF1bMF0gPiBtWzJdWzJdKSkge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzBdWzBdIC0gbVsxXVsxXSAtIG1bMl1bMl0pO1xcbiAgICBxdWF0LncgPSAobVsyXVsxXSAtIG1bMV1bMl0pIC8gcztcXG4gICAgcXVhdC54ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueSA9IChtWzBdWzFdICsgbVsxXVswXSkgLyBzO1xcbiAgICBxdWF0LnogPSAobVswXVsyXSArIG1bMl1bMF0pIC8gcztcXG4gIH0gZWxzZSBpZiAobVsxXVsxXSA+IG1bMl1bMl0pIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsxXVsxXSAtIG1bMF1bMF0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzFdICsgbVsxXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAwLjI1ICogcztcXG4gICAgcXVhdC56ID0gKG1bMV1bMl0gKyBtWzJdWzFdKSAvIHM7XFxuICB9IGVsc2Uge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzJdWzJdIC0gbVswXVswXSAtIG1bMV1bMV0pO1xcbiAgICBxdWF0LncgPSAobVsxXVswXSAtIG1bMF1bMV0pIC8gcztcXG4gICAgcXVhdC54ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICAgIHF1YXQueSA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgICBxdWF0LnogPSAwLjI1ICogcztcXG4gIH1cXG4gIGZsb2F0IGxlbiA9IHF1YXQueCAqIHF1YXQueCArIHF1YXQueSAqIHF1YXQueSArIHF1YXQueiAqIHF1YXQueiArIHF1YXQudyAqIHF1YXQudztcXG4gIGlmIChsZW4gPiAwLikge1xcbiAgICBsZW4gPSAxLiAvIHNxcnQobGVuKTtcXG4gICAgcXVhdC54ID0gcXVhdC54ICogbGVuO1xcbiAgICBxdWF0LnkgPSBxdWF0LnkgKiBsZW47XFxuICAgIHF1YXQueiA9IHF1YXQueiAqIGxlbjtcXG4gICAgcXVhdC53ID0gcXVhdC53ICogbGVuO1xcbiAgfVxcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbnZlYzQgcXVhdGVybmlvbkZyb21FdWxlciAodmVjMyBhbmdsZSl7XFxuICBmbG9hdCB4ID0gYW5nbGUueCAvIDIuO1xcbiAgZmxvYXQgeSA9IGFuZ2xlLnkgLyAyLjtcXG4gIGZsb2F0IHogPSBhbmdsZS56IC8gMi47XFxuICBmbG9hdCBzeCA9IHNpbih4KTtcXG4gIGZsb2F0IGN4ID0gY29zKHgpO1xcbiAgZmxvYXQgc3kgPSBzaW4oeSk7XFxuICBmbG9hdCBjeSA9IGNvcyh5KTtcXG4gIGZsb2F0IHN6ID0gc2luKHopO1xcbiAgZmxvYXQgY3ogPSBjb3Moeik7XFxuICB2ZWM0IHF1YXQgPSB2ZWM0KDApO1xcbiAgcXVhdC54ID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xcbiAgcXVhdC55ID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xcbiAgcXVhdC56ID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xcbiAgcXVhdC53ID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbm1hdDQgbWF0cml4RnJvbVJUICh2ZWM0IHEsIHZlYzMgcCl7XFxuICBmbG9hdCB4MiA9IHEueCArIHEueDtcXG4gIGZsb2F0IHkyID0gcS55ICsgcS55O1xcbiAgZmxvYXQgejIgPSBxLnogKyBxLno7XFxuICBmbG9hdCB4eCA9IHEueCAqIHgyO1xcbiAgZmxvYXQgeHkgPSBxLnggKiB5MjtcXG4gIGZsb2F0IHh6ID0gcS54ICogejI7XFxuICBmbG9hdCB5eSA9IHEueSAqIHkyO1xcbiAgZmxvYXQgeXogPSBxLnkgKiB6MjtcXG4gIGZsb2F0IHp6ID0gcS56ICogejI7XFxuICBmbG9hdCB3eCA9IHEudyAqIHgyO1xcbiAgZmxvYXQgd3kgPSBxLncgKiB5MjtcXG4gIGZsb2F0IHd6ID0gcS53ICogejI7XFxuICByZXR1cm4gbWF0NChcXG4gICAgMS4gLSAoeXkgKyB6eiksIHh5ICsgd3osIHh6IC0gd3ksIDAsXFxuICAgIHh5IC0gd3osIDEuIC0gKHh4ICsgenopLCB5eiArIHd4LCAwLFxcbiAgICB4eiArIHd5LCB5eiAtIHd4LCAxLiAtICh4eCArIHl5KSwgMCxcXG4gICAgcC54LCBwLnksIHAueiwgMVxcbiAgKTtcXG59XFxubWF0NCBtYXRGcm9tUlRTICh2ZWM0IHEsIHZlYzMgdCwgdmVjMyBzKXtcXG4gIGZsb2F0IHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLnc7XFxuICBmbG9hdCB4MiA9IHggKyB4O1xcbiAgZmxvYXQgeTIgPSB5ICsgeTtcXG4gIGZsb2F0IHoyID0geiArIHo7XFxuICBmbG9hdCB4eCA9IHggKiB4MjtcXG4gIGZsb2F0IHh5ID0geCAqIHkyO1xcbiAgZmxvYXQgeHogPSB4ICogejI7XFxuICBmbG9hdCB5eSA9IHkgKiB5MjtcXG4gIGZsb2F0IHl6ID0geSAqIHoyO1xcbiAgZmxvYXQgenogPSB6ICogejI7XFxuICBmbG9hdCB3eCA9IHcgKiB4MjtcXG4gIGZsb2F0IHd5ID0gdyAqIHkyO1xcbiAgZmxvYXQgd3ogPSB3ICogejI7XFxuICBmbG9hdCBzeCA9IHMueDtcXG4gIGZsb2F0IHN5ID0gcy55O1xcbiAgZmxvYXQgc3ogPSBzLno7XFxuICByZXR1cm4gbWF0NCgoMS4gLSAoeXkgKyB6eikpICogc3gsICh4eSArIHd6KSAqIHN4LCAoeHogLSB3eSkgKiBzeCwgMCxcXG4gICAgKHh5IC0gd3opICogc3ksICgxLiAtICh4eCArIHp6KSkgKiBzeSwgKHl6ICsgd3gpICogc3ksIDAsXFxuICAgICh4eiArIHd5KSAqIHN6LCAoeXogLSB3eCkgKiBzeiwgKDEuIC0gKHh4ICsgeXkpKSAqIHN6LCAwLFxcbiAgICB0LngsIHQueSwgdC56LCAxKTtcXG59XFxudmVjNCBxdWF0TXVsdGlwbHkgKHZlYzQgYSwgdmVjNCBiKXtcXG4gIHZlYzQgcXVhdDtcXG4gIHF1YXQueCA9IGEueCAqIGIudyArIGEudyAqIGIueCArIGEueSAqIGIueiAtIGEueiAqIGIueTtcXG4gIHF1YXQueSA9IGEueSAqIGIudyArIGEudyAqIGIueSArIGEueiAqIGIueCAtIGEueCAqIGIuejtcXG4gIHF1YXQueiA9IGEueiAqIGIudyArIGEudyAqIGIueiArIGEueCAqIGIueSAtIGEueSAqIGIueDtcXG4gIHF1YXQudyA9IGEudyAqIGIudyAtIGEueCAqIGIueCAtIGEueSAqIGIueSAtIGEueiAqIGIuejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG52b2lkIHJvdGF0ZVZlY0Zyb21RdWF0IChpbm91dCB2ZWMzIHYsIHZlYzQgcSl7XFxuICBmbG9hdCBpeCA9IHEudyAqIHYueCArIHEueSAqIHYueiAtIHEueiAqIHYueTtcXG4gIGZsb2F0IGl5ID0gcS53ICogdi55ICsgcS56ICogdi54IC0gcS54ICogdi56O1xcbiAgZmxvYXQgaXogPSBxLncgKiB2LnogKyBxLnggKiB2LnkgLSBxLnkgKiB2Lng7XFxuICBmbG9hdCBpdyA9IC1xLnggKiB2LnggLSBxLnkgKiB2LnkgLSBxLnogKiB2Lno7XFxuICB2LnggPSBpeCAqIHEudyArIGl3ICogLXEueCArIGl5ICogLXEueiAtIGl6ICogLXEueTtcXG4gIHYueSA9IGl5ICogcS53ICsgaXcgKiAtcS55ICsgaXogKiAtcS54IC0gaXggKiAtcS56O1xcbiAgdi56ID0gaXogKiBxLncgKyBpdyAqIC1xLnogKyBpeCAqIC1xLnkgLSBpeSAqIC1xLng7XFxufVxcbnZlYzMgcm90YXRlSW5Mb2NhbFNwYWNlICh2ZWMzIHBvcywgdmVjMyB4QXhpcywgdmVjMyB5QXhpcywgdmVjMyB6QXhpcywgdmVjNCBxKXtcXG4gIHZlYzQgdmlld1F1YXQgPSBxdWF0ZXJuaW9uRnJvbUF4aXMoeEF4aXMsIHlBeGlzLCB6QXhpcyk7XFxuICB2ZWM0IHJvdFF1YXQgPSBxdWF0TXVsdGlwbHkodmlld1F1YXQsIHEpO1xcbiAgcm90YXRlVmVjRnJvbVF1YXQocG9zLCByb3RRdWF0KTtcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgcm90YXRlQ29ybmVyIChpbm91dCB2ZWMyIGNvcm5lciwgZmxvYXQgYW5nbGUpe1xcbiAgZmxvYXQgeE9TID0gY29zKGFuZ2xlKSAqIGNvcm5lci54IC0gc2luKGFuZ2xlKSAqIGNvcm5lci55O1xcbiAgZmxvYXQgeU9TID0gc2luKGFuZ2xlKSAqIGNvcm5lci54ICsgY29zKGFuZ2xlKSAqIGNvcm5lci55O1xcbiAgY29ybmVyLnggPSB4T1M7XFxuICBjb3JuZXIueSA9IHlPUztcXG59XFxudW5pZm9ybSB2ZWM0IG1haW5UaWxpbmdfT2Zmc2V0O1xcbnVuaWZvcm0gdmVjNCBmcmFtZVRpbGVfdmVsTGVuU2NhbGU7XFxudW5pZm9ybSB2ZWM0IHNjYWxlO1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3SW52O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG51bmlmb3JtIGhpZ2hwIHZlYzQgY2NfY2FtZXJhUG9zO1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB1djtcXG52YXJ5aW5nIG1lZGl1bXAgdmVjNCBjb2xvcjtcXG52b2lkIGNvbXB1dGVWZXJ0UG9zIChpbm91dCB2ZWM0IHBvcywgdmVjMiB2ZXJ0T2Zmc2V0LCB2ZWM0IHEsIHZlYzMgc1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICwgbWF0NCB2aWV3SW52XFxuI2VuZGlmXFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICwgdmVjMyBleWVcXG4gICwgdmVjNCB2ZWxvY2l0eVxcbiAgLCBmbG9hdCB2ZWxvY2l0eVNjYWxlXFxuICAsIGZsb2F0IGxlbmd0aFNjYWxlXFxuICAsIGZsb2F0IHhJbmRleFxcbiNlbmRpZlxcbikge1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzBdLCB2aWV3SW52WzFdWzBdLCB2aWV3SW52WzJdWzBdKSk7XFxuICB2ZWMzIGNhbVkgPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzFdLCB2aWV3SW52WzFdWzFdLCB2aWV3SW52WzJdWzFdKSk7XFxuICB2ZWMzIGNhbVogPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzJdLCB2aWV3SW52WzFdWzJdLCB2aWV3SW52WzJdWzJdKSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjYW1aLCBxKTtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICB2ZWMzIGNhbVJpZ2h0ID0gbm9ybWFsaXplKGNyb3NzKHBvcy54eXogLSBleWUsIHZlbG9jaXR5Lnh5eikpICogcy54O1xcbiAgdmVjMyBjYW1VcCA9IHZlbG9jaXR5Lnh5eiAqIHZlbG9jaXR5U2NhbGUgKyBub3JtYWxpemUodmVsb2NpdHkueHl6KSAqIGxlbmd0aFNjYWxlICogcy55O1xcbiAgcG9zLnh5eiArPSAoY2FtUmlnaHQgKiBhYnModmVydE9mZnNldC54KSAqIHNpZ24odmVydE9mZnNldC55KSkgLSBjYW1VcCAqIHhJbmRleDtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAyXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSB2ZWMzKDEsIDAsIDApO1xcbiAgdmVjMyBjYW1ZID0gdmVjMygwLCAwLCAtMSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjcm9zcyhjYW1YLCBjYW1ZKSwgcSk7XFxuI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgdmVjMiB2aWV3U3BhY2VWZXJ0ID0gdmVjMih2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSk7XFxuICByb3RhdGVDb3JuZXIodmlld1NwYWNlVmVydCwgcS56KTtcXG4gIHZlYzMgY2FtWCA9IG5vcm1hbGl6ZSh2ZWMzKGNjX21hdFZpZXdbMF1bMF0sIGNjX21hdFZpZXdbMV1bMF0sIGNjX21hdFZpZXdbMl1bMF0pKTtcXG4gIHZlYzMgY2FtWSA9IHZlYzMoMCwgMSwgMCk7XFxuICB2ZWMzIG9mZnNldCA9IGNhbVggKiB2aWV3U3BhY2VWZXJ0LnggKyBjYW1ZICogdmlld1NwYWNlVmVydC55O1xcbiAgcG9zLnh5eiArPSBvZmZzZXQ7XFxuI2Vsc2VcXG4gIHBvcy54ICs9IHZlcnRPZmZzZXQueDtcXG4gIHBvcy55ICs9IHZlcnRPZmZzZXQueTtcXG4jZW5kaWZcXG59XFxudmVjMiBjb21wdXRlVVYgKGZsb2F0IGZyYW1lSW5kZXgsIHZlYzIgdmVydEluZGV4LCB2ZWMyIGZyYW1lVGlsZSl7XFxuICB2ZWMyIGFuaVVWID0gdmVjMigwLCBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnkpKTtcXG4gIGFuaVVWLnggPSBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnggKiBmcmFtZVRpbGUueSAtIGFuaVVWLnkgKiBmcmFtZVRpbGUueCk7XFxuI2lmIENDX1JFTkRFUl9NT0RFICE9IDRcXG4gIHZlcnRJbmRleC55ID0gMS4gLSB2ZXJ0SW5kZXgueTtcXG4jZW5kaWZcXG4gIHJldHVybiAoYW5pVVYueHkgKyB2ZXJ0SW5kZXgpIC8gdmVjMihmcmFtZVRpbGUueCwgZnJhbWVUaWxlLnkpO1xcbn1cXG51bmlmb3JtIHZlYzQgdV9zYW1wbGVJbmZvO1xcbnVuaWZvcm0gdmVjNCB1X3dvcmxkUm90O1xcbnVuaWZvcm0gdmVjNCB1X3RpbWVEZWx0YTtcXG5hdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uX3N0YXJ0dGltZTtcXG5hdHRyaWJ1dGUgdmVjNCBhX3NpemVfdXY7XFxuYXR0cmlidXRlIHZlYzQgYV9yb3RhdGlvbl91djtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGlyX2xpZmU7XFxuYXR0cmlidXRlIGZsb2F0IGFfcm5kU2VlZDtcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gNFxcbiAgYXR0cmlidXRlIHZlYzMgYV90ZXhDb29yZDtcXG4gIGF0dHJpYnV0ZSB2ZWMzIGFfdGV4Q29vcmQzO1xcbiAgYXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XFxuICBhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yMTtcXG4jZW5kaWZcXG52ZWMzIHVucGFja0N1cnZlRGF0YSAoc2FtcGxlcjJEIHRleCwgdmVjMiBjb29yZCkge1xcbiAgICB2ZWM0IGEgPSB0ZXh0dXJlMkQodGV4LCBjb29yZCk7XFxuICAgIHZlYzQgYiA9IHRleHR1cmUyRCh0ZXgsIGNvb3JkICsgdV9zYW1wbGVJbmZvLnkpO1xcbiAgICBmbG9hdCBjID0gZnJhY3QoY29vcmQueCAqIHVfc2FtcGxlSW5mby54KTtcXG4gICAgcmV0dXJuIG1peChhLnh5eiwgYi54eXosIGMpO1xcbn1cXG52ZWMzIHVucGFja0N1cnZlRGF0YSAoc2FtcGxlcjJEIHRleCwgdmVjMiBjb29yZCwgb3V0IGZsb2F0IHcpIHtcXG4gICAgdmVjNCBhID0gdGV4dHVyZTJEKHRleCwgY29vcmQpO1xcbiAgICB2ZWM0IGIgPSB0ZXh0dXJlMkQodGV4LCBjb29yZCArIHVfc2FtcGxlSW5mby55KTtcXG4gICAgZmxvYXQgYyA9IGZyYWN0KGNvb3JkLnggKiB1X3NhbXBsZUluZm8ueCk7XFxuICAgIHcgPSBtaXgoYS53LCBiLncsIGMpO1xcbiAgICByZXR1cm4gbWl4KGEueHl6LCBiLnh5eiwgYyk7XFxufVxcbmZsb2F0IHBzZXVkb1JhbmRvbSAoZmxvYXQgc2VlZCkge1xcbiAgc2VlZCA9IG1vZChzZWVkLCAyMzMyODAuKTtcXG4gIGZsb2F0IHEgPSAoc2VlZCAqIDkzMDEuICsgNDkyOTcuKSAvIDIzMzI4MC47XFxuICByZXR1cm4gZnJhY3QocSk7XFxufVxcbiNpZiBDT0xPUl9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgY29sb3Jfb3Zlcl90aW1lX3RleDA7XFxuICB1bmlmb3JtIGludCB1X2NvbG9yX21vZGU7XFxuI2VuZGlmXFxuI2lmIFJPVEFUSU9OX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICB1bmlmb3JtIHNhbXBsZXIyRCByb3RhdGlvbl9vdmVyX3RpbWVfdGV4MDtcXG4gIHVuaWZvcm0gaW50IHVfcm90YXRpb25fbW9kZTtcXG4jZW5kaWZcXG4jaWYgU0laRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgc2l6ZV9vdmVyX3RpbWVfdGV4MDtcXG4gIHVuaWZvcm0gaW50IHVfc2l6ZV9tb2RlO1xcbiNlbmRpZlxcbiNpZiBGT1JDRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZm9yY2Vfb3Zlcl90aW1lX3RleDA7XFxuICB1bmlmb3JtIGludCB1X2ZvcmNlX21vZGU7XFxudW5pZm9ybSBpbnQgdV9mb3JjZV9zcGFjZTtcXG4jZW5kaWZcXG4jaWYgVkVMT0NJVFlfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHZlbG9jaXR5X292ZXJfdGltZV90ZXgwO1xcbiAgdW5pZm9ybSBpbnQgdV92ZWxvY2l0eV9tb2RlO1xcbnVuaWZvcm0gaW50IHVfdmVsb2NpdHlfc3BhY2U7XFxuI2VuZGlmXFxuI2lmIFRFWFRVUkVfQU5JTUFUSU9OX01PRFVMRV9FTkFCTEVcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVfYW5pbWF0aW9uX3RleDA7XFxuICB1bmlmb3JtIHZlYzQgdV9hbmltX2luZm87XFxuI2VuZGlmXFxuZmxvYXQgcmVwZWF0IChmbG9hdCB0LCBmbG9hdCBsZW5ndGgpIHtcXG4gIHJldHVybiB0IC0gZmxvb3IodCAvIGxlbmd0aCkgKiBsZW5ndGg7XFxufVxcbnZlYzQgcm90YXRlUXVhdCAodmVjNCBwLCB2ZWM0IHEpIHtcXG4gIHZlYzMgaXYgPSBjcm9zcyhxLnh5eiwgcC54eXopICsgcS53ICogcC54eXo7XFxuICB2ZWMzIHJlcyA9IHAueHl6ICsgMi4wICogY3Jvc3MocS54eXosIGl2KTtcXG4gIHJldHVybiB2ZWM0KHJlcy54eXosIHAudyk7XFxufVxcbnZlYzQgZ3B2c19tYWluICgpIHtcXG4gIGZsb2F0IGFjdGl2ZVRpbWUgPSB1X3RpbWVEZWx0YS54IC0gYV9wb3NpdGlvbl9zdGFydHRpbWUudztcXG4gIGZsb2F0IG5vcm1hbGl6ZWRUaW1lID0gY2xhbXAoYWN0aXZlVGltZSAvIGFfZGlyX2xpZmUudywgMC4wLCAxLjApO1xcbiAgdmVjMiB0aW1lQ29vcmQwID0gdmVjMihub3JtYWxpemVkVGltZSwgMC4pO1xcbiAgdmVjMiB0aW1lQ29vcmQxID0gdmVjMihub3JtYWxpemVkVGltZSwgMS4pO1xcbiAgI2lmIENDX1JFTkRFUl9NT0RFID09IDRcXG4gICAgdmVjMiB2ZXJ0SWR4ID0gdmVjMihhX3RleENvb3JkLngsIGFfdGV4Q29vcmQueSk7XFxuICAjZWxzZVxcbiAgICB2ZWMyIHZlcnRJZHggPSB2ZWMyKGFfc2l6ZV91di53LCBhX3JvdGF0aW9uX3V2LncpO1xcbiAgI2VuZGlmXFxuICB2ZWM0IHZlbG9jaXR5ID0gdmVjNChhX2Rpcl9saWZlLnh5eiwgMC4pO1xcbiAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb25fc3RhcnR0aW1lLnh5eiwgMS4pO1xcbiAgdmVjMyBzaXplID0gYV9zaXplX3V2Lnh5ejtcXG4gICNpZiBTSVpFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICAgIGlmICh1X3NpemVfbW9kZSA9PSAxKSB7XFxuICAgICAgc2l6ZSAqPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyBzaXplXzAgPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyBzaXplXzEgPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX3MgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgMzk4MjUuKTtcXG4gICAgICBzaXplICo9IG1peChzaXplXzAsIHNpemVfMSwgZmFjdG9yX3MpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4gIHZlYzMgY29tcFNjYWxlID0gc2NhbGUueHl6ICogc2l6ZTtcXG4gICNpZiBGT1JDRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgICB2ZWMzIGZvcmNlQW5pbSA9IHZlYzMoMC4pO1xcbiAgICBpZiAodV9mb3JjZV9tb2RlID09IDEpIHtcXG4gICAgICBmb3JjZUFuaW0gPSB1bnBhY2tDdXJ2ZURhdGEoZm9yY2Vfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgZm9yY2VfMCA9IHVucGFja0N1cnZlRGF0YShmb3JjZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyBmb3JjZV8xID0gdW5wYWNrQ3VydmVEYXRhKGZvcmNlX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfZiA9ICBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgMjEyMTY1Lik7XFxuICAgICAgZm9yY2VBbmltID0gbWl4KGZvcmNlXzAsIGZvcmNlXzEsIGZhY3Rvcl9mKTtcXG4gICAgfVxcbiAgICB2ZWM0IGZvcmNlVHJhY2sgPSB2ZWM0KGZvcmNlQW5pbSwgMC4pO1xcbiAgICBpZiAodV9mb3JjZV9zcGFjZSA9PSAwKSB7XFxuICAgICAgZm9yY2VUcmFjayA9IHJvdGF0ZVF1YXQoZm9yY2VUcmFjaywgdV93b3JsZFJvdCk7XFxuICAgIH1cXG4gICAgdmVsb2NpdHkueHl6ICs9IGZvcmNlVHJhY2sueHl6O1xcbiAgI2VuZGlmXFxuICAjaWYgVkVMT0NJVFlfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgZmxvYXQgc3BlZWRNb2RpZmllcjAgPSAxLjtcXG4gICAgZmxvYXQgc3BlZWRNb2RpZmllcjEgPSAxLjtcXG4gICAgdmVjMyB2ZWxvY2l0eUFuaW0gPSB2ZWMzKDAuKTtcXG4gICAgaWYgKHVfdmVsb2NpdHlfbW9kZSA9PSAxKSB7XFxuICAgICAgdmVsb2NpdHlBbmltID0gdW5wYWNrQ3VydmVEYXRhKHZlbG9jaXR5X292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwLCBzcGVlZE1vZGlmaWVyMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyB2ZWN0b3J5XzAgPSB1bnBhY2tDdXJ2ZURhdGEodmVsb2NpdHlfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDAsIHNwZWVkTW9kaWZpZXIwKTtcXG4gICAgICB2ZWMzIHZlY3RvcnlfMSA9IHVucGFja0N1cnZlRGF0YSh2ZWxvY2l0eV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMSwgc3BlZWRNb2RpZmllcjEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl92ID0gcHNldWRvUmFuZG9tKGFfcm5kU2VlZCArIDE5Nzg2Ni4pO1xcbiAgICAgIHZlbG9jaXR5QW5pbSA9IG1peCh2ZWN0b3J5XzAsIHZlY3RvcnlfMSwgZmFjdG9yX3YpO1xcbiAgICAgIHNwZWVkTW9kaWZpZXIwID0gbWl4KHNwZWVkTW9kaWZpZXIwLCBzcGVlZE1vZGlmaWVyMSwgZmFjdG9yX3YpO1xcbiAgICB9XFxuICAgIHZlYzQgdmVsb2NpdHlUcmFjayA9IHZlYzQodmVsb2NpdHlBbmltLCAwLik7XFxuICAgIGlmICh1X3ZlbG9jaXR5X3NwYWNlID09IDApIHtcXG4gICAgICB2ZWxvY2l0eVRyYWNrID0gcm90YXRlUXVhdCh2ZWxvY2l0eVRyYWNrLCB1X3dvcmxkUm90KTtcXG4gICAgfVxcbiAgICB2ZWxvY2l0eS54eXogKz0gdmVsb2NpdHlUcmFjay54eXo7XFxuICAgIHZlbG9jaXR5Lnh5eiAqPSBzcGVlZE1vZGlmaWVyMDtcXG4gICNlbmRpZlxcbiAgcG9zLnh5eiArPSB2ZWxvY2l0eS54eXogKiBub3JtYWxpemVkVGltZSAqIGFfZGlyX2xpZmUudztcXG4gICNpZiAhQ0NfVVNFX1dPUkxEX1NQQUNFXFxuICAgIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICAgIHZlbG9jaXR5ID0gcm90YXRlUXVhdCh2ZWxvY2l0eSwgdV93b3JsZFJvdCk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICB2ZWMzIHJvdGF0aW9uID0gYV9yb3RhdGlvbl91di54eXo7XFxuICAjaWYgUk9UQVRJT05fT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgaWYgKHVfcm90YXRpb25fbW9kZSA9PSAxKSB7XFxuICAgICAgcm90YXRpb24gKz0gdW5wYWNrQ3VydmVEYXRhKHJvdGF0aW9uX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKSAqIG5vcm1hbGl6ZWRUaW1lICogYV9kaXJfbGlmZS53O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgcm90YXRpb25fMCA9IHVucGFja0N1cnZlRGF0YShyb3RhdGlvbl9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyByb3RhdGlvbl8xID0gdW5wYWNrQ3VydmVEYXRhKHJvdGF0aW9uX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfciA9IHBzZXVkb1JhbmRvbShhX3JuZFNlZWQgKyAxMjUyOTIuKTtcXG4gICAgICByb3RhdGlvbiArPSBtaXgocm90YXRpb25fMCwgcm90YXRpb25fMSwgZmFjdG9yX3IpICogbm9ybWFsaXplZFRpbWUgKiBhX2Rpcl9saWZlLnc7XFxuICAgIH1cXG4gICNlbmRpZlxcbiAgI2lmIENPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICAgIGlmICh1X2NvbG9yX21vZGUgPT0gMSkge1xcbiAgICAgIGNvbG9yID0gYV9jb2xvciAqIHRleHR1cmUyRChjb2xvcl9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjNCBjb2xvcl8wID0gdGV4dHVyZTJEKGNvbG9yX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgICB2ZWM0IGNvbG9yXzEgPSB0ZXh0dXJlMkQoY29sb3Jfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl9jID0gcHNldWRvUmFuZG9tKGFfcm5kU2VlZCArIDkxMDQxLik7XFxuICAgICAgY29sb3IgPSBhX2NvbG9yICogbWl4KGNvbG9yXzAsIGNvbG9yXzEsIGZhY3Rvcl9jKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgICB2ZWMyIGNvcm5lck9mZnNldCA9IHZlYzIoKHZlcnRJZHggLSAwLjUpKTtcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gcm90YXRpb24ueHl6O1xcbiAgICAjZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgdmVjMyByb3RFdWxlciA9IHZlYzMoMC4pO1xcbiAgICAjZWxzZVxcbiAgICAgIHZlYzMgcm90RXVsZXIgPSB2ZWMzKDAuLCAwLiwgcm90YXRpb24ueik7XFxuICAgICNlbmRpZlxcbiAgICBjb21wdXRlVmVydFBvcyhwb3MsIGNvcm5lck9mZnNldCwgcXVhdGVybmlvbkZyb21FdWxlcihyb3RFdWxlciksIGNvbXBTY2FsZVxcbiAgICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICAgICAgICwgY2NfbWF0Vmlld0ludlxcbiAgICAgICNlbmRpZlxcbiAgICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgICAsIGNjX2NhbWVyYVBvcy54eXpcXG4gICAgICAgICwgdmVsb2NpdHlcXG4gICAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLnpcXG4gICAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLndcXG4gICAgICAgICwgYV9zaXplX3V2LndcXG4gICAgICAjZW5kaWZcXG4gICAgKTtcXG4gICNlbHNlXFxuICAgIG1hdDQgeGZvcm1Ob1NjYWxlID0gbWF0cml4RnJvbVJUKHF1YXRlcm5pb25Gcm9tRXVsZXIocm90YXRpb24pLCBwb3MueHl6KTtcXG4gICAgbWF0NCB4Zm9ybSA9IG1hdEZyb21SVFMocXVhdGVybmlvbkZyb21FdWxlcihyb3RhdGlvbiksIHBvcy54eXosIGNvbXBTY2FsZSk7XFxuICAgIHBvcyA9IHhmb3JtICogdmVjNChhX3RleENvb3JkMywgMSk7XFxuICAgIHZlYzQgbm9ybWFsID0geGZvcm1Ob1NjYWxlICogdmVjNChhX25vcm1hbCwgMCk7XFxuICAgIGNvbG9yICo9IGFfY29sb3IxO1xcbiAgI2VuZGlmXFxuICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gIGZsb2F0IGZyYW1lSW5kZXggPSAwLjtcXG4gICNpZiBURVhUVVJFX0FOSU1BVElPTl9NT0RVTEVfRU5BQkxFXFxuICAgIGZsb2F0IHN0YXJ0RnJhbWUgPSAwLjtcXG4gICAgdmVjMyBmcmFtZUluZm8gPSB2ZWMzKDAuKTtcXG4gICAgaWYgKGludCh1X2FuaW1faW5mby54KSA9PSAxKSB7XFxuICAgICAgZnJhbWVJbmZvID0gdW5wYWNrQ3VydmVEYXRhKHRleHR1cmVfYW5pbWF0aW9uX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgZnJhbWVJbmZvMCA9IHVucGFja0N1cnZlRGF0YSh0ZXh0dXJlX2FuaW1hdGlvbl90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgICB2ZWMzIGZyYW1lSW5mbzEgPSB1bnBhY2tDdXJ2ZURhdGEodGV4dHVyZV9hbmltYXRpb25fdGV4MCwgdGltZUNvb3JkMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX3QgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgOTA3OTQuKTtcXG4gICAgICBmcmFtZUluZm8gPSBtaXgoZnJhbWVJbmZvMCwgZnJhbWVJbmZvMSwgZmFjdG9yX3QpO1xcbiAgICB9XFxuICAgIHN0YXJ0RnJhbWUgPSBmcmFtZUluZm8ueCAvIHVfYW5pbV9pbmZvLnk7XFxuICAgIGZyYW1lSW5kZXggPSByZXBlYXQodV9hbmltX2luZm8ueiAqIChmcmFtZUluZm8ueSArIHN0YXJ0RnJhbWUpLCAxLik7XFxuICAjZW5kaWZcXG4gIHV2ID0gY29tcHV0ZVVWKGZyYW1lSW5kZXgsIHZlcnRJZHgsIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS54eSkgKiBtYWluVGlsaW5nX09mZnNldC54eSArIG1haW5UaWxpbmdfT2Zmc2V0Lnp3O1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IGdwdnNfbWFpbigpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbnVuaWZvcm0gdmVjNCB0aW50Q29sb3I7XFxudmVjNCBhZGQgKCkge1xcbiAgdmVjNCBjb2wgPSAyLjAgKiBjb2xvciAqIHRpbnRDb2xvciAqIHRleHR1cmUyRChtYWluVGV4dHVyZSwgdXYpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2wpO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX0ZyYWdDb2xvciA9IGFkZCgpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsNFwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnZlYzQgcXVhdGVybmlvbkZyb21BeGlzICh2ZWMzIHhBeGlzLHZlYzMgeUF4aXMsdmVjMyB6QXhpcyl7XFxuICBtYXQzIG0gPSBtYXQzKHhBeGlzLHlBeGlzLHpBeGlzKTtcXG4gIGZsb2F0IHRyYWNlID0gbVswXVswXSArIG1bMV1bMV0gKyBtWzJdWzJdO1xcbiAgdmVjNCBxdWF0O1xcbiAgaWYgKHRyYWNlID4gMC4pIHtcXG4gICAgZmxvYXQgcyA9IDAuNSAvIHNxcnQodHJhY2UgKyAxLjApO1xcbiAgICBxdWF0LncgPSAwLjI1IC8gcztcXG4gICAgcXVhdC54ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAqIHM7XFxuICAgIHF1YXQueSA9IChtWzBdWzJdIC0gbVsyXVswXSkgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVswXSAtIG1bMF1bMV0pICogcztcXG4gIH0gZWxzZSBpZiAoKG1bMF1bMF0gPiBtWzFdWzFdKSAmJiAobVswXVswXSA+IG1bMl1bMl0pKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMF1bMF0gLSBtWzFdWzFdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzJdWzFdIC0gbVsxXVsyXSkgLyBzO1xcbiAgICBxdWF0LnggPSAwLjI1ICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueiA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgfSBlbHNlIGlmIChtWzFdWzFdID4gbVsyXVsyXSkge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzFdWzFdIC0gbVswXVswXSAtIG1bMl1bMl0pO1xcbiAgICBxdWF0LncgPSAobVswXVsyXSAtIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC54ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueSA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gIH0gZWxzZSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMl1bMl0gLSBtWzBdWzBdIC0gbVsxXVsxXSk7XFxuICAgIHF1YXQudyA9IChtWzFdWzBdIC0gbVswXVsxXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsyXSArIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gKG1bMV1bMl0gKyBtWzJdWzFdKSAvIHM7XFxuICAgIHF1YXQueiA9IDAuMjUgKiBzO1xcbiAgfVxcbiAgZmxvYXQgbGVuID0gcXVhdC54ICogcXVhdC54ICsgcXVhdC55ICogcXVhdC55ICsgcXVhdC56ICogcXVhdC56ICsgcXVhdC53ICogcXVhdC53O1xcbiAgaWYgKGxlbiA+IDAuKSB7XFxuICAgIGxlbiA9IDEuIC8gc3FydChsZW4pO1xcbiAgICBxdWF0LnggPSBxdWF0LnggKiBsZW47XFxuICAgIHF1YXQueSA9IHF1YXQueSAqIGxlbjtcXG4gICAgcXVhdC56ID0gcXVhdC56ICogbGVuO1xcbiAgICBxdWF0LncgPSBxdWF0LncgKiBsZW47XFxuICB9XFxuICByZXR1cm4gcXVhdDtcXG59XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUV1bGVyICh2ZWMzIGFuZ2xlKXtcXG4gIGZsb2F0IHggPSBhbmdsZS54IC8gMi47XFxuICBmbG9hdCB5ID0gYW5nbGUueSAvIDIuO1xcbiAgZmxvYXQgeiA9IGFuZ2xlLnogLyAyLjtcXG4gIGZsb2F0IHN4ID0gc2luKHgpO1xcbiAgZmxvYXQgY3ggPSBjb3MoeCk7XFxuICBmbG9hdCBzeSA9IHNpbih5KTtcXG4gIGZsb2F0IGN5ID0gY29zKHkpO1xcbiAgZmxvYXQgc3ogPSBzaW4oeik7XFxuICBmbG9hdCBjeiA9IGNvcyh6KTtcXG4gIHZlYzQgcXVhdCA9IHZlYzQoMCk7XFxuICBxdWF0LnggPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XFxuICBxdWF0LnkgPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XFxuICBxdWF0LnogPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XFxuICBxdWF0LncgPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XFxuICByZXR1cm4gcXVhdDtcXG59XFxubWF0NCBtYXRyaXhGcm9tUlQgKHZlYzQgcSwgdmVjMyBwKXtcXG4gIGZsb2F0IHgyID0gcS54ICsgcS54O1xcbiAgZmxvYXQgeTIgPSBxLnkgKyBxLnk7XFxuICBmbG9hdCB6MiA9IHEueiArIHEuejtcXG4gIGZsb2F0IHh4ID0gcS54ICogeDI7XFxuICBmbG9hdCB4eSA9IHEueCAqIHkyO1xcbiAgZmxvYXQgeHogPSBxLnggKiB6MjtcXG4gIGZsb2F0IHl5ID0gcS55ICogeTI7XFxuICBmbG9hdCB5eiA9IHEueSAqIHoyO1xcbiAgZmxvYXQgenogPSBxLnogKiB6MjtcXG4gIGZsb2F0IHd4ID0gcS53ICogeDI7XFxuICBmbG9hdCB3eSA9IHEudyAqIHkyO1xcbiAgZmxvYXQgd3ogPSBxLncgKiB6MjtcXG4gIHJldHVybiBtYXQ0KFxcbiAgICAxLiAtICh5eSArIHp6KSwgeHkgKyB3eiwgeHogLSB3eSwgMCxcXG4gICAgeHkgLSB3eiwgMS4gLSAoeHggKyB6eiksIHl6ICsgd3gsIDAsXFxuICAgIHh6ICsgd3ksIHl6IC0gd3gsIDEuIC0gKHh4ICsgeXkpLCAwLFxcbiAgICBwLngsIHAueSwgcC56LCAxXFxuICApO1xcbn1cXG5tYXQ0IG1hdEZyb21SVFMgKHZlYzQgcSwgdmVjMyB0LCB2ZWMzIHMpe1xcbiAgZmxvYXQgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcXG4gIGZsb2F0IHgyID0geCArIHg7XFxuICBmbG9hdCB5MiA9IHkgKyB5O1xcbiAgZmxvYXQgejIgPSB6ICsgejtcXG4gIGZsb2F0IHh4ID0geCAqIHgyO1xcbiAgZmxvYXQgeHkgPSB4ICogeTI7XFxuICBmbG9hdCB4eiA9IHggKiB6MjtcXG4gIGZsb2F0IHl5ID0geSAqIHkyO1xcbiAgZmxvYXQgeXogPSB5ICogejI7XFxuICBmbG9hdCB6eiA9IHogKiB6MjtcXG4gIGZsb2F0IHd4ID0gdyAqIHgyO1xcbiAgZmxvYXQgd3kgPSB3ICogeTI7XFxuICBmbG9hdCB3eiA9IHcgKiB6MjtcXG4gIGZsb2F0IHN4ID0gcy54O1xcbiAgZmxvYXQgc3kgPSBzLnk7XFxuICBmbG9hdCBzeiA9IHMuejtcXG4gIHJldHVybiBtYXQ0KCgxLiAtICh5eSArIHp6KSkgKiBzeCwgKHh5ICsgd3opICogc3gsICh4eiAtIHd5KSAqIHN4LCAwLFxcbiAgICAoeHkgLSB3eikgKiBzeSwgKDEuIC0gKHh4ICsgenopKSAqIHN5LCAoeXogKyB3eCkgKiBzeSwgMCxcXG4gICAgKHh6ICsgd3kpICogc3osICh5eiAtIHd4KSAqIHN6LCAoMS4gLSAoeHggKyB5eSkpICogc3osIDAsXFxuICAgIHQueCwgdC55LCB0LnosIDEpO1xcbn1cXG52ZWM0IHF1YXRNdWx0aXBseSAodmVjNCBhLCB2ZWM0IGIpe1xcbiAgdmVjNCBxdWF0O1xcbiAgcXVhdC54ID0gYS54ICogYi53ICsgYS53ICogYi54ICsgYS55ICogYi56IC0gYS56ICogYi55O1xcbiAgcXVhdC55ID0gYS55ICogYi53ICsgYS53ICogYi55ICsgYS56ICogYi54IC0gYS54ICogYi56O1xcbiAgcXVhdC56ID0gYS56ICogYi53ICsgYS53ICogYi56ICsgYS54ICogYi55IC0gYS55ICogYi54O1xcbiAgcXVhdC53ID0gYS53ICogYi53IC0gYS54ICogYi54IC0gYS55ICogYi55IC0gYS56ICogYi56O1xcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbnZvaWQgcm90YXRlVmVjRnJvbVF1YXQgKGlub3V0IHZlYzMgdiwgdmVjNCBxKXtcXG4gIGZsb2F0IGl4ID0gcS53ICogdi54ICsgcS55ICogdi56IC0gcS56ICogdi55O1xcbiAgZmxvYXQgaXkgPSBxLncgKiB2LnkgKyBxLnogKiB2LnggLSBxLnggKiB2Lno7XFxuICBmbG9hdCBpeiA9IHEudyAqIHYueiArIHEueCAqIHYueSAtIHEueSAqIHYueDtcXG4gIGZsb2F0IGl3ID0gLXEueCAqIHYueCAtIHEueSAqIHYueSAtIHEueiAqIHYuejtcXG4gIHYueCA9IGl4ICogcS53ICsgaXcgKiAtcS54ICsgaXkgKiAtcS56IC0gaXogKiAtcS55O1xcbiAgdi55ID0gaXkgKiBxLncgKyBpdyAqIC1xLnkgKyBpeiAqIC1xLnggLSBpeCAqIC1xLno7XFxuICB2LnogPSBpeiAqIHEudyArIGl3ICogLXEueiArIGl4ICogLXEueSAtIGl5ICogLXEueDtcXG59XFxudmVjMyByb3RhdGVJbkxvY2FsU3BhY2UgKHZlYzMgcG9zLCB2ZWMzIHhBeGlzLCB2ZWMzIHlBeGlzLCB2ZWMzIHpBeGlzLCB2ZWM0IHEpe1xcbiAgdmVjNCB2aWV3UXVhdCA9IHF1YXRlcm5pb25Gcm9tQXhpcyh4QXhpcywgeUF4aXMsIHpBeGlzKTtcXG4gIHZlYzQgcm90UXVhdCA9IHF1YXRNdWx0aXBseSh2aWV3UXVhdCwgcSk7XFxuICByb3RhdGVWZWNGcm9tUXVhdChwb3MsIHJvdFF1YXQpO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCByb3RhdGVDb3JuZXIgKGlub3V0IHZlYzIgY29ybmVyLCBmbG9hdCBhbmdsZSl7XFxuICBmbG9hdCB4T1MgPSBjb3MoYW5nbGUpICogY29ybmVyLnggLSBzaW4oYW5nbGUpICogY29ybmVyLnk7XFxuICBmbG9hdCB5T1MgPSBzaW4oYW5nbGUpICogY29ybmVyLnggKyBjb3MoYW5nbGUpICogY29ybmVyLnk7XFxuICBjb3JuZXIueCA9IHhPUztcXG4gIGNvcm5lci55ID0geU9TO1xcbn1cXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDApIHVuaWZvcm0gQ29uc3RhbnRzIHtcXG4gIHZlYzQgbWFpblRpbGluZ19PZmZzZXQ7XFxuICB2ZWM0IGZyYW1lVGlsZV92ZWxMZW5TY2FsZTtcXG4gIHZlYzQgc2NhbGU7XFxufTtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCBtZWRpdW1wIHZlYzIgdXY7XFxubGF5b3V0KGxvY2F0aW9uID0gMSkgb3V0IG1lZGl1bXAgdmVjNCBjb2xvcjtcXG52b2lkIGNvbXB1dGVWZXJ0UG9zIChpbm91dCB2ZWM0IHBvcywgdmVjMiB2ZXJ0T2Zmc2V0LCB2ZWM0IHEsIHZlYzMgc1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICwgbWF0NCB2aWV3SW52XFxuI2VuZGlmXFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICwgdmVjMyBleWVcXG4gICwgdmVjNCB2ZWxvY2l0eVxcbiAgLCBmbG9hdCB2ZWxvY2l0eVNjYWxlXFxuICAsIGZsb2F0IGxlbmd0aFNjYWxlXFxuICAsIGZsb2F0IHhJbmRleFxcbiNlbmRpZlxcbikge1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzBdLCB2aWV3SW52WzFdWzBdLCB2aWV3SW52WzJdWzBdKSk7XFxuICB2ZWMzIGNhbVkgPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzFdLCB2aWV3SW52WzFdWzFdLCB2aWV3SW52WzJdWzFdKSk7XFxuICB2ZWMzIGNhbVogPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzJdLCB2aWV3SW52WzFdWzJdLCB2aWV3SW52WzJdWzJdKSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjYW1aLCBxKTtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICB2ZWMzIGNhbVJpZ2h0ID0gbm9ybWFsaXplKGNyb3NzKHBvcy54eXogLSBleWUsIHZlbG9jaXR5Lnh5eikpICogcy54O1xcbiAgdmVjMyBjYW1VcCA9IHZlbG9jaXR5Lnh5eiAqIHZlbG9jaXR5U2NhbGUgKyBub3JtYWxpemUodmVsb2NpdHkueHl6KSAqIGxlbmd0aFNjYWxlICogcy55O1xcbiAgcG9zLnh5eiArPSAoY2FtUmlnaHQgKiBhYnModmVydE9mZnNldC54KSAqIHNpZ24odmVydE9mZnNldC55KSkgLSBjYW1VcCAqIHhJbmRleDtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAyXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSB2ZWMzKDEsIDAsIDApO1xcbiAgdmVjMyBjYW1ZID0gdmVjMygwLCAwLCAtMSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjcm9zcyhjYW1YLCBjYW1ZKSwgcSk7XFxuI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgdmVjMiB2aWV3U3BhY2VWZXJ0ID0gdmVjMih2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSk7XFxuICByb3RhdGVDb3JuZXIodmlld1NwYWNlVmVydCwgcS56KTtcXG4gIHZlYzMgY2FtWCA9IG5vcm1hbGl6ZSh2ZWMzKGNjX21hdFZpZXdbMF1bMF0sIGNjX21hdFZpZXdbMV1bMF0sIGNjX21hdFZpZXdbMl1bMF0pKTtcXG4gIHZlYzMgY2FtWSA9IHZlYzMoMCwgMSwgMCk7XFxuICB2ZWMzIG9mZnNldCA9IGNhbVggKiB2aWV3U3BhY2VWZXJ0LnggKyBjYW1ZICogdmlld1NwYWNlVmVydC55O1xcbiAgcG9zLnh5eiArPSBvZmZzZXQ7XFxuI2Vsc2VcXG4gIHBvcy54ICs9IHZlcnRPZmZzZXQueDtcXG4gIHBvcy55ICs9IHZlcnRPZmZzZXQueTtcXG4jZW5kaWZcXG59XFxudmVjMiBjb21wdXRlVVYgKGZsb2F0IGZyYW1lSW5kZXgsIHZlYzIgdmVydEluZGV4LCB2ZWMyIGZyYW1lVGlsZSl7XFxuICB2ZWMyIGFuaVVWID0gdmVjMigwLCBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnkpKTtcXG4gIGFuaVVWLnggPSBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnggKiBmcmFtZVRpbGUueSAtIGFuaVVWLnkgKiBmcmFtZVRpbGUueCk7XFxuI2lmIENDX1JFTkRFUl9NT0RFICE9IDRcXG4gIHZlcnRJbmRleC55ID0gMS4gLSB2ZXJ0SW5kZXgueTtcXG4jZW5kaWZcXG4gIHJldHVybiAoYW5pVVYueHkgKyB2ZXJ0SW5kZXgpIC8gdmVjMihmcmFtZVRpbGUueCwgZnJhbWVUaWxlLnkpO1xcbn1cXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDEpIHVuaWZvcm0gU2FtcGxlQ29uc3RhbnRzIHtcXG4gIHZlYzQgdV9zYW1wbGVJbmZvO1xcbn07XFxubGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSAyKSB1bmlmb3JtIFRpY2tDb25zdGFudHMge1xcbiAgdmVjNCB1X3dvcmxkUm90O1xcbiAgdmVjNCB1X3RpbWVEZWx0YTtcXG59O1xcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzQgYV9wb3NpdGlvbl9zdGFydHRpbWU7XFxubGF5b3V0KGxvY2F0aW9uID0gMSkgaW4gdmVjNCBhX3NpemVfdXY7XFxubGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjNCBhX3JvdGF0aW9uX3V2O1xcbmxheW91dChsb2NhdGlvbiA9IDMpIGluIHZlYzQgYV9jb2xvcjtcXG5sYXlvdXQobG9jYXRpb24gPSA0KSBpbiB2ZWM0IGFfZGlyX2xpZmU7XFxubGF5b3V0KGxvY2F0aW9uID0gNSkgaW4gZmxvYXQgYV9ybmRTZWVkO1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSA0XFxuICBsYXlvdXQobG9jYXRpb24gPSA2KSBpbiB2ZWMzIGFfdGV4Q29vcmQ7XFxuICBsYXlvdXQobG9jYXRpb24gPSA3KSBpbiB2ZWMzIGFfdGV4Q29vcmQzO1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gOCkgaW4gdmVjMyBhX25vcm1hbDtcXG4gIGxheW91dChsb2NhdGlvbiA9IDkpIGluIHZlYzQgYV9jb2xvcjE7XFxuI2VuZGlmXFxudmVjMyB1bnBhY2tDdXJ2ZURhdGEgKHNhbXBsZXIyRCB0ZXgsIHZlYzIgY29vcmQpIHtcXG4gICAgdmVjNCBhID0gdGV4dHVyZSh0ZXgsIGNvb3JkKTtcXG4gICAgdmVjNCBiID0gdGV4dHVyZSh0ZXgsIGNvb3JkICsgdV9zYW1wbGVJbmZvLnkpO1xcbiAgICBmbG9hdCBjID0gZnJhY3QoY29vcmQueCAqIHVfc2FtcGxlSW5mby54KTtcXG4gICAgcmV0dXJuIG1peChhLnh5eiwgYi54eXosIGMpO1xcbn1cXG52ZWMzIHVucGFja0N1cnZlRGF0YSAoc2FtcGxlcjJEIHRleCwgdmVjMiBjb29yZCwgb3V0IGZsb2F0IHcpIHtcXG4gICAgdmVjNCBhID0gdGV4dHVyZSh0ZXgsIGNvb3JkKTtcXG4gICAgdmVjNCBiID0gdGV4dHVyZSh0ZXgsIGNvb3JkICsgdV9zYW1wbGVJbmZvLnkpO1xcbiAgICBmbG9hdCBjID0gZnJhY3QoY29vcmQueCAqIHVfc2FtcGxlSW5mby54KTtcXG4gICAgdyA9IG1peChhLncsIGIudywgYyk7XFxuICAgIHJldHVybiBtaXgoYS54eXosIGIueHl6LCBjKTtcXG59XFxuZmxvYXQgcHNldWRvUmFuZG9tIChmbG9hdCBzZWVkKSB7XFxuICBzZWVkID0gbW9kKHNlZWQsIDIzMzI4MC4pO1xcbiAgZmxvYXQgcSA9IChzZWVkICogOTMwMS4gKyA0OTI5Ny4pIC8gMjMzMjgwLjtcXG4gIHJldHVybiBmcmFjdChxKTtcXG59XFxuI2lmIENPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDEwKSB1bmlmb3JtIHNhbXBsZXIyRCBjb2xvcl9vdmVyX3RpbWVfdGV4MDtcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMykgdW5pZm9ybSBDb2xvckNvbnN0YW50IHtcXG4gICAgaW50IHVfY29sb3JfbW9kZTtcXG4gIH07XFxuI2VuZGlmXFxuI2lmIFJPVEFUSU9OX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDExKSB1bmlmb3JtIHNhbXBsZXIyRCByb3RhdGlvbl9vdmVyX3RpbWVfdGV4MDtcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gNCkgdW5pZm9ybSBSb3RhdGlvbkNvbnN0YW50IHtcXG4gICAgaW50IHVfcm90YXRpb25fbW9kZTtcXG4gIH07XFxuI2VuZGlmXFxuI2lmIFNJWkVfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMTIpIHVuaWZvcm0gc2FtcGxlcjJEIHNpemVfb3Zlcl90aW1lX3RleDA7XFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDUpIHVuaWZvcm0gU2l6ZUNvbnN0YW50IHtcXG4gICAgaW50IHVfc2l6ZV9tb2RlO1xcbiAgfTtcXG4jZW5kaWZcXG4jaWYgRk9SQ0VfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMTMpIHVuaWZvcm0gc2FtcGxlcjJEIGZvcmNlX292ZXJfdGltZV90ZXgwO1xcbiAgbGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSA2KSB1bmlmb3JtIEZvcmNlQ29uc3RhbnQge1xcbiAgICBpbnQgdV9mb3JjZV9tb2RlO1xcbiAgICBpbnQgdV9mb3JjZV9zcGFjZTtcXG4gIH07XFxuI2VuZGlmXFxuI2lmIFZFTE9DSVRZX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDE0KSB1bmlmb3JtIHNhbXBsZXIyRCB2ZWxvY2l0eV9vdmVyX3RpbWVfdGV4MDtcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gNykgdW5pZm9ybSBWZWxvY2l0eUNvbnN0YW50IHtcXG4gICAgaW50IHVfdmVsb2NpdHlfbW9kZTtcXG4gICAgaW50IHVfdmVsb2NpdHlfc3BhY2U7XFxuICB9O1xcbiNlbmRpZlxcbiNpZiBURVhUVVJFX0FOSU1BVElPTl9NT0RVTEVfRU5BQkxFXFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDE1KSB1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlX2FuaW1hdGlvbl90ZXgwO1xcbiAgbGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSA4KSB1bmlmb3JtIEFuaW1hdGlvbkNvbnN0YW50IHtcXG4gICAgdmVjNCB1X2FuaW1faW5mbztcXG4gIH07XFxuI2VuZGlmXFxuZmxvYXQgcmVwZWF0IChmbG9hdCB0LCBmbG9hdCBsZW5ndGgpIHtcXG4gIHJldHVybiB0IC0gZmxvb3IodCAvIGxlbmd0aCkgKiBsZW5ndGg7XFxufVxcbnZlYzQgcm90YXRlUXVhdCAodmVjNCBwLCB2ZWM0IHEpIHtcXG4gIHZlYzMgaXYgPSBjcm9zcyhxLnh5eiwgcC54eXopICsgcS53ICogcC54eXo7XFxuICB2ZWMzIHJlcyA9IHAueHl6ICsgMi4wICogY3Jvc3MocS54eXosIGl2KTtcXG4gIHJldHVybiB2ZWM0KHJlcy54eXosIHAudyk7XFxufVxcbnZlYzQgZ3B2c19tYWluICgpIHtcXG4gIGZsb2F0IGFjdGl2ZVRpbWUgPSB1X3RpbWVEZWx0YS54IC0gYV9wb3NpdGlvbl9zdGFydHRpbWUudztcXG4gIGZsb2F0IG5vcm1hbGl6ZWRUaW1lID0gY2xhbXAoYWN0aXZlVGltZSAvIGFfZGlyX2xpZmUudywgMC4wLCAxLjApO1xcbiAgdmVjMiB0aW1lQ29vcmQwID0gdmVjMihub3JtYWxpemVkVGltZSwgMC4pO1xcbiAgdmVjMiB0aW1lQ29vcmQxID0gdmVjMihub3JtYWxpemVkVGltZSwgMS4pO1xcbiAgI2lmIENDX1JFTkRFUl9NT0RFID09IDRcXG4gICAgdmVjMiB2ZXJ0SWR4ID0gdmVjMihhX3RleENvb3JkLngsIGFfdGV4Q29vcmQueSk7XFxuICAjZWxzZVxcbiAgICB2ZWMyIHZlcnRJZHggPSB2ZWMyKGFfc2l6ZV91di53LCBhX3JvdGF0aW9uX3V2LncpO1xcbiAgI2VuZGlmXFxuICB2ZWM0IHZlbG9jaXR5ID0gdmVjNChhX2Rpcl9saWZlLnh5eiwgMC4pO1xcbiAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb25fc3RhcnR0aW1lLnh5eiwgMS4pO1xcbiAgdmVjMyBzaXplID0gYV9zaXplX3V2Lnh5ejtcXG4gICNpZiBTSVpFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICAgIGlmICh1X3NpemVfbW9kZSA9PSAxKSB7XFxuICAgICAgc2l6ZSAqPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyBzaXplXzAgPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyBzaXplXzEgPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX3MgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgMzk4MjUuKTtcXG4gICAgICBzaXplICo9IG1peChzaXplXzAsIHNpemVfMSwgZmFjdG9yX3MpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4gIHZlYzMgY29tcFNjYWxlID0gc2NhbGUueHl6ICogc2l6ZTtcXG4gICNpZiBGT1JDRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgICB2ZWMzIGZvcmNlQW5pbSA9IHZlYzMoMC4pO1xcbiAgICBpZiAodV9mb3JjZV9tb2RlID09IDEpIHtcXG4gICAgICBmb3JjZUFuaW0gPSB1bnBhY2tDdXJ2ZURhdGEoZm9yY2Vfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgZm9yY2VfMCA9IHVucGFja0N1cnZlRGF0YShmb3JjZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyBmb3JjZV8xID0gdW5wYWNrQ3VydmVEYXRhKGZvcmNlX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfZiA9ICBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgMjEyMTY1Lik7XFxuICAgICAgZm9yY2VBbmltID0gbWl4KGZvcmNlXzAsIGZvcmNlXzEsIGZhY3Rvcl9mKTtcXG4gICAgfVxcbiAgICB2ZWM0IGZvcmNlVHJhY2sgPSB2ZWM0KGZvcmNlQW5pbSwgMC4pO1xcbiAgICBpZiAodV9mb3JjZV9zcGFjZSA9PSAwKSB7XFxuICAgICAgZm9yY2VUcmFjayA9IHJvdGF0ZVF1YXQoZm9yY2VUcmFjaywgdV93b3JsZFJvdCk7XFxuICAgIH1cXG4gICAgdmVsb2NpdHkueHl6ICs9IGZvcmNlVHJhY2sueHl6O1xcbiAgI2VuZGlmXFxuICAjaWYgVkVMT0NJVFlfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgZmxvYXQgc3BlZWRNb2RpZmllcjAgPSAxLjtcXG4gICAgZmxvYXQgc3BlZWRNb2RpZmllcjEgPSAxLjtcXG4gICAgdmVjMyB2ZWxvY2l0eUFuaW0gPSB2ZWMzKDAuKTtcXG4gICAgaWYgKHVfdmVsb2NpdHlfbW9kZSA9PSAxKSB7XFxuICAgICAgdmVsb2NpdHlBbmltID0gdW5wYWNrQ3VydmVEYXRhKHZlbG9jaXR5X292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwLCBzcGVlZE1vZGlmaWVyMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyB2ZWN0b3J5XzAgPSB1bnBhY2tDdXJ2ZURhdGEodmVsb2NpdHlfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDAsIHNwZWVkTW9kaWZpZXIwKTtcXG4gICAgICB2ZWMzIHZlY3RvcnlfMSA9IHVucGFja0N1cnZlRGF0YSh2ZWxvY2l0eV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMSwgc3BlZWRNb2RpZmllcjEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl92ID0gcHNldWRvUmFuZG9tKGFfcm5kU2VlZCArIDE5Nzg2Ni4pO1xcbiAgICAgIHZlbG9jaXR5QW5pbSA9IG1peCh2ZWN0b3J5XzAsIHZlY3RvcnlfMSwgZmFjdG9yX3YpO1xcbiAgICAgIHNwZWVkTW9kaWZpZXIwID0gbWl4KHNwZWVkTW9kaWZpZXIwLCBzcGVlZE1vZGlmaWVyMSwgZmFjdG9yX3YpO1xcbiAgICB9XFxuICAgIHZlYzQgdmVsb2NpdHlUcmFjayA9IHZlYzQodmVsb2NpdHlBbmltLCAwLik7XFxuICAgIGlmICh1X3ZlbG9jaXR5X3NwYWNlID09IDApIHtcXG4gICAgICB2ZWxvY2l0eVRyYWNrID0gcm90YXRlUXVhdCh2ZWxvY2l0eVRyYWNrLCB1X3dvcmxkUm90KTtcXG4gICAgfVxcbiAgICB2ZWxvY2l0eS54eXogKz0gdmVsb2NpdHlUcmFjay54eXo7XFxuICAgIHZlbG9jaXR5Lnh5eiAqPSBzcGVlZE1vZGlmaWVyMDtcXG4gICNlbmRpZlxcbiAgcG9zLnh5eiArPSB2ZWxvY2l0eS54eXogKiBub3JtYWxpemVkVGltZSAqIGFfZGlyX2xpZmUudztcXG4gICNpZiAhQ0NfVVNFX1dPUkxEX1NQQUNFXFxuICAgIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICAgIHZlbG9jaXR5ID0gcm90YXRlUXVhdCh2ZWxvY2l0eSwgdV93b3JsZFJvdCk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICB2ZWMzIHJvdGF0aW9uID0gYV9yb3RhdGlvbl91di54eXo7XFxuICAjaWYgUk9UQVRJT05fT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgaWYgKHVfcm90YXRpb25fbW9kZSA9PSAxKSB7XFxuICAgICAgcm90YXRpb24gKz0gdW5wYWNrQ3VydmVEYXRhKHJvdGF0aW9uX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKSAqIG5vcm1hbGl6ZWRUaW1lICogYV9kaXJfbGlmZS53O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgcm90YXRpb25fMCA9IHVucGFja0N1cnZlRGF0YShyb3RhdGlvbl9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyByb3RhdGlvbl8xID0gdW5wYWNrQ3VydmVEYXRhKHJvdGF0aW9uX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfciA9IHBzZXVkb1JhbmRvbShhX3JuZFNlZWQgKyAxMjUyOTIuKTtcXG4gICAgICByb3RhdGlvbiArPSBtaXgocm90YXRpb25fMCwgcm90YXRpb25fMSwgZmFjdG9yX3IpICogbm9ybWFsaXplZFRpbWUgKiBhX2Rpcl9saWZlLnc7XFxuICAgIH1cXG4gICNlbmRpZlxcbiAgI2lmIENPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICAgIGlmICh1X2NvbG9yX21vZGUgPT0gMSkge1xcbiAgICAgIGNvbG9yID0gYV9jb2xvciAqIHRleHR1cmUoY29sb3Jfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzQgY29sb3JfMCA9IHRleHR1cmUoY29sb3Jfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICAgIHZlYzQgY29sb3JfMSA9IHRleHR1cmUoY29sb3Jfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl9jID0gcHNldWRvUmFuZG9tKGFfcm5kU2VlZCArIDkxMDQxLik7XFxuICAgICAgY29sb3IgPSBhX2NvbG9yICogbWl4KGNvbG9yXzAsIGNvbG9yXzEsIGZhY3Rvcl9jKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgICB2ZWMyIGNvcm5lck9mZnNldCA9IHZlYzIoKHZlcnRJZHggLSAwLjUpKTtcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gcm90YXRpb24ueHl6O1xcbiAgICAjZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgdmVjMyByb3RFdWxlciA9IHZlYzMoMC4pO1xcbiAgICAjZWxzZVxcbiAgICAgIHZlYzMgcm90RXVsZXIgPSB2ZWMzKDAuLCAwLiwgcm90YXRpb24ueik7XFxuICAgICNlbmRpZlxcbiAgICBjb21wdXRlVmVydFBvcyhwb3MsIGNvcm5lck9mZnNldCwgcXVhdGVybmlvbkZyb21FdWxlcihyb3RFdWxlciksIGNvbXBTY2FsZVxcbiAgICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICAgICAgICwgY2NfbWF0Vmlld0ludlxcbiAgICAgICNlbmRpZlxcbiAgICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgICAsIGNjX2NhbWVyYVBvcy54eXpcXG4gICAgICAgICwgdmVsb2NpdHlcXG4gICAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLnpcXG4gICAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLndcXG4gICAgICAgICwgYV9zaXplX3V2LndcXG4gICAgICAjZW5kaWZcXG4gICAgKTtcXG4gICNlbHNlXFxuICAgIG1hdDQgeGZvcm1Ob1NjYWxlID0gbWF0cml4RnJvbVJUKHF1YXRlcm5pb25Gcm9tRXVsZXIocm90YXRpb24pLCBwb3MueHl6KTtcXG4gICAgbWF0NCB4Zm9ybSA9IG1hdEZyb21SVFMocXVhdGVybmlvbkZyb21FdWxlcihyb3RhdGlvbiksIHBvcy54eXosIGNvbXBTY2FsZSk7XFxuICAgIHBvcyA9IHhmb3JtICogdmVjNChhX3RleENvb3JkMywgMSk7XFxuICAgIHZlYzQgbm9ybWFsID0geGZvcm1Ob1NjYWxlICogdmVjNChhX25vcm1hbCwgMCk7XFxuICAgIGNvbG9yICo9IGFfY29sb3IxO1xcbiAgI2VuZGlmXFxuICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gIGZsb2F0IGZyYW1lSW5kZXggPSAwLjtcXG4gICNpZiBURVhUVVJFX0FOSU1BVElPTl9NT0RVTEVfRU5BQkxFXFxuICAgIGZsb2F0IHN0YXJ0RnJhbWUgPSAwLjtcXG4gICAgdmVjMyBmcmFtZUluZm8gPSB2ZWMzKDAuKTtcXG4gICAgaWYgKGludCh1X2FuaW1faW5mby54KSA9PSAxKSB7XFxuICAgICAgZnJhbWVJbmZvID0gdW5wYWNrQ3VydmVEYXRhKHRleHR1cmVfYW5pbWF0aW9uX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgZnJhbWVJbmZvMCA9IHVucGFja0N1cnZlRGF0YSh0ZXh0dXJlX2FuaW1hdGlvbl90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgICB2ZWMzIGZyYW1lSW5mbzEgPSB1bnBhY2tDdXJ2ZURhdGEodGV4dHVyZV9hbmltYXRpb25fdGV4MCwgdGltZUNvb3JkMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX3QgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgOTA3OTQuKTtcXG4gICAgICBmcmFtZUluZm8gPSBtaXgoZnJhbWVJbmZvMCwgZnJhbWVJbmZvMSwgZmFjdG9yX3QpO1xcbiAgICB9XFxuICAgIHN0YXJ0RnJhbWUgPSBmcmFtZUluZm8ueCAvIHVfYW5pbV9pbmZvLnk7XFxuICAgIGZyYW1lSW5kZXggPSByZXBlYXQodV9hbmltX2luZm8ueiAqIChmcmFtZUluZm8ueSArIHN0YXJ0RnJhbWUpLCAxLik7XFxuICAjZW5kaWZcXG4gIHV2ID0gY29tcHV0ZVVWKGZyYW1lSW5kZXgsIHZlcnRJZHgsIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS54eSkgKiBtYWluVGlsaW5nX09mZnNldC54eSArIG1haW5UaWxpbmdfT2Zmc2V0Lnp3O1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IGdwdnNfbWFpbigpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHNldCA9IDAsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzIgdXY7XFxubGF5b3V0KGxvY2F0aW9uID0gMSkgaW4gdmVjNCBjb2xvcjtcXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDE2KSB1bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDkpIHVuaWZvcm0gRnJhZ0NvbnN0YW50cyB7XFxuICB2ZWM0IHRpbnRDb2xvcjtcXG59O1xcbnZlYzQgYWRkICgpIHtcXG4gIHZlYzQgY29sID0gMi4wICogY29sb3IgKiB0aW50Q29sb3IgKiB0ZXh0dXJlKG1haW5UZXh0dXJlLCB1dik7XFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNvbCk7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGFkZCgpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NMb2NhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZpbmVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfUkVOREVSX01PREVcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzAsIDRdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJST1RBVElPTl9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiU0laRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiRk9SQ0VfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlZFTE9DSVRZX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJURVhUVVJFX0FOSU1BVElPTl9NT0RVTEVfRU5BQkxFXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfV09STERfU1BBQ0VcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMCwgXCJzdGFnZUZsYWdzXCI6IDEsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwibWFpblRpbGluZ19PZmZzZXRcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJmcmFtZVRpbGVfdmVsTGVuU2NhbGVcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJzY2FsZVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJTYW1wbGVDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwidV9zYW1wbGVJbmZvXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcIlRpY2tDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMiwgXCJzdGFnZUZsYWdzXCI6IDEsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwidV93b3JsZFJvdFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInVfdGltZURlbHRhXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkNvbG9yQ29uc3RhbnRcIiwgXCJkZWZpbmVzXCI6IFtcIkNPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCJdLCBcImJpbmRpbmdcIjogMywgXCJzdGFnZUZsYWdzXCI6IDEsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwidV9jb2xvcl9tb2RlXCIsIFwidHlwZVwiOiA1LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX0sXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiUm90YXRpb25Db25zdGFudFwiLCBcImRlZmluZXNcIjogW1wiUk9UQVRJT05fT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcIl0sIFwiYmluZGluZ1wiOiA0LCBcInN0YWdlRmxhZ3NcIjogMSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ1X3JvdGF0aW9uX21vZGVcIiwgXCJ0eXBlXCI6IDUsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJTaXplQ29uc3RhbnRcIiwgXCJkZWZpbmVzXCI6IFtcIlNJWkVfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcIl0sIFwiYmluZGluZ1wiOiA1LCBcInN0YWdlRmxhZ3NcIjogMSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ1X3NpemVfbW9kZVwiLCBcInR5cGVcIjogNSwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkZvcmNlQ29uc3RhbnRcIiwgXCJkZWZpbmVzXCI6IFtcIkZPUkNFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCJdLCBcImJpbmRpbmdcIjogNiwgXCJzdGFnZUZsYWdzXCI6IDEsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwidV9mb3JjZV9tb2RlXCIsIFwidHlwZVwiOiA1LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ1X2ZvcmNlX3NwYWNlXCIsIFwidHlwZVwiOiA1LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX0sXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiVmVsb2NpdHlDb25zdGFudFwiLCBcImRlZmluZXNcIjogW1wiVkVMT0NJVFlfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcIl0sIFwiYmluZGluZ1wiOiA3LCBcInN0YWdlRmxhZ3NcIjogMSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ1X3ZlbG9jaXR5X21vZGVcIiwgXCJ0eXBlXCI6IDUsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInVfdmVsb2NpdHlfc3BhY2VcIiwgXCJ0eXBlXCI6IDUsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJBbmltYXRpb25Db25zdGFudFwiLCBcImRlZmluZXNcIjogW1wiVEVYVFVSRV9BTklNQVRJT05fTU9EVUxFX0VOQUJMRVwiXSwgXCJiaW5kaW5nXCI6IDgsIFwic3RhZ2VGbGFnc1wiOiAxLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInVfYW5pbV9pbmZvXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkZyYWdDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogOSwgXCJzdGFnZUZsYWdzXCI6IDE2LCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInRpbnRDb2xvclwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJzYW1wbGVyc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImNvbG9yX292ZXJfdGltZV90ZXgwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ09MT1JfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImJpbmRpbmdcIjogMTAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwicm90YXRpb25fb3Zlcl90aW1lX3RleDBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJST1RBVElPTl9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiYmluZGluZ1wiOiAxMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJzaXplX292ZXJfdGltZV90ZXgwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiU0laRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiYmluZGluZ1wiOiAxMiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJmb3JjZV9vdmVyX3RpbWVfdGV4MFwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkZPUkNFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJiaW5kaW5nXCI6IDEzIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlbG9jaXR5X292ZXJfdGltZV90ZXgwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVkVMT0NJVFlfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImJpbmRpbmdcIjogMTQgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwidGV4dHVyZV9hbmltYXRpb25fdGV4MFwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlRFWFRVUkVfQU5JTUFUSU9OX01PRFVMRV9FTkFCTEVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImJpbmRpbmdcIjogMTUgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwibWFpblRleHR1cmVcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDE2LCBcImJpbmRpbmdcIjogMTYgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvbl9zdGFydHRpbWVcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQ0LCBcImxvY2F0aW9uXCI6IDAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9zaXplX3V2XCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJsb2NhdGlvblwiOiAxIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcm90YXRpb25fdXZcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQ0LCBcImxvY2F0aW9uXCI6IDIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9jb2xvclwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2Rpcl9saWZlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJsb2NhdGlvblwiOiA0IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcm5kU2VlZFwiLCBcInR5cGVcIjogMTMsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMTEsIFwibG9jYXRpb25cIjogNSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfUkVOREVSX01PREVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiA2IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmQzXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfUkVOREVSX01PREVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiA3IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbm9ybWFsXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfUkVOREVSX01PREVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiA4IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfY29sb3IxXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfUkVOREVSX01PREVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJsb2NhdGlvblwiOiA5IH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tcGFydGljbGUtdHJhaWxcIixcclxuICAgIFwiX3V1aWRcIjogXCIxN2RlYmNjMy0wYTZiLTRiOGEtYjAwYi1kYzU4Yjg4NTU4MWVcIixcclxuICAgIFwidGVjaG5pcXVlc1wiOiBbXHJcbiAgICAgIHsgXCJuYW1lXCI6IFwiYWRkXCIsIFwicGFzc2VzXCI6IFt7IFwicmFzdGVyaXplclN0YXRlXCI6IHsgXCJjdWxsTW9kZVwiOiAwIH0sIFwiYmxlbmRTdGF0ZVwiOiB7IFwidGFyZ2V0c1wiOiBbeyBcImJsZW5kXCI6IHRydWUsIFwiYmxlbmRTcmNcIjogMiwgXCJibGVuZERzdFwiOiAxLCBcImJsZW5kU3JjQWxwaGFcIjogMiwgXCJibGVuZERzdEFscGhhXCI6IDEgfV0gfSwgXCJwcm9ncmFtXCI6IFwiYnVpbHRpbi1wYXJ0aWNsZS10cmFpbHxwYXJ0aWNsZS10cmFpbDp2c19tYWlufHRpbnRlZC1mczphZGRcIiwgXCJkZXB0aFN0ZW5jaWxTdGF0ZVwiOiB7IFwiZGVwdGhUZXN0XCI6IHRydWUsIFwiZGVwdGhXcml0ZVwiOiBmYWxzZSB9LCBcInByb3BlcnRpZXNcIjogeyBcIm1haW5UZXh0dXJlXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0sIFwibWFpblRpbGluZ19PZmZzZXRcIjogeyBcInZhbHVlXCI6IFsxLCAxLCAwLCAwXSwgXCJ0eXBlXCI6IDE2IH0sIFwiZnJhbWVUaWxlX3ZlbExlblNjYWxlXCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMCwgMF0sIFwidHlwZVwiOiAxNiB9LCBcInRpbnRDb2xvclwiOiB7IFwidmFsdWVcIjogWzAuNSwgMC41LCAwLjUsIDAuNV0sIFwidHlwZVwiOiAxNiB9IH0gfV0gfVxyXG4gICAgXSxcclxuICAgIFwic2hhZGVyc1wiOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBcIm5hbWVcIjogXCJidWlsdGluLXBhcnRpY2xlLXRyYWlsfHBhcnRpY2xlLXRyYWlsOnZzX21haW58dGludGVkLWZzOmFkZFwiLFxyXG4gICAgICAgIFwiaGFzaFwiOiA0MTE1MTU1NzcyLFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENvbnN0YW50cyB7XFxuICB2ZWM0IG1haW5UaWxpbmdfT2Zmc2V0O1xcbiAgdmVjNCBmcmFtZVRpbGVfdmVsTGVuU2NhbGU7XFxuICB2ZWM0IHNjYWxlO1xcbn07XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbm91dCBtZWRpdW1wIHZlYzIgdXY7XFxub3V0IG1lZGl1bXAgdmVjNCBjb2xvcjtcXG5pbiB2ZWMzIGFfcG9zaXRpb247XFxuaW4gdmVjNCBhX3RleENvb3JkO1xcbmluIHZlYzMgYV90ZXhDb29yZDE7XFxuaW4gdmVjMyBhX3RleENvb3JkMjtcXG5pbiB2ZWM0IGFfY29sb3I7XFxuI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgb3V0IHZlYzMgdkJhcnljZW50cmljO1xcbiNlbmRpZlxcbnZlYzQgdnNfbWFpbigpIHtcXG4gIGhpZ2hwIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAxKTtcXG4gIHZlYzQgdmVsb2NpdHkgPSB2ZWM0KGFfdGV4Q29vcmQxLnh5eiwgMCk7XFxuICAjaWYgIUNDX1VTRV9XT1JMRF9TUEFDRVxcbiAgICBwb3MgPSBjY19tYXRXb3JsZCAqIHBvcztcXG4gICAgdmVsb2NpdHkgPSBjY19tYXRXb3JsZCAqIHZlbG9jaXR5O1xcbiAgI2VuZGlmXFxuICBmbG9hdCB2ZXJ0T2Zmc2V0ID0gKGFfdGV4Q29vcmQueCAtIDAuNSkgKiBhX3RleENvb3JkLnk7XFxuICB2ZWMzIGNhbVVwID0gbm9ybWFsaXplKGNyb3NzKHBvcy54eXogLSBjY19jYW1lcmFQb3MueHl6LCB2ZWxvY2l0eS54eXopKTtcXG4gIHBvcy54eXogKz0gY2FtVXAgKiB2ZXJ0T2Zmc2V0O1xcbiAgcG9zID0gY2NfbWF0Vmlld1Byb2ogKiBwb3M7XFxuICB1diA9IGFfdGV4Q29vcmQuencgKiBtYWluVGlsaW5nX09mZnNldC54eSArIG1haW5UaWxpbmdfT2Zmc2V0Lnp3OztcXG4gIGNvbG9yID0gYV9jb2xvcjtcXG4gICNpZiBDQ19EUkFXX1dJUkVfRlJBTUVcXG4gICAgdkJhcnljZW50cmljID0gYV90ZXhDb29yZDI7XFxuICAjZW5kaWZcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2c19tYWluKCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxuICBpbiB2ZWMyIHV2O1xcbiAgaW4gdmVjNCBjb2xvcjtcXG4gICNpZiBDQ19EUkFXX1dJUkVfRlJBTUVcXG4gICAgaW4gdmVjMyB2QmFyeWNlbnRyaWM7XFxuICAjZW5kaWZcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBGcmFnQ29uc3RhbnRzIHtcXG4gICAgdmVjNCB0aW50Q29sb3I7XFxuICB9O1xcbiAgdmVjNCBhZGQgKCkge1xcbiAgICB2ZWM0IGNvbCA9IDIuMCAqIGNvbG9yICogdGludENvbG9yICogdGV4dHVyZShtYWluVGV4dHVyZSwgdXYpO1xcbiNpZiBDQ19EUkFXX1dJUkVfRlJBTUVcXG4gICAgaWYgKGFueShsZXNzVGhhbih2QmFyeWNlbnRyaWMsIHZlYzMoMC4wMikpKSkge1xcbiAgICAgICAgY29sID0gdmVjNCgwLiwgMS4sIDEuLCAxLik7XFxuICAgIH1cXG4jZW5kaWZcXG4gICAgcmV0dXJuIENDRnJhZ091dHB1dChjb2wpO1xcbiAgfVxcbm91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGFkZCgpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsMVwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCBtYWluVGlsaW5nX09mZnNldDtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxudW5pZm9ybSBoaWdocCB2ZWM0IGNjX2NhbWVyYVBvcztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdXY7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgY29sb3I7XFxuYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjNCBhX3RleENvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfdGV4Q29vcmQxO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfdGV4Q29vcmQyO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgdmFyeWluZyB2ZWMzIHZCYXJ5Y2VudHJpYztcXG4jZW5kaWZcXG52ZWM0IHZzX21haW4oKSB7XFxuICBoaWdocCB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbiwgMSk7XFxuICB2ZWM0IHZlbG9jaXR5ID0gdmVjNChhX3RleENvb3JkMS54eXosIDApO1xcbiAgI2lmICFDQ19VU0VfV09STERfU1BBQ0VcXG4gICAgcG9zID0gY2NfbWF0V29ybGQgKiBwb3M7XFxuICAgIHZlbG9jaXR5ID0gY2NfbWF0V29ybGQgKiB2ZWxvY2l0eTtcXG4gICNlbmRpZlxcbiAgZmxvYXQgdmVydE9mZnNldCA9IChhX3RleENvb3JkLnggLSAwLjUpICogYV90ZXhDb29yZC55O1xcbiAgdmVjMyBjYW1VcCA9IG5vcm1hbGl6ZShjcm9zcyhwb3MueHl6IC0gY2NfY2FtZXJhUG9zLnh5eiwgdmVsb2NpdHkueHl6KSk7XFxuICBwb3MueHl6ICs9IGNhbVVwICogdmVydE9mZnNldDtcXG4gIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgdXYgPSBhX3RleENvb3JkLnp3ICogbWFpblRpbGluZ19PZmZzZXQueHkgKyBtYWluVGlsaW5nX09mZnNldC56dzs7XFxuICBjb2xvciA9IGFfY29sb3I7XFxuICAjaWYgQ0NfRFJBV19XSVJFX0ZSQU1FXFxuICAgIHZCYXJ5Y2VudHJpYyA9IGFfdGV4Q29vcmQyO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdnNfbWFpbigpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxuICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbiAgdmFyeWluZyB2ZWMyIHV2O1xcbiAgdmFyeWluZyB2ZWM0IGNvbG9yO1xcbiAgI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgICB2YXJ5aW5nIHZlYzMgdkJhcnljZW50cmljO1xcbiAgI2VuZGlmXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG4gIHVuaWZvcm0gdmVjNCB0aW50Q29sb3I7XFxuICB2ZWM0IGFkZCAoKSB7XFxuICAgIHZlYzQgY29sID0gMi4wICogY29sb3IgKiB0aW50Q29sb3IgKiB0ZXh0dXJlMkQobWFpblRleHR1cmUsIHV2KTtcXG4jaWYgQ0NfRFJBV19XSVJFX0ZSQU1FXFxuICAgIGlmIChhbnkobGVzc1RoYW4odkJhcnljZW50cmljLCB2ZWMzKDAuMDIpKSkpIHtcXG4gICAgICAgIGNvbCA9IHZlYzQoMC4sIDEuLCAxLiwgMS4pO1xcbiAgICB9XFxuI2VuZGlmXFxuICAgIHJldHVybiBDQ0ZyYWdPdXRwdXQoY29sKTtcXG4gIH1cXG52b2lkIG1haW4oKSB7IGdsX0ZyYWdDb2xvciA9IGFkZCgpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsNFwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDb25zdGFudHMge1xcbiAgdmVjNCBtYWluVGlsaW5nX09mZnNldDtcXG4gIHZlYzQgZnJhbWVUaWxlX3ZlbExlblNjYWxlO1xcbiAgdmVjNCBzY2FsZTtcXG59O1xcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxubGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IG1lZGl1bXAgdmVjMiB1djtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBvdXQgbWVkaXVtcCB2ZWM0IGNvbG9yO1xcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzMgYV9wb3NpdGlvbjtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWM0IGFfdGV4Q29vcmQ7XFxubGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjMyBhX3RleENvb3JkMTtcXG5sYXlvdXQobG9jYXRpb24gPSAzKSBpbiB2ZWMzIGFfdGV4Q29vcmQyO1xcbmxheW91dChsb2NhdGlvbiA9IDQpIGluIHZlYzQgYV9jb2xvcjtcXG4jaWYgQ0NfRFJBV19XSVJFX0ZSQU1FXFxuICBsYXlvdXQobG9jYXRpb24gPSAyKSBvdXQgdmVjMyB2QmFyeWNlbnRyaWM7XFxuI2VuZGlmXFxudmVjNCB2c19tYWluKCkge1xcbiAgaGlnaHAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb24sIDEpO1xcbiAgdmVjNCB2ZWxvY2l0eSA9IHZlYzQoYV90ZXhDb29yZDEueHl6LCAwKTtcXG4gICNpZiAhQ0NfVVNFX1dPUkxEX1NQQUNFXFxuICAgIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgICB2ZWxvY2l0eSA9IGNjX21hdFdvcmxkICogdmVsb2NpdHk7XFxuICAjZW5kaWZcXG4gIGZsb2F0IHZlcnRPZmZzZXQgPSAoYV90ZXhDb29yZC54IC0gMC41KSAqIGFfdGV4Q29vcmQueTtcXG4gIHZlYzMgY2FtVXAgPSBub3JtYWxpemUoY3Jvc3MocG9zLnh5eiAtIGNjX2NhbWVyYVBvcy54eXosIHZlbG9jaXR5Lnh5eikpO1xcbiAgcG9zLnh5eiArPSBjYW1VcCAqIHZlcnRPZmZzZXQ7XFxuICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gIHV2ID0gYV90ZXhDb29yZC56dyAqIG1haW5UaWxpbmdfT2Zmc2V0Lnh5ICsgbWFpblRpbGluZ19PZmZzZXQuenc7O1xcbiAgY29sb3IgPSBhX2NvbG9yO1xcbiAgI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgICB2QmFyeWNlbnRyaWMgPSBhX3RleENvb3JkMjtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZzX21haW4oKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHNldCA9IDAsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbiAgbGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMiB1djtcXG4gIGxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzQgY29sb3I7XFxuICAjaWYgQ0NfRFJBV19XSVJFX0ZSQU1FXFxuICAgIGxheW91dChsb2NhdGlvbiA9IDIpIGluIHZlYzMgdkJhcnljZW50cmljO1xcbiAgI2VuZGlmXFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDIpIHVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbiAgbGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSAxKSB1bmlmb3JtIEZyYWdDb25zdGFudHMge1xcbiAgICB2ZWM0IHRpbnRDb2xvcjtcXG4gIH07XFxuICB2ZWM0IGFkZCAoKSB7XFxuICAgIHZlYzQgY29sID0gMi4wICogY29sb3IgKiB0aW50Q29sb3IgKiB0ZXh0dXJlKG1haW5UZXh0dXJlLCB1dik7XFxuI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgICBpZiAoYW55KGxlc3NUaGFuKHZCYXJ5Y2VudHJpYywgdmVjMygwLjAyKSkpKSB7XFxuICAgICAgICBjb2wgPSB2ZWM0KDAuLCAxLiwgMS4sIDEuKTtcXG4gICAgfVxcbiNlbmRpZlxcbiAgICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNvbCk7XFxuICB9XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gYWRkKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJ1aWx0aW5zXCI6IHtcclxuICAgICAgICAgIFwiZ2xvYmFsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDR2xvYmFsXCIsIFwiZGVmaW5lc1wiOiBbXSB9XSwgXCJzYW1wbGVyc1wiOiBbXSB9LFxyXG4gICAgICAgICAgXCJsb2NhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0xvY2FsXCIsIFwiZGVmaW5lc1wiOiBbXSB9XSwgXCJzYW1wbGVyc1wiOiBbXSB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRlZmluZXNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19SRU5ERVJfTU9ERVwiLCBcInR5cGVcIjogXCJudW1iZXJcIiwgXCJyYW5nZVwiOiBbMCwgNF0gfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfRFJBV19XSVJFX0ZSQU1FXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfV09STERfU1BBQ0VcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMCwgXCJzdGFnZUZsYWdzXCI6IDEsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwibWFpblRpbGluZ19PZmZzZXRcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJmcmFtZVRpbGVfdmVsTGVuU2NhbGVcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJzY2FsZVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJGcmFnQ29uc3RhbnRzXCIsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDEsIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ0aW50Q29sb3JcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGV4dHVyZVwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMTYsIFwiYmluZGluZ1wiOiAyIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcG9zaXRpb25cIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkMVwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkMlwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2NvbG9yXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJsb2NhdGlvblwiOiA0IH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tcGFydGljbGVcIixcclxuICAgIFwiX3V1aWRcIjogXCJkMTM0NjQzNi1hYzk2LTQyNzEtYjg2My0xZjRmZGVhZDk1YjBcIixcclxuICAgIFwidGVjaG5pcXVlc1wiOiBbXHJcbiAgICAgIHsgXCJuYW1lXCI6IFwiYWRkXCIsIFwicGFzc2VzXCI6IFt7IFwicmFzdGVyaXplclN0YXRlXCI6IHsgXCJjdWxsTW9kZVwiOiAwIH0sIFwiYmxlbmRTdGF0ZVwiOiB7IFwidGFyZ2V0c1wiOiBbeyBcImJsZW5kXCI6IHRydWUsIFwiYmxlbmRTcmNcIjogMiwgXCJibGVuZERzdFwiOiAxLCBcImJsZW5kU3JjQWxwaGFcIjogMiwgXCJibGVuZERzdEFscGhhXCI6IDEgfV0gfSwgXCJwcm9ncmFtXCI6IFwiYnVpbHRpbi1wYXJ0aWNsZXxwYXJ0aWNsZS12cy1sZWdhY3k6bHB2c19tYWlufHRpbnRlZC1mczphZGRcIiwgXCJkZXB0aFN0ZW5jaWxTdGF0ZVwiOiB7IFwiZGVwdGhUZXN0XCI6IHRydWUsIFwiZGVwdGhXcml0ZVwiOiBmYWxzZSB9LCBcInByb3BlcnRpZXNcIjogeyBcIm1haW5UZXh0dXJlXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0sIFwibWFpblRpbGluZ19PZmZzZXRcIjogeyBcInZhbHVlXCI6IFsxLCAxLCAwLCAwXSwgXCJ0eXBlXCI6IDE2IH0sIFwidGludENvbG9yXCI6IHsgXCJ2YWx1ZVwiOiBbMC41LCAwLjUsIDAuNSwgMC41XSwgXCJ0eXBlXCI6IDE2IH0gfSB9XSB9XHJcbiAgICBdLFxyXG4gICAgXCJzaGFkZXJzXCI6IFtcclxuICAgICAge1xyXG4gICAgICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tcGFydGljbGV8cGFydGljbGUtdnMtbGVnYWN5OmxwdnNfbWFpbnx0aW50ZWQtZnM6YWRkXCIsXHJcbiAgICAgICAgXCJoYXNoXCI6IDY2NjYyMzE3LFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUF4aXMgKHZlYzMgeEF4aXMsdmVjMyB5QXhpcyx2ZWMzIHpBeGlzKXtcXG4gIG1hdDMgbSA9IG1hdDMoeEF4aXMseUF4aXMsekF4aXMpO1xcbiAgZmxvYXQgdHJhY2UgPSBtWzBdWzBdICsgbVsxXVsxXSArIG1bMl1bMl07XFxuICB2ZWM0IHF1YXQ7XFxuICBpZiAodHJhY2UgPiAwLikge1xcbiAgICBmbG9hdCBzID0gMC41IC8gc3FydCh0cmFjZSArIDEuMCk7XFxuICAgIHF1YXQudyA9IDAuMjUgLyBzO1xcbiAgICBxdWF0LnggPSAobVsyXVsxXSAtIG1bMV1bMl0pICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzBdIC0gbVswXVsxXSkgKiBzO1xcbiAgfSBlbHNlIGlmICgobVswXVswXSA+IG1bMV1bMV0pICYmIChtWzBdWzBdID4gbVsyXVsyXSkpIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVswXVswXSAtIG1bMV1bMV0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAvIHM7XFxuICAgIHF1YXQueCA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC56ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICB9IGVsc2UgaWYgKG1bMV1bMV0gPiBtWzJdWzJdKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMV1bMV0gLSBtWzBdWzBdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzBdWzJdIC0gbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgfSBlbHNlIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsyXVsyXSAtIG1bMF1bMF0gLSBtWzFdWzFdKTtcXG4gICAgcXVhdC53ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gICAgcXVhdC56ID0gMC4yNSAqIHM7XFxuICB9XFxuICBmbG9hdCBsZW4gPSBxdWF0LnggKiBxdWF0LnggKyBxdWF0LnkgKiBxdWF0LnkgKyBxdWF0LnogKiBxdWF0LnogKyBxdWF0LncgKiBxdWF0Lnc7XFxuICBpZiAobGVuID4gMC4pIHtcXG4gICAgbGVuID0gMS4gLyBzcXJ0KGxlbik7XFxuICAgIHF1YXQueCA9IHF1YXQueCAqIGxlbjtcXG4gICAgcXVhdC55ID0gcXVhdC55ICogbGVuO1xcbiAgICBxdWF0LnogPSBxdWF0LnogKiBsZW47XFxuICAgIHF1YXQudyA9IHF1YXQudyAqIGxlbjtcXG4gIH1cXG4gIHJldHVybiBxdWF0O1xcbn1cXG52ZWM0IHF1YXRlcm5pb25Gcm9tRXVsZXIgKHZlYzMgYW5nbGUpe1xcbiAgZmxvYXQgeCA9IGFuZ2xlLnggLyAyLjtcXG4gIGZsb2F0IHkgPSBhbmdsZS55IC8gMi47XFxuICBmbG9hdCB6ID0gYW5nbGUueiAvIDIuO1xcbiAgZmxvYXQgc3ggPSBzaW4oeCk7XFxuICBmbG9hdCBjeCA9IGNvcyh4KTtcXG4gIGZsb2F0IHN5ID0gc2luKHkpO1xcbiAgZmxvYXQgY3kgPSBjb3MoeSk7XFxuICBmbG9hdCBzeiA9IHNpbih6KTtcXG4gIGZsb2F0IGN6ID0gY29zKHopO1xcbiAgdmVjNCBxdWF0ID0gdmVjNCgwKTtcXG4gIHF1YXQueCA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcXG4gIHF1YXQueSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcXG4gIHF1YXQueiA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcXG4gIHF1YXQudyA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG5tYXQ0IG1hdHJpeEZyb21SVCAodmVjNCBxLCB2ZWMzIHApe1xcbiAgZmxvYXQgeDIgPSBxLnggKyBxLng7XFxuICBmbG9hdCB5MiA9IHEueSArIHEueTtcXG4gIGZsb2F0IHoyID0gcS56ICsgcS56O1xcbiAgZmxvYXQgeHggPSBxLnggKiB4MjtcXG4gIGZsb2F0IHh5ID0gcS54ICogeTI7XFxuICBmbG9hdCB4eiA9IHEueCAqIHoyO1xcbiAgZmxvYXQgeXkgPSBxLnkgKiB5MjtcXG4gIGZsb2F0IHl6ID0gcS55ICogejI7XFxuICBmbG9hdCB6eiA9IHEueiAqIHoyO1xcbiAgZmxvYXQgd3ggPSBxLncgKiB4MjtcXG4gIGZsb2F0IHd5ID0gcS53ICogeTI7XFxuICBmbG9hdCB3eiA9IHEudyAqIHoyO1xcbiAgcmV0dXJuIG1hdDQoXFxuICAgIDEuIC0gKHl5ICsgenopLCB4eSArIHd6LCB4eiAtIHd5LCAwLFxcbiAgICB4eSAtIHd6LCAxLiAtICh4eCArIHp6KSwgeXogKyB3eCwgMCxcXG4gICAgeHogKyB3eSwgeXogLSB3eCwgMS4gLSAoeHggKyB5eSksIDAsXFxuICAgIHAueCwgcC55LCBwLnosIDFcXG4gICk7XFxufVxcbm1hdDQgbWF0RnJvbVJUUyAodmVjNCBxLCB2ZWMzIHQsIHZlYzMgcyl7XFxuICBmbG9hdCB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53O1xcbiAgZmxvYXQgeDIgPSB4ICsgeDtcXG4gIGZsb2F0IHkyID0geSArIHk7XFxuICBmbG9hdCB6MiA9IHogKyB6O1xcbiAgZmxvYXQgeHggPSB4ICogeDI7XFxuICBmbG9hdCB4eSA9IHggKiB5MjtcXG4gIGZsb2F0IHh6ID0geCAqIHoyO1xcbiAgZmxvYXQgeXkgPSB5ICogeTI7XFxuICBmbG9hdCB5eiA9IHkgKiB6MjtcXG4gIGZsb2F0IHp6ID0geiAqIHoyO1xcbiAgZmxvYXQgd3ggPSB3ICogeDI7XFxuICBmbG9hdCB3eSA9IHcgKiB5MjtcXG4gIGZsb2F0IHd6ID0gdyAqIHoyO1xcbiAgZmxvYXQgc3ggPSBzLng7XFxuICBmbG9hdCBzeSA9IHMueTtcXG4gIGZsb2F0IHN6ID0gcy56O1xcbiAgcmV0dXJuIG1hdDQoKDEuIC0gKHl5ICsgenopKSAqIHN4LCAoeHkgKyB3eikgKiBzeCwgKHh6IC0gd3kpICogc3gsIDAsXFxuICAgICh4eSAtIHd6KSAqIHN5LCAoMS4gLSAoeHggKyB6eikpICogc3ksICh5eiArIHd4KSAqIHN5LCAwLFxcbiAgICAoeHogKyB3eSkgKiBzeiwgKHl6IC0gd3gpICogc3osICgxLiAtICh4eCArIHl5KSkgKiBzeiwgMCxcXG4gICAgdC54LCB0LnksIHQueiwgMSk7XFxufVxcbnZlYzQgcXVhdE11bHRpcGx5ICh2ZWM0IGEsIHZlYzQgYil7XFxuICB2ZWM0IHF1YXQ7XFxuICBxdWF0LnggPSBhLnggKiBiLncgKyBhLncgKiBiLnggKyBhLnkgKiBiLnogLSBhLnogKiBiLnk7XFxuICBxdWF0LnkgPSBhLnkgKiBiLncgKyBhLncgKiBiLnkgKyBhLnogKiBiLnggLSBhLnggKiBiLno7XFxuICBxdWF0LnogPSBhLnogKiBiLncgKyBhLncgKiBiLnogKyBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxuICBxdWF0LncgPSBhLncgKiBiLncgLSBhLnggKiBiLnggLSBhLnkgKiBiLnkgLSBhLnogKiBiLno7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudm9pZCByb3RhdGVWZWNGcm9tUXVhdCAoaW5vdXQgdmVjMyB2LCB2ZWM0IHEpe1xcbiAgZmxvYXQgaXggPSBxLncgKiB2LnggKyBxLnkgKiB2LnogLSBxLnogKiB2Lnk7XFxuICBmbG9hdCBpeSA9IHEudyAqIHYueSArIHEueiAqIHYueCAtIHEueCAqIHYuejtcXG4gIGZsb2F0IGl6ID0gcS53ICogdi56ICsgcS54ICogdi55IC0gcS55ICogdi54O1xcbiAgZmxvYXQgaXcgPSAtcS54ICogdi54IC0gcS55ICogdi55IC0gcS56ICogdi56O1xcbiAgdi54ID0gaXggKiBxLncgKyBpdyAqIC1xLnggKyBpeSAqIC1xLnogLSBpeiAqIC1xLnk7XFxuICB2LnkgPSBpeSAqIHEudyArIGl3ICogLXEueSArIGl6ICogLXEueCAtIGl4ICogLXEuejtcXG4gIHYueiA9IGl6ICogcS53ICsgaXcgKiAtcS56ICsgaXggKiAtcS55IC0gaXkgKiAtcS54O1xcbn1cXG52ZWMzIHJvdGF0ZUluTG9jYWxTcGFjZSAodmVjMyBwb3MsIHZlYzMgeEF4aXMsIHZlYzMgeUF4aXMsIHZlYzMgekF4aXMsIHZlYzQgcSl7XFxuICB2ZWM0IHZpZXdRdWF0ID0gcXVhdGVybmlvbkZyb21BeGlzKHhBeGlzLCB5QXhpcywgekF4aXMpO1xcbiAgdmVjNCByb3RRdWF0ID0gcXVhdE11bHRpcGx5KHZpZXdRdWF0LCBxKTtcXG4gIHJvdGF0ZVZlY0Zyb21RdWF0KHBvcywgcm90UXVhdCk7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIHJvdGF0ZUNvcm5lciAoaW5vdXQgdmVjMiBjb3JuZXIsIGZsb2F0IGFuZ2xlKXtcXG4gIGZsb2F0IHhPUyA9IGNvcyhhbmdsZSkgKiBjb3JuZXIueCAtIHNpbihhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGZsb2F0IHlPUyA9IHNpbihhbmdsZSkgKiBjb3JuZXIueCArIGNvcyhhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGNvcm5lci54ID0geE9TO1xcbiAgY29ybmVyLnkgPSB5T1M7XFxufVxcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ29uc3RhbnRzIHtcXG4gIHZlYzQgbWFpblRpbGluZ19PZmZzZXQ7XFxuICB2ZWM0IGZyYW1lVGlsZV92ZWxMZW5TY2FsZTtcXG4gIHZlYzQgc2NhbGU7XFxufTtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxub3V0IG1lZGl1bXAgdmVjMiB1djtcXG5vdXQgbWVkaXVtcCB2ZWM0IGNvbG9yO1xcbnZvaWQgY29tcHV0ZVZlcnRQb3MgKGlub3V0IHZlYzQgcG9zLCB2ZWMyIHZlcnRPZmZzZXQsIHZlYzQgcSwgdmVjMyBzXFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDAgfHwgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgLCBtYXQ0IHZpZXdJbnZcXG4jZW5kaWZcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgLCB2ZWMzIGV5ZVxcbiAgLCB2ZWM0IHZlbG9jaXR5XFxuICAsIGZsb2F0IHZlbG9jaXR5U2NhbGVcXG4gICwgZmxvYXQgbGVuZ3RoU2NhbGVcXG4gICwgZmxvYXQgeEluZGV4XFxuI2VuZGlmXFxuKSB7XFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gIHZlYzMgdmlld1NwYWNlVmVydCA9IHZlYzModmVydE9mZnNldC54ICogcy54LCB2ZXJ0T2Zmc2V0LnkgKiBzLnksIDAuKTtcXG4gIHZlYzMgY2FtWCA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMF0sIHZpZXdJbnZbMV1bMF0sIHZpZXdJbnZbMl1bMF0pKTtcXG4gIHZlYzMgY2FtWSA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMV0sIHZpZXdJbnZbMV1bMV0sIHZpZXdJbnZbMl1bMV0pKTtcXG4gIHZlYzMgY2FtWiA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMl0sIHZpZXdJbnZbMV1bMl0sIHZpZXdJbnZbMl1bMl0pKTtcXG4gIHBvcy54eXogKz0gcm90YXRlSW5Mb2NhbFNwYWNlKHZpZXdTcGFjZVZlcnQsIGNhbVgsIGNhbVksIGNhbVosIHEpO1xcbiNlbGlmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gIHZlYzMgY2FtUmlnaHQgPSBub3JtYWxpemUoY3Jvc3MocG9zLnh5eiAtIGV5ZSwgdmVsb2NpdHkueHl6KSkgKiBzLng7XFxuICB2ZWMzIGNhbVVwID0gdmVsb2NpdHkueHl6ICogdmVsb2NpdHlTY2FsZSArIG5vcm1hbGl6ZSh2ZWxvY2l0eS54eXopICogbGVuZ3RoU2NhbGUgKiBzLnk7XFxuICBwb3MueHl6ICs9IChjYW1SaWdodCAqIGFicyh2ZXJ0T2Zmc2V0LngpICogc2lnbih2ZXJ0T2Zmc2V0LnkpKSAtIGNhbVVwICogeEluZGV4O1xcbiNlbGlmIENDX1JFTkRFUl9NT0RFID09IDJcXG4gIHZlYzMgdmlld1NwYWNlVmVydCA9IHZlYzModmVydE9mZnNldC54ICogcy54LCB2ZXJ0T2Zmc2V0LnkgKiBzLnksIDAuKTtcXG4gIHZlYzMgY2FtWCA9IHZlYzMoMSwgMCwgMCk7XFxuICB2ZWMzIGNhbVkgPSB2ZWMzKDAsIDAsIC0xKTtcXG4gIHBvcy54eXogKz0gcm90YXRlSW5Mb2NhbFNwYWNlKHZpZXdTcGFjZVZlcnQsIGNhbVgsIGNhbVksIGNyb3NzKGNhbVgsIGNhbVkpLCBxKTtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAzXFxuICB2ZWMyIHZpZXdTcGFjZVZlcnQgPSB2ZWMyKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55KTtcXG4gIHJvdGF0ZUNvcm5lcih2aWV3U3BhY2VWZXJ0LCBxLnopO1xcbiAgdmVjMyBjYW1YID0gbm9ybWFsaXplKHZlYzMoY2NfbWF0Vmlld1swXVswXSwgY2NfbWF0Vmlld1sxXVswXSwgY2NfbWF0Vmlld1syXVswXSkpO1xcbiAgdmVjMyBjYW1ZID0gdmVjMygwLCAxLCAwKTtcXG4gIHZlYzMgb2Zmc2V0ID0gY2FtWCAqIHZpZXdTcGFjZVZlcnQueCArIGNhbVkgKiB2aWV3U3BhY2VWZXJ0Lnk7XFxuICBwb3MueHl6ICs9IG9mZnNldDtcXG4jZWxzZVxcbiAgcG9zLnggKz0gdmVydE9mZnNldC54O1xcbiAgcG9zLnkgKz0gdmVydE9mZnNldC55O1xcbiNlbmRpZlxcbn1cXG52ZWMyIGNvbXB1dGVVViAoZmxvYXQgZnJhbWVJbmRleCwgdmVjMiB2ZXJ0SW5kZXgsIHZlYzIgZnJhbWVUaWxlKXtcXG4gIHZlYzIgYW5pVVYgPSB2ZWMyKDAsIGZsb29yKGZyYW1lSW5kZXggKiBmcmFtZVRpbGUueSkpO1xcbiAgYW5pVVYueCA9IGZsb29yKGZyYW1lSW5kZXggKiBmcmFtZVRpbGUueCAqIGZyYW1lVGlsZS55IC0gYW5pVVYueSAqIGZyYW1lVGlsZS54KTtcXG4jaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgdmVydEluZGV4LnkgPSAxLiAtIHZlcnRJbmRleC55O1xcbiNlbmRpZlxcbiAgcmV0dXJuIChhbmlVVi54eSArIHZlcnRJbmRleCkgLyB2ZWMyKGZyYW1lVGlsZS54LCBmcmFtZVRpbGUueSk7XFxufVxcbmluIHZlYzMgYV9wb3NpdGlvbjtcXG5pbiB2ZWMzIGFfdGV4Q29vcmQ7XFxuaW4gdmVjMyBhX3RleENvb3JkMTtcXG5pbiB2ZWMzIGFfdGV4Q29vcmQyO1xcbmluIHZlYzQgYV9jb2xvcjtcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgaW4gdmVjMyBhX2NvbG9yMTtcXG4jZW5kaWZcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gNFxcbiAgaW4gdmVjMyBhX3RleENvb3JkMztcXG4gIGluIHZlYzMgYV9ub3JtYWw7XFxuICBpbiB2ZWM0IGFfY29sb3IxO1xcbiNlbmRpZlxcbnZlYzQgbHB2c19tYWluICgpIHtcXG4gIHZlYzMgY29tcFNjYWxlID0gc2NhbGUueHl6ICogYV90ZXhDb29yZDE7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbiwgMSk7XFxuICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICB2ZWM0IHZlbG9jaXR5ID0gdmVjNChhX2NvbG9yMS54eXosIDApO1xcbiAgI2VuZGlmXFxuICAjaWYgIUNDX1VTRV9XT1JMRF9TUEFDRVxcbiAgICBwb3MgPSBjY19tYXRXb3JsZCAqIHBvcztcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgICB2ZWxvY2l0eSA9IGNjX21hdFdvcmxkICogdmVsb2NpdHk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICAjaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgICB2ZWMyIGNvcm5lck9mZnNldCA9IHZlYzIoKGFfdGV4Q29vcmQueHkgLSAwLjUpKTtcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gYV90ZXhDb29yZDI7XFxuICAgICNlbGlmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gdmVjMygwLik7XFxuICAgICNlbHNlXFxuICAgICAgdmVjMyByb3RFdWxlciA9IHZlYzMoMC4sIDAuLCBhX3RleENvb3JkMi56KTtcXG4gICAgI2VuZGlmXFxuICAgIGNvbXB1dGVWZXJ0UG9zKHBvcywgY29ybmVyT2Zmc2V0LCBxdWF0ZXJuaW9uRnJvbUV1bGVyKHJvdEV1bGVyKSwgY29tcFNjYWxlXFxuICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICAgICAsIGNjX21hdFZpZXdJbnZcXG4gICAgI2VuZGlmXFxuICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgLCBjY19jYW1lcmFQb3MueHl6XFxuICAgICAgLCB2ZWxvY2l0eVxcbiAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLnpcXG4gICAgICAsIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS53XFxuICAgICAgLCBhX3RleENvb3JkLnhcXG4gICAgI2VuZGlmXFxuICAgICk7XFxuICAgIGNvbG9yID0gYV9jb2xvcjtcXG4gICNlbHNlXFxuICAgIG1hdDQgeGZvcm1Ob1NjYWxlID0gbWF0cml4RnJvbVJUKHF1YXRlcm5pb25Gcm9tRXVsZXIoYV90ZXhDb29yZDIpLCBwb3MueHl6KTtcXG4gICAgbWF0NCB4Zm9ybSA9IG1hdEZyb21SVFMocXVhdGVybmlvbkZyb21FdWxlcihhX3RleENvb3JkMiksIHBvcy54eXosIGNvbXBTY2FsZSk7XFxuICAgIHBvcyA9IHhmb3JtICogdmVjNChhX3RleENvb3JkMywgMSk7XFxuICAgIHZlYzQgbm9ybWFsID0geGZvcm1Ob1NjYWxlICogdmVjNChhX25vcm1hbCwgMCk7XFxuICAgIGNvbG9yID0gYV9jb2xvciAqIGFfY29sb3IxO1xcbiAgI2VuZGlmXFxuICB1diA9IGNvbXB1dGVVVihhX3RleENvb3JkLnosIGFfdGV4Q29vcmQueHksIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS54eSkgKiBtYWluVGlsaW5nX09mZnNldC54eSArIG1haW5UaWxpbmdfT2Zmc2V0Lnp3O1xcbiAgcG9zID0gY2NfbWF0Vmlld1Byb2ogKiBwb3M7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gbHB2c19tYWluKCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbmluIHZlYzIgdXY7XFxuaW4gdmVjNCBjb2xvcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIEZyYWdDb25zdGFudHMge1xcbiAgdmVjNCB0aW50Q29sb3I7XFxufTtcXG52ZWM0IGFkZCAoKSB7XFxuICB2ZWM0IGNvbCA9IDIuMCAqIGNvbG9yICogdGludENvbG9yICogdGV4dHVyZShtYWluVGV4dHVyZSwgdXYpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2wpO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBhZGQoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xzbDFcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUF4aXMgKHZlYzMgeEF4aXMsdmVjMyB5QXhpcyx2ZWMzIHpBeGlzKXtcXG4gIG1hdDMgbSA9IG1hdDMoeEF4aXMseUF4aXMsekF4aXMpO1xcbiAgZmxvYXQgdHJhY2UgPSBtWzBdWzBdICsgbVsxXVsxXSArIG1bMl1bMl07XFxuICB2ZWM0IHF1YXQ7XFxuICBpZiAodHJhY2UgPiAwLikge1xcbiAgICBmbG9hdCBzID0gMC41IC8gc3FydCh0cmFjZSArIDEuMCk7XFxuICAgIHF1YXQudyA9IDAuMjUgLyBzO1xcbiAgICBxdWF0LnggPSAobVsyXVsxXSAtIG1bMV1bMl0pICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzBdIC0gbVswXVsxXSkgKiBzO1xcbiAgfSBlbHNlIGlmICgobVswXVswXSA+IG1bMV1bMV0pICYmIChtWzBdWzBdID4gbVsyXVsyXSkpIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVswXVswXSAtIG1bMV1bMV0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAvIHM7XFxuICAgIHF1YXQueCA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC56ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICB9IGVsc2UgaWYgKG1bMV1bMV0gPiBtWzJdWzJdKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMV1bMV0gLSBtWzBdWzBdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzBdWzJdIC0gbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgfSBlbHNlIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsyXVsyXSAtIG1bMF1bMF0gLSBtWzFdWzFdKTtcXG4gICAgcXVhdC53ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gICAgcXVhdC56ID0gMC4yNSAqIHM7XFxuICB9XFxuICBmbG9hdCBsZW4gPSBxdWF0LnggKiBxdWF0LnggKyBxdWF0LnkgKiBxdWF0LnkgKyBxdWF0LnogKiBxdWF0LnogKyBxdWF0LncgKiBxdWF0Lnc7XFxuICBpZiAobGVuID4gMC4pIHtcXG4gICAgbGVuID0gMS4gLyBzcXJ0KGxlbik7XFxuICAgIHF1YXQueCA9IHF1YXQueCAqIGxlbjtcXG4gICAgcXVhdC55ID0gcXVhdC55ICogbGVuO1xcbiAgICBxdWF0LnogPSBxdWF0LnogKiBsZW47XFxuICAgIHF1YXQudyA9IHF1YXQudyAqIGxlbjtcXG4gIH1cXG4gIHJldHVybiBxdWF0O1xcbn1cXG52ZWM0IHF1YXRlcm5pb25Gcm9tRXVsZXIgKHZlYzMgYW5nbGUpe1xcbiAgZmxvYXQgeCA9IGFuZ2xlLnggLyAyLjtcXG4gIGZsb2F0IHkgPSBhbmdsZS55IC8gMi47XFxuICBmbG9hdCB6ID0gYW5nbGUueiAvIDIuO1xcbiAgZmxvYXQgc3ggPSBzaW4oeCk7XFxuICBmbG9hdCBjeCA9IGNvcyh4KTtcXG4gIGZsb2F0IHN5ID0gc2luKHkpO1xcbiAgZmxvYXQgY3kgPSBjb3MoeSk7XFxuICBmbG9hdCBzeiA9IHNpbih6KTtcXG4gIGZsb2F0IGN6ID0gY29zKHopO1xcbiAgdmVjNCBxdWF0ID0gdmVjNCgwKTtcXG4gIHF1YXQueCA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcXG4gIHF1YXQueSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcXG4gIHF1YXQueiA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcXG4gIHF1YXQudyA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG5tYXQ0IG1hdHJpeEZyb21SVCAodmVjNCBxLCB2ZWMzIHApe1xcbiAgZmxvYXQgeDIgPSBxLnggKyBxLng7XFxuICBmbG9hdCB5MiA9IHEueSArIHEueTtcXG4gIGZsb2F0IHoyID0gcS56ICsgcS56O1xcbiAgZmxvYXQgeHggPSBxLnggKiB4MjtcXG4gIGZsb2F0IHh5ID0gcS54ICogeTI7XFxuICBmbG9hdCB4eiA9IHEueCAqIHoyO1xcbiAgZmxvYXQgeXkgPSBxLnkgKiB5MjtcXG4gIGZsb2F0IHl6ID0gcS55ICogejI7XFxuICBmbG9hdCB6eiA9IHEueiAqIHoyO1xcbiAgZmxvYXQgd3ggPSBxLncgKiB4MjtcXG4gIGZsb2F0IHd5ID0gcS53ICogeTI7XFxuICBmbG9hdCB3eiA9IHEudyAqIHoyO1xcbiAgcmV0dXJuIG1hdDQoXFxuICAgIDEuIC0gKHl5ICsgenopLCB4eSArIHd6LCB4eiAtIHd5LCAwLFxcbiAgICB4eSAtIHd6LCAxLiAtICh4eCArIHp6KSwgeXogKyB3eCwgMCxcXG4gICAgeHogKyB3eSwgeXogLSB3eCwgMS4gLSAoeHggKyB5eSksIDAsXFxuICAgIHAueCwgcC55LCBwLnosIDFcXG4gICk7XFxufVxcbm1hdDQgbWF0RnJvbVJUUyAodmVjNCBxLCB2ZWMzIHQsIHZlYzMgcyl7XFxuICBmbG9hdCB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53O1xcbiAgZmxvYXQgeDIgPSB4ICsgeDtcXG4gIGZsb2F0IHkyID0geSArIHk7XFxuICBmbG9hdCB6MiA9IHogKyB6O1xcbiAgZmxvYXQgeHggPSB4ICogeDI7XFxuICBmbG9hdCB4eSA9IHggKiB5MjtcXG4gIGZsb2F0IHh6ID0geCAqIHoyO1xcbiAgZmxvYXQgeXkgPSB5ICogeTI7XFxuICBmbG9hdCB5eiA9IHkgKiB6MjtcXG4gIGZsb2F0IHp6ID0geiAqIHoyO1xcbiAgZmxvYXQgd3ggPSB3ICogeDI7XFxuICBmbG9hdCB3eSA9IHcgKiB5MjtcXG4gIGZsb2F0IHd6ID0gdyAqIHoyO1xcbiAgZmxvYXQgc3ggPSBzLng7XFxuICBmbG9hdCBzeSA9IHMueTtcXG4gIGZsb2F0IHN6ID0gcy56O1xcbiAgcmV0dXJuIG1hdDQoKDEuIC0gKHl5ICsgenopKSAqIHN4LCAoeHkgKyB3eikgKiBzeCwgKHh6IC0gd3kpICogc3gsIDAsXFxuICAgICh4eSAtIHd6KSAqIHN5LCAoMS4gLSAoeHggKyB6eikpICogc3ksICh5eiArIHd4KSAqIHN5LCAwLFxcbiAgICAoeHogKyB3eSkgKiBzeiwgKHl6IC0gd3gpICogc3osICgxLiAtICh4eCArIHl5KSkgKiBzeiwgMCxcXG4gICAgdC54LCB0LnksIHQueiwgMSk7XFxufVxcbnZlYzQgcXVhdE11bHRpcGx5ICh2ZWM0IGEsIHZlYzQgYil7XFxuICB2ZWM0IHF1YXQ7XFxuICBxdWF0LnggPSBhLnggKiBiLncgKyBhLncgKiBiLnggKyBhLnkgKiBiLnogLSBhLnogKiBiLnk7XFxuICBxdWF0LnkgPSBhLnkgKiBiLncgKyBhLncgKiBiLnkgKyBhLnogKiBiLnggLSBhLnggKiBiLno7XFxuICBxdWF0LnogPSBhLnogKiBiLncgKyBhLncgKiBiLnogKyBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxuICBxdWF0LncgPSBhLncgKiBiLncgLSBhLnggKiBiLnggLSBhLnkgKiBiLnkgLSBhLnogKiBiLno7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudm9pZCByb3RhdGVWZWNGcm9tUXVhdCAoaW5vdXQgdmVjMyB2LCB2ZWM0IHEpe1xcbiAgZmxvYXQgaXggPSBxLncgKiB2LnggKyBxLnkgKiB2LnogLSBxLnogKiB2Lnk7XFxuICBmbG9hdCBpeSA9IHEudyAqIHYueSArIHEueiAqIHYueCAtIHEueCAqIHYuejtcXG4gIGZsb2F0IGl6ID0gcS53ICogdi56ICsgcS54ICogdi55IC0gcS55ICogdi54O1xcbiAgZmxvYXQgaXcgPSAtcS54ICogdi54IC0gcS55ICogdi55IC0gcS56ICogdi56O1xcbiAgdi54ID0gaXggKiBxLncgKyBpdyAqIC1xLnggKyBpeSAqIC1xLnogLSBpeiAqIC1xLnk7XFxuICB2LnkgPSBpeSAqIHEudyArIGl3ICogLXEueSArIGl6ICogLXEueCAtIGl4ICogLXEuejtcXG4gIHYueiA9IGl6ICogcS53ICsgaXcgKiAtcS56ICsgaXggKiAtcS55IC0gaXkgKiAtcS54O1xcbn1cXG52ZWMzIHJvdGF0ZUluTG9jYWxTcGFjZSAodmVjMyBwb3MsIHZlYzMgeEF4aXMsIHZlYzMgeUF4aXMsIHZlYzMgekF4aXMsIHZlYzQgcSl7XFxuICB2ZWM0IHZpZXdRdWF0ID0gcXVhdGVybmlvbkZyb21BeGlzKHhBeGlzLCB5QXhpcywgekF4aXMpO1xcbiAgdmVjNCByb3RRdWF0ID0gcXVhdE11bHRpcGx5KHZpZXdRdWF0LCBxKTtcXG4gIHJvdGF0ZVZlY0Zyb21RdWF0KHBvcywgcm90UXVhdCk7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIHJvdGF0ZUNvcm5lciAoaW5vdXQgdmVjMiBjb3JuZXIsIGZsb2F0IGFuZ2xlKXtcXG4gIGZsb2F0IHhPUyA9IGNvcyhhbmdsZSkgKiBjb3JuZXIueCAtIHNpbihhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGZsb2F0IHlPUyA9IHNpbihhbmdsZSkgKiBjb3JuZXIueCArIGNvcyhhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGNvcm5lci54ID0geE9TO1xcbiAgY29ybmVyLnkgPSB5T1M7XFxufVxcbnVuaWZvcm0gdmVjNCBtYWluVGlsaW5nX09mZnNldDtcXG51bmlmb3JtIHZlYzQgZnJhbWVUaWxlX3ZlbExlblNjYWxlO1xcbnVuaWZvcm0gdmVjNCBzY2FsZTtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0VmlldztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0Vmlld0ludjtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxudW5pZm9ybSBoaWdocCB2ZWM0IGNjX2NhbWVyYVBvcztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdXY7XFxudmFyeWluZyBtZWRpdW1wIHZlYzQgY29sb3I7XFxudm9pZCBjb21wdXRlVmVydFBvcyAoaW5vdXQgdmVjNCBwb3MsIHZlYzIgdmVydE9mZnNldCwgdmVjNCBxLCB2ZWMzIHNcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMCB8fCBDQ19SRU5ERVJfTU9ERSA9PSAzXFxuICAsIG1hdDQgdmlld0ludlxcbiNlbmRpZlxcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAsIHZlYzMgZXllXFxuICAsIHZlYzQgdmVsb2NpdHlcXG4gICwgZmxvYXQgdmVsb2NpdHlTY2FsZVxcbiAgLCBmbG9hdCBsZW5ndGhTY2FsZVxcbiAgLCBmbG9hdCB4SW5kZXhcXG4jZW5kaWZcXG4pIHtcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMFxcbiAgdmVjMyB2aWV3U3BhY2VWZXJ0ID0gdmVjMyh2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSwgMC4pO1xcbiAgdmVjMyBjYW1YID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVswXSwgdmlld0ludlsxXVswXSwgdmlld0ludlsyXVswXSkpO1xcbiAgdmVjMyBjYW1ZID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsxXSwgdmlld0ludlsxXVsxXSwgdmlld0ludlsyXVsxXSkpO1xcbiAgdmVjMyBjYW1aID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsyXSwgdmlld0ludlsxXVsyXSwgdmlld0ludlsyXVsyXSkpO1xcbiAgcG9zLnh5eiArPSByb3RhdGVJbkxvY2FsU3BhY2Uodmlld1NwYWNlVmVydCwgY2FtWCwgY2FtWSwgY2FtWiwgcSk7XFxuI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgdmVjMyBjYW1SaWdodCA9IG5vcm1hbGl6ZShjcm9zcyhwb3MueHl6IC0gZXllLCB2ZWxvY2l0eS54eXopKSAqIHMueDtcXG4gIHZlYzMgY2FtVXAgPSB2ZWxvY2l0eS54eXogKiB2ZWxvY2l0eVNjYWxlICsgbm9ybWFsaXplKHZlbG9jaXR5Lnh5eikgKiBsZW5ndGhTY2FsZSAqIHMueTtcXG4gIHBvcy54eXogKz0gKGNhbVJpZ2h0ICogYWJzKHZlcnRPZmZzZXQueCkgKiBzaWduKHZlcnRPZmZzZXQueSkpIC0gY2FtVXAgKiB4SW5kZXg7XFxuI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gMlxcbiAgdmVjMyB2aWV3U3BhY2VWZXJ0ID0gdmVjMyh2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSwgMC4pO1xcbiAgdmVjMyBjYW1YID0gdmVjMygxLCAwLCAwKTtcXG4gIHZlYzMgY2FtWSA9IHZlYzMoMCwgMCwgLTEpO1xcbiAgcG9zLnh5eiArPSByb3RhdGVJbkxvY2FsU3BhY2Uodmlld1NwYWNlVmVydCwgY2FtWCwgY2FtWSwgY3Jvc3MoY2FtWCwgY2FtWSksIHEpO1xcbiNlbGlmIENDX1JFTkRFUl9NT0RFID09IDNcXG4gIHZlYzIgdmlld1NwYWNlVmVydCA9IHZlYzIodmVydE9mZnNldC54ICogcy54LCB2ZXJ0T2Zmc2V0LnkgKiBzLnkpO1xcbiAgcm90YXRlQ29ybmVyKHZpZXdTcGFjZVZlcnQsIHEueik7XFxuICB2ZWMzIGNhbVggPSBub3JtYWxpemUodmVjMyhjY19tYXRWaWV3WzBdWzBdLCBjY19tYXRWaWV3WzFdWzBdLCBjY19tYXRWaWV3WzJdWzBdKSk7XFxuICB2ZWMzIGNhbVkgPSB2ZWMzKDAsIDEsIDApO1xcbiAgdmVjMyBvZmZzZXQgPSBjYW1YICogdmlld1NwYWNlVmVydC54ICsgY2FtWSAqIHZpZXdTcGFjZVZlcnQueTtcXG4gIHBvcy54eXogKz0gb2Zmc2V0O1xcbiNlbHNlXFxuICBwb3MueCArPSB2ZXJ0T2Zmc2V0Lng7XFxuICBwb3MueSArPSB2ZXJ0T2Zmc2V0Lnk7XFxuI2VuZGlmXFxufVxcbnZlYzIgY29tcHV0ZVVWIChmbG9hdCBmcmFtZUluZGV4LCB2ZWMyIHZlcnRJbmRleCwgdmVjMiBmcmFtZVRpbGUpe1xcbiAgdmVjMiBhbmlVViA9IHZlYzIoMCwgZmxvb3IoZnJhbWVJbmRleCAqIGZyYW1lVGlsZS55KSk7XFxuICBhbmlVVi54ID0gZmxvb3IoZnJhbWVJbmRleCAqIGZyYW1lVGlsZS54ICogZnJhbWVUaWxlLnkgLSBhbmlVVi55ICogZnJhbWVUaWxlLngpO1xcbiNpZiBDQ19SRU5ERVJfTU9ERSAhPSA0XFxuICB2ZXJ0SW5kZXgueSA9IDEuIC0gdmVydEluZGV4Lnk7XFxuI2VuZGlmXFxuICByZXR1cm4gKGFuaVVWLnh5ICsgdmVydEluZGV4KSAvIHZlYzIoZnJhbWVUaWxlLngsIGZyYW1lVGlsZS55KTtcXG59XFxuYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBhX3RleENvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfdGV4Q29vcmQxO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfdGV4Q29vcmQyO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gIGF0dHJpYnV0ZSB2ZWMzIGFfY29sb3IxO1xcbiNlbmRpZlxcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSA0XFxuICBhdHRyaWJ1dGUgdmVjMyBhX3RleENvb3JkMztcXG4gIGF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcbiAgYXR0cmlidXRlIHZlYzQgYV9jb2xvcjE7XFxuI2VuZGlmXFxudmVjNCBscHZzX21haW4gKCkge1xcbiAgdmVjMyBjb21wU2NhbGUgPSBzY2FsZS54eXogKiBhX3RleENvb3JkMTtcXG4gIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAxKTtcXG4gICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgIHZlYzQgdmVsb2NpdHkgPSB2ZWM0KGFfY29sb3IxLnh5eiwgMCk7XFxuICAjZW5kaWZcXG4gICNpZiAhQ0NfVVNFX1dPUkxEX1NQQUNFXFxuICAgIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICAgIHZlbG9jaXR5ID0gY2NfbWF0V29ybGQgKiB2ZWxvY2l0eTtcXG4gICAgI2VuZGlmXFxuICAjZW5kaWZcXG4gICNpZiBDQ19SRU5ERVJfTU9ERSAhPSA0XFxuICAgIHZlYzIgY29ybmVyT2Zmc2V0ID0gdmVjMigoYV90ZXhDb29yZC54eSAtIDAuNSkpO1xcbiAgICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMFxcbiAgICAgIHZlYzMgcm90RXVsZXIgPSBhX3RleENvb3JkMjtcXG4gICAgI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICAgIHZlYzMgcm90RXVsZXIgPSB2ZWMzKDAuKTtcXG4gICAgI2Vsc2VcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gdmVjMygwLiwgMC4sIGFfdGV4Q29vcmQyLnopO1xcbiAgICAjZW5kaWZcXG4gICAgY29tcHV0ZVZlcnRQb3MocG9zLCBjb3JuZXJPZmZzZXQsIHF1YXRlcm5pb25Gcm9tRXVsZXIocm90RXVsZXIpLCBjb21wU2NhbGVcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDAgfHwgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgICAgICwgY2NfbWF0Vmlld0ludlxcbiAgICAjZW5kaWZcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgICAsIGNjX2NhbWVyYVBvcy54eXpcXG4gICAgICAsIHZlbG9jaXR5XFxuICAgICAgLCBmcmFtZVRpbGVfdmVsTGVuU2NhbGUuelxcbiAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLndcXG4gICAgICAsIGFfdGV4Q29vcmQueFxcbiAgICAjZW5kaWZcXG4gICAgKTtcXG4gICAgY29sb3IgPSBhX2NvbG9yO1xcbiAgI2Vsc2VcXG4gICAgbWF0NCB4Zm9ybU5vU2NhbGUgPSBtYXRyaXhGcm9tUlQocXVhdGVybmlvbkZyb21FdWxlcihhX3RleENvb3JkMiksIHBvcy54eXopO1xcbiAgICBtYXQ0IHhmb3JtID0gbWF0RnJvbVJUUyhxdWF0ZXJuaW9uRnJvbUV1bGVyKGFfdGV4Q29vcmQyKSwgcG9zLnh5eiwgY29tcFNjYWxlKTtcXG4gICAgcG9zID0geGZvcm0gKiB2ZWM0KGFfdGV4Q29vcmQzLCAxKTtcXG4gICAgdmVjNCBub3JtYWwgPSB4Zm9ybU5vU2NhbGUgKiB2ZWM0KGFfbm9ybWFsLCAwKTtcXG4gICAgY29sb3IgPSBhX2NvbG9yICogYV9jb2xvcjE7XFxuICAjZW5kaWZcXG4gIHV2ID0gY29tcHV0ZVVWKGFfdGV4Q29vcmQueiwgYV90ZXhDb29yZC54eSwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLnh5KSAqIG1haW5UaWxpbmdfT2Zmc2V0Lnh5ICsgbWFpblRpbGluZ19PZmZzZXQuenc7XFxuICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSBscHZzX21haW4oKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG51bmlmb3JtIHZlYzQgdGludENvbG9yO1xcbnZlYzQgYWRkICgpIHtcXG4gIHZlYzQgY29sID0gMi4wICogY29sb3IgKiB0aW50Q29sb3IgKiB0ZXh0dXJlMkQobWFpblRleHR1cmUsIHV2KTtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY29sKTtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBhZGQoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xzbDRcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUF4aXMgKHZlYzMgeEF4aXMsdmVjMyB5QXhpcyx2ZWMzIHpBeGlzKXtcXG4gIG1hdDMgbSA9IG1hdDMoeEF4aXMseUF4aXMsekF4aXMpO1xcbiAgZmxvYXQgdHJhY2UgPSBtWzBdWzBdICsgbVsxXVsxXSArIG1bMl1bMl07XFxuICB2ZWM0IHF1YXQ7XFxuICBpZiAodHJhY2UgPiAwLikge1xcbiAgICBmbG9hdCBzID0gMC41IC8gc3FydCh0cmFjZSArIDEuMCk7XFxuICAgIHF1YXQudyA9IDAuMjUgLyBzO1xcbiAgICBxdWF0LnggPSAobVsyXVsxXSAtIG1bMV1bMl0pICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzBdIC0gbVswXVsxXSkgKiBzO1xcbiAgfSBlbHNlIGlmICgobVswXVswXSA+IG1bMV1bMV0pICYmIChtWzBdWzBdID4gbVsyXVsyXSkpIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVswXVswXSAtIG1bMV1bMV0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAvIHM7XFxuICAgIHF1YXQueCA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC56ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICB9IGVsc2UgaWYgKG1bMV1bMV0gPiBtWzJdWzJdKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMV1bMV0gLSBtWzBdWzBdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzBdWzJdIC0gbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgfSBlbHNlIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsyXVsyXSAtIG1bMF1bMF0gLSBtWzFdWzFdKTtcXG4gICAgcXVhdC53ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gICAgcXVhdC56ID0gMC4yNSAqIHM7XFxuICB9XFxuICBmbG9hdCBsZW4gPSBxdWF0LnggKiBxdWF0LnggKyBxdWF0LnkgKiBxdWF0LnkgKyBxdWF0LnogKiBxdWF0LnogKyBxdWF0LncgKiBxdWF0Lnc7XFxuICBpZiAobGVuID4gMC4pIHtcXG4gICAgbGVuID0gMS4gLyBzcXJ0KGxlbik7XFxuICAgIHF1YXQueCA9IHF1YXQueCAqIGxlbjtcXG4gICAgcXVhdC55ID0gcXVhdC55ICogbGVuO1xcbiAgICBxdWF0LnogPSBxdWF0LnogKiBsZW47XFxuICAgIHF1YXQudyA9IHF1YXQudyAqIGxlbjtcXG4gIH1cXG4gIHJldHVybiBxdWF0O1xcbn1cXG52ZWM0IHF1YXRlcm5pb25Gcm9tRXVsZXIgKHZlYzMgYW5nbGUpe1xcbiAgZmxvYXQgeCA9IGFuZ2xlLnggLyAyLjtcXG4gIGZsb2F0IHkgPSBhbmdsZS55IC8gMi47XFxuICBmbG9hdCB6ID0gYW5nbGUueiAvIDIuO1xcbiAgZmxvYXQgc3ggPSBzaW4oeCk7XFxuICBmbG9hdCBjeCA9IGNvcyh4KTtcXG4gIGZsb2F0IHN5ID0gc2luKHkpO1xcbiAgZmxvYXQgY3kgPSBjb3MoeSk7XFxuICBmbG9hdCBzeiA9IHNpbih6KTtcXG4gIGZsb2F0IGN6ID0gY29zKHopO1xcbiAgdmVjNCBxdWF0ID0gdmVjNCgwKTtcXG4gIHF1YXQueCA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcXG4gIHF1YXQueSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcXG4gIHF1YXQueiA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcXG4gIHF1YXQudyA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG5tYXQ0IG1hdHJpeEZyb21SVCAodmVjNCBxLCB2ZWMzIHApe1xcbiAgZmxvYXQgeDIgPSBxLnggKyBxLng7XFxuICBmbG9hdCB5MiA9IHEueSArIHEueTtcXG4gIGZsb2F0IHoyID0gcS56ICsgcS56O1xcbiAgZmxvYXQgeHggPSBxLnggKiB4MjtcXG4gIGZsb2F0IHh5ID0gcS54ICogeTI7XFxuICBmbG9hdCB4eiA9IHEueCAqIHoyO1xcbiAgZmxvYXQgeXkgPSBxLnkgKiB5MjtcXG4gIGZsb2F0IHl6ID0gcS55ICogejI7XFxuICBmbG9hdCB6eiA9IHEueiAqIHoyO1xcbiAgZmxvYXQgd3ggPSBxLncgKiB4MjtcXG4gIGZsb2F0IHd5ID0gcS53ICogeTI7XFxuICBmbG9hdCB3eiA9IHEudyAqIHoyO1xcbiAgcmV0dXJuIG1hdDQoXFxuICAgIDEuIC0gKHl5ICsgenopLCB4eSArIHd6LCB4eiAtIHd5LCAwLFxcbiAgICB4eSAtIHd6LCAxLiAtICh4eCArIHp6KSwgeXogKyB3eCwgMCxcXG4gICAgeHogKyB3eSwgeXogLSB3eCwgMS4gLSAoeHggKyB5eSksIDAsXFxuICAgIHAueCwgcC55LCBwLnosIDFcXG4gICk7XFxufVxcbm1hdDQgbWF0RnJvbVJUUyAodmVjNCBxLCB2ZWMzIHQsIHZlYzMgcyl7XFxuICBmbG9hdCB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53O1xcbiAgZmxvYXQgeDIgPSB4ICsgeDtcXG4gIGZsb2F0IHkyID0geSArIHk7XFxuICBmbG9hdCB6MiA9IHogKyB6O1xcbiAgZmxvYXQgeHggPSB4ICogeDI7XFxuICBmbG9hdCB4eSA9IHggKiB5MjtcXG4gIGZsb2F0IHh6ID0geCAqIHoyO1xcbiAgZmxvYXQgeXkgPSB5ICogeTI7XFxuICBmbG9hdCB5eiA9IHkgKiB6MjtcXG4gIGZsb2F0IHp6ID0geiAqIHoyO1xcbiAgZmxvYXQgd3ggPSB3ICogeDI7XFxuICBmbG9hdCB3eSA9IHcgKiB5MjtcXG4gIGZsb2F0IHd6ID0gdyAqIHoyO1xcbiAgZmxvYXQgc3ggPSBzLng7XFxuICBmbG9hdCBzeSA9IHMueTtcXG4gIGZsb2F0IHN6ID0gcy56O1xcbiAgcmV0dXJuIG1hdDQoKDEuIC0gKHl5ICsgenopKSAqIHN4LCAoeHkgKyB3eikgKiBzeCwgKHh6IC0gd3kpICogc3gsIDAsXFxuICAgICh4eSAtIHd6KSAqIHN5LCAoMS4gLSAoeHggKyB6eikpICogc3ksICh5eiArIHd4KSAqIHN5LCAwLFxcbiAgICAoeHogKyB3eSkgKiBzeiwgKHl6IC0gd3gpICogc3osICgxLiAtICh4eCArIHl5KSkgKiBzeiwgMCxcXG4gICAgdC54LCB0LnksIHQueiwgMSk7XFxufVxcbnZlYzQgcXVhdE11bHRpcGx5ICh2ZWM0IGEsIHZlYzQgYil7XFxuICB2ZWM0IHF1YXQ7XFxuICBxdWF0LnggPSBhLnggKiBiLncgKyBhLncgKiBiLnggKyBhLnkgKiBiLnogLSBhLnogKiBiLnk7XFxuICBxdWF0LnkgPSBhLnkgKiBiLncgKyBhLncgKiBiLnkgKyBhLnogKiBiLnggLSBhLnggKiBiLno7XFxuICBxdWF0LnogPSBhLnogKiBiLncgKyBhLncgKiBiLnogKyBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxuICBxdWF0LncgPSBhLncgKiBiLncgLSBhLnggKiBiLnggLSBhLnkgKiBiLnkgLSBhLnogKiBiLno7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudm9pZCByb3RhdGVWZWNGcm9tUXVhdCAoaW5vdXQgdmVjMyB2LCB2ZWM0IHEpe1xcbiAgZmxvYXQgaXggPSBxLncgKiB2LnggKyBxLnkgKiB2LnogLSBxLnogKiB2Lnk7XFxuICBmbG9hdCBpeSA9IHEudyAqIHYueSArIHEueiAqIHYueCAtIHEueCAqIHYuejtcXG4gIGZsb2F0IGl6ID0gcS53ICogdi56ICsgcS54ICogdi55IC0gcS55ICogdi54O1xcbiAgZmxvYXQgaXcgPSAtcS54ICogdi54IC0gcS55ICogdi55IC0gcS56ICogdi56O1xcbiAgdi54ID0gaXggKiBxLncgKyBpdyAqIC1xLnggKyBpeSAqIC1xLnogLSBpeiAqIC1xLnk7XFxuICB2LnkgPSBpeSAqIHEudyArIGl3ICogLXEueSArIGl6ICogLXEueCAtIGl4ICogLXEuejtcXG4gIHYueiA9IGl6ICogcS53ICsgaXcgKiAtcS56ICsgaXggKiAtcS55IC0gaXkgKiAtcS54O1xcbn1cXG52ZWMzIHJvdGF0ZUluTG9jYWxTcGFjZSAodmVjMyBwb3MsIHZlYzMgeEF4aXMsIHZlYzMgeUF4aXMsIHZlYzMgekF4aXMsIHZlYzQgcSl7XFxuICB2ZWM0IHZpZXdRdWF0ID0gcXVhdGVybmlvbkZyb21BeGlzKHhBeGlzLCB5QXhpcywgekF4aXMpO1xcbiAgdmVjNCByb3RRdWF0ID0gcXVhdE11bHRpcGx5KHZpZXdRdWF0LCBxKTtcXG4gIHJvdGF0ZVZlY0Zyb21RdWF0KHBvcywgcm90UXVhdCk7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIHJvdGF0ZUNvcm5lciAoaW5vdXQgdmVjMiBjb3JuZXIsIGZsb2F0IGFuZ2xlKXtcXG4gIGZsb2F0IHhPUyA9IGNvcyhhbmdsZSkgKiBjb3JuZXIueCAtIHNpbihhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGZsb2F0IHlPUyA9IHNpbihhbmdsZSkgKiBjb3JuZXIueCArIGNvcyhhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGNvcm5lci54ID0geE9TO1xcbiAgY29ybmVyLnkgPSB5T1M7XFxufVxcbmxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDb25zdGFudHMge1xcbiAgdmVjNCBtYWluVGlsaW5nX09mZnNldDtcXG4gIHZlYzQgZnJhbWVUaWxlX3ZlbExlblNjYWxlO1xcbiAgdmVjNCBzY2FsZTtcXG59O1xcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxubGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IG1lZGl1bXAgdmVjMiB1djtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBvdXQgbWVkaXVtcCB2ZWM0IGNvbG9yO1xcbnZvaWQgY29tcHV0ZVZlcnRQb3MgKGlub3V0IHZlYzQgcG9zLCB2ZWMyIHZlcnRPZmZzZXQsIHZlYzQgcSwgdmVjMyBzXFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDAgfHwgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgLCBtYXQ0IHZpZXdJbnZcXG4jZW5kaWZcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgLCB2ZWMzIGV5ZVxcbiAgLCB2ZWM0IHZlbG9jaXR5XFxuICAsIGZsb2F0IHZlbG9jaXR5U2NhbGVcXG4gICwgZmxvYXQgbGVuZ3RoU2NhbGVcXG4gICwgZmxvYXQgeEluZGV4XFxuI2VuZGlmXFxuKSB7XFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gIHZlYzMgdmlld1NwYWNlVmVydCA9IHZlYzModmVydE9mZnNldC54ICogcy54LCB2ZXJ0T2Zmc2V0LnkgKiBzLnksIDAuKTtcXG4gIHZlYzMgY2FtWCA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMF0sIHZpZXdJbnZbMV1bMF0sIHZpZXdJbnZbMl1bMF0pKTtcXG4gIHZlYzMgY2FtWSA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMV0sIHZpZXdJbnZbMV1bMV0sIHZpZXdJbnZbMl1bMV0pKTtcXG4gIHZlYzMgY2FtWiA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMl0sIHZpZXdJbnZbMV1bMl0sIHZpZXdJbnZbMl1bMl0pKTtcXG4gIHBvcy54eXogKz0gcm90YXRlSW5Mb2NhbFNwYWNlKHZpZXdTcGFjZVZlcnQsIGNhbVgsIGNhbVksIGNhbVosIHEpO1xcbiNlbGlmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gIHZlYzMgY2FtUmlnaHQgPSBub3JtYWxpemUoY3Jvc3MocG9zLnh5eiAtIGV5ZSwgdmVsb2NpdHkueHl6KSkgKiBzLng7XFxuICB2ZWMzIGNhbVVwID0gdmVsb2NpdHkueHl6ICogdmVsb2NpdHlTY2FsZSArIG5vcm1hbGl6ZSh2ZWxvY2l0eS54eXopICogbGVuZ3RoU2NhbGUgKiBzLnk7XFxuICBwb3MueHl6ICs9IChjYW1SaWdodCAqIGFicyh2ZXJ0T2Zmc2V0LngpICogc2lnbih2ZXJ0T2Zmc2V0LnkpKSAtIGNhbVVwICogeEluZGV4O1xcbiNlbGlmIENDX1JFTkRFUl9NT0RFID09IDJcXG4gIHZlYzMgdmlld1NwYWNlVmVydCA9IHZlYzModmVydE9mZnNldC54ICogcy54LCB2ZXJ0T2Zmc2V0LnkgKiBzLnksIDAuKTtcXG4gIHZlYzMgY2FtWCA9IHZlYzMoMSwgMCwgMCk7XFxuICB2ZWMzIGNhbVkgPSB2ZWMzKDAsIDAsIC0xKTtcXG4gIHBvcy54eXogKz0gcm90YXRlSW5Mb2NhbFNwYWNlKHZpZXdTcGFjZVZlcnQsIGNhbVgsIGNhbVksIGNyb3NzKGNhbVgsIGNhbVkpLCBxKTtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAzXFxuICB2ZWMyIHZpZXdTcGFjZVZlcnQgPSB2ZWMyKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55KTtcXG4gIHJvdGF0ZUNvcm5lcih2aWV3U3BhY2VWZXJ0LCBxLnopO1xcbiAgdmVjMyBjYW1YID0gbm9ybWFsaXplKHZlYzMoY2NfbWF0Vmlld1swXVswXSwgY2NfbWF0Vmlld1sxXVswXSwgY2NfbWF0Vmlld1syXVswXSkpO1xcbiAgdmVjMyBjYW1ZID0gdmVjMygwLCAxLCAwKTtcXG4gIHZlYzMgb2Zmc2V0ID0gY2FtWCAqIHZpZXdTcGFjZVZlcnQueCArIGNhbVkgKiB2aWV3U3BhY2VWZXJ0Lnk7XFxuICBwb3MueHl6ICs9IG9mZnNldDtcXG4jZWxzZVxcbiAgcG9zLnggKz0gdmVydE9mZnNldC54O1xcbiAgcG9zLnkgKz0gdmVydE9mZnNldC55O1xcbiNlbmRpZlxcbn1cXG52ZWMyIGNvbXB1dGVVViAoZmxvYXQgZnJhbWVJbmRleCwgdmVjMiB2ZXJ0SW5kZXgsIHZlYzIgZnJhbWVUaWxlKXtcXG4gIHZlYzIgYW5pVVYgPSB2ZWMyKDAsIGZsb29yKGZyYW1lSW5kZXggKiBmcmFtZVRpbGUueSkpO1xcbiAgYW5pVVYueCA9IGZsb29yKGZyYW1lSW5kZXggKiBmcmFtZVRpbGUueCAqIGZyYW1lVGlsZS55IC0gYW5pVVYueSAqIGZyYW1lVGlsZS54KTtcXG4jaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgdmVydEluZGV4LnkgPSAxLiAtIHZlcnRJbmRleC55O1xcbiNlbmRpZlxcbiAgcmV0dXJuIChhbmlVVi54eSArIHZlcnRJbmRleCkgLyB2ZWMyKGZyYW1lVGlsZS54LCBmcmFtZVRpbGUueSk7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzMgYV9wb3NpdGlvbjtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMzIGFfdGV4Q29vcmQ7XFxubGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjMyBhX3RleENvb3JkMTtcXG5sYXlvdXQobG9jYXRpb24gPSAzKSBpbiB2ZWMzIGFfdGV4Q29vcmQyO1xcbmxheW91dChsb2NhdGlvbiA9IDQpIGluIHZlYzQgYV9jb2xvcjtcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgbGF5b3V0KGxvY2F0aW9uID0gNSkgaW4gdmVjMyBhX2NvbG9yMTtcXG4jZW5kaWZcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gNFxcbiAgbGF5b3V0KGxvY2F0aW9uID0gNikgaW4gdmVjMyBhX3RleENvb3JkMztcXG4gIGxheW91dChsb2NhdGlvbiA9IDcpIGluIHZlYzMgYV9ub3JtYWw7XFxuICBsYXlvdXQobG9jYXRpb24gPSA1KSBpbiB2ZWM0IGFfY29sb3IxO1xcbiNlbmRpZlxcbnZlYzQgbHB2c19tYWluICgpIHtcXG4gIHZlYzMgY29tcFNjYWxlID0gc2NhbGUueHl6ICogYV90ZXhDb29yZDE7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbiwgMSk7XFxuICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICB2ZWM0IHZlbG9jaXR5ID0gdmVjNChhX2NvbG9yMS54eXosIDApO1xcbiAgI2VuZGlmXFxuICAjaWYgIUNDX1VTRV9XT1JMRF9TUEFDRVxcbiAgICBwb3MgPSBjY19tYXRXb3JsZCAqIHBvcztcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgICB2ZWxvY2l0eSA9IGNjX21hdFdvcmxkICogdmVsb2NpdHk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICAjaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgICB2ZWMyIGNvcm5lck9mZnNldCA9IHZlYzIoKGFfdGV4Q29vcmQueHkgLSAwLjUpKTtcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gYV90ZXhDb29yZDI7XFxuICAgICNlbGlmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gdmVjMygwLik7XFxuICAgICNlbHNlXFxuICAgICAgdmVjMyByb3RFdWxlciA9IHZlYzMoMC4sIDAuLCBhX3RleENvb3JkMi56KTtcXG4gICAgI2VuZGlmXFxuICAgIGNvbXB1dGVWZXJ0UG9zKHBvcywgY29ybmVyT2Zmc2V0LCBxdWF0ZXJuaW9uRnJvbUV1bGVyKHJvdEV1bGVyKSwgY29tcFNjYWxlXFxuICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICAgICAsIGNjX21hdFZpZXdJbnZcXG4gICAgI2VuZGlmXFxuICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgLCBjY19jYW1lcmFQb3MueHl6XFxuICAgICAgLCB2ZWxvY2l0eVxcbiAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLnpcXG4gICAgICAsIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS53XFxuICAgICAgLCBhX3RleENvb3JkLnhcXG4gICAgI2VuZGlmXFxuICAgICk7XFxuICAgIGNvbG9yID0gYV9jb2xvcjtcXG4gICNlbHNlXFxuICAgIG1hdDQgeGZvcm1Ob1NjYWxlID0gbWF0cml4RnJvbVJUKHF1YXRlcm5pb25Gcm9tRXVsZXIoYV90ZXhDb29yZDIpLCBwb3MueHl6KTtcXG4gICAgbWF0NCB4Zm9ybSA9IG1hdEZyb21SVFMocXVhdGVybmlvbkZyb21FdWxlcihhX3RleENvb3JkMiksIHBvcy54eXosIGNvbXBTY2FsZSk7XFxuICAgIHBvcyA9IHhmb3JtICogdmVjNChhX3RleENvb3JkMywgMSk7XFxuICAgIHZlYzQgbm9ybWFsID0geGZvcm1Ob1NjYWxlICogdmVjNChhX25vcm1hbCwgMCk7XFxuICAgIGNvbG9yID0gYV9jb2xvciAqIGFfY29sb3IxO1xcbiAgI2VuZGlmXFxuICB1diA9IGNvbXB1dGVVVihhX3RleENvb3JkLnosIGFfdGV4Q29vcmQueHksIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS54eSkgKiBtYWluVGlsaW5nX09mZnNldC54eSArIG1haW5UaWxpbmdfT2Zmc2V0Lnp3O1xcbiAgcG9zID0gY2NfbWF0Vmlld1Byb2ogKiBwb3M7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gbHB2c19tYWluKCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMiB1djtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWM0IGNvbG9yO1xcbmxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMikgdW5pZm9ybSBzYW1wbGVyMkQgbWFpblRleHR1cmU7XFxubGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSAxKSB1bmlmb3JtIEZyYWdDb25zdGFudHMge1xcbiAgdmVjNCB0aW50Q29sb3I7XFxufTtcXG52ZWM0IGFkZCAoKSB7XFxuICB2ZWM0IGNvbCA9IDIuMCAqIGNvbG9yICogdGludENvbG9yICogdGV4dHVyZShtYWluVGV4dHVyZSwgdXYpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2wpO1xcbn1cXG5sYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBhZGQoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnVpbHRpbnNcIjoge1xyXG4gICAgICAgICAgXCJnbG9iYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NHbG9iYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH0sXHJcbiAgICAgICAgICBcImxvY2Fsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDTG9jYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1JFTkRFUl9NT0RFXCIsIFwidHlwZVwiOiBcIm51bWJlclwiLCBcInJhbmdlXCI6IFswLCA0XSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfV09STERfU1BBQ0VcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMCwgXCJzdGFnZUZsYWdzXCI6IDEsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwibWFpblRpbGluZ19PZmZzZXRcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJmcmFtZVRpbGVfdmVsTGVuU2NhbGVcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJzY2FsZVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJGcmFnQ29uc3RhbnRzXCIsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDEsIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ0aW50Q29sb3JcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGV4dHVyZVwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMTYsIFwiYmluZGluZ1wiOiAyIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcG9zaXRpb25cIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZFwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkMVwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkMlwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2NvbG9yXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJsb2NhdGlvblwiOiA0IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfY29sb3IxXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfUkVOREVSX01PREVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiA1IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmQzXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfUkVOREVSX01PREVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiA2IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbm9ybWFsXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfUkVOREVSX01PREVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiA3IH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tc3ByaXRlXCIsXHJcbiAgICBcIl91dWlkXCI6IFwiNjBmNzE5NWMtZWMyYS00NWViLWJhOTQtODk1NWY2MGU4MWQwXCIsXHJcbiAgICBcInRlY2huaXF1ZXNcIjogW1xyXG4gICAgICB7IFwicGFzc2VzXCI6IFt7IFwiYmxlbmRTdGF0ZVwiOiB7IFwidGFyZ2V0c1wiOiBbeyBcImJsZW5kXCI6IHRydWUsIFwiYmxlbmRTcmNcIjogMiwgXCJibGVuZERzdFwiOiA0LCBcImJsZW5kRHN0QWxwaGFcIjogNCB9XSB9LCBcInJhc3Rlcml6ZXJTdGF0ZVwiOiB7IFwiY3VsbE1vZGVcIjogMCB9LCBcInByb2dyYW1cIjogXCJidWlsdGluLXNwcml0ZXxzcHJpdGUtdnM6dmVydHxzcHJpdGUtZnM6ZnJhZ1wiLCBcImRlcHRoU3RlbmNpbFN0YXRlXCI6IHsgXCJkZXB0aFRlc3RcIjogZmFsc2UsIFwiZGVwdGhXcml0ZVwiOiBmYWxzZSB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1zcHJpdGV8c3ByaXRlLXZzOnZlcnR8c3ByaXRlLWZzOmZyYWdcIixcclxuICAgICAgICBcImhhc2hcIjogMjY3OTA3ODM5MixcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbiNpZiBVU0VfTE9DQUxcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxuI2VuZGlmXFxuaW4gdmVjMyBhX3Bvc2l0aW9uO1xcbmluIHZlYzIgYV90ZXhDb29yZDtcXG5pbiB2ZWM0IGFfY29sb3I7XFxub3V0IHZlYzQgY29sb3I7XFxub3V0IHZlYzIgdXYwO1xcbnZlYzQgdmVydCAoKSB7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbiwgMSk7XFxuICAjaWYgVVNFX0xPQ0FMXFxuICAgIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX1BJWEVMX0FMSUdOTUVOVFxcbiAgICBwb3MgPSBjY19tYXRWaWV3ICogcG9zO1xcbiAgICBwb3MueHl6ID0gZmxvb3IocG9zLnh5eik7XFxuICAgIHBvcyA9IGNjX21hdFByb2ogKiBwb3M7XFxuICAjZWxzZVxcbiAgICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gICNlbmRpZlxcbiAgdXYwID0gYV90ZXhDb29yZDtcXG4gIGNvbG9yID0gYV9jb2xvcjtcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudmVjNCBDQ1NhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleCwgdmVjMiB1dikge1xcbiNpZiBDQ19VU0VfRU1CRURERURfQUxQSEFcXG4gICAgcmV0dXJuIHZlYzQodGV4dHVyZSh0ZXgsIHV2KS5yZ2IsIHRleHR1cmUodGV4LCB1diArIHZlYzIoMC4wLCAwLjUpKS5yKTtcXG4jZWxzZVxcbiAgICByZXR1cm4gdGV4dHVyZSh0ZXgsIHV2KTtcXG4jZW5kaWZcXG59XFxuaW4gdmVjNCBjb2xvcjtcXG4jaWYgVVNFX1RFWFRVUkVcXG4gIGluIHZlYzIgdXYwO1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgY2Nfc3ByaXRlVGV4dHVyZTtcXG4jZW5kaWZcXG52ZWM0IGZyYWcgKCkge1xcbiAgdmVjNCBvID0gdmVjNCgxLCAxLCAxLCAxKTtcXG4gICNpZiBVU0VfVEVYVFVSRVxcbiAgICBvICo9IENDU2FtcGxlVGV4dHVyZShjY19zcHJpdGVUZXh0dXJlLCB1djApO1xcbiAgICAjaWYgSVNfR1JBWVxcbiAgICAgIGZsb2F0IGdyYXkgID0gMC4yMTI2ICogby5yICsgMC43MTUyICogby5nICsgMC4wNzIyICogby5iO1xcbiAgICAgIG8uciA9IG8uZyA9IG8uYiA9IGdyYXk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICBvICo9IGNvbG9yO1xcbiAgcmV0dXJuIG87XFxufVxcbm91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xzbDFcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXc7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFByb2o7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiNpZiBVU0VfTE9DQUxcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuI2VuZGlmXFxuYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgdmVjMiB1djA7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAxKTtcXG4gICNpZiBVU0VfTE9DQUxcXG4gICAgcG9zID0gY2NfbWF0V29ybGQgKiBwb3M7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfUElYRUxfQUxJR05NRU5UXFxuICAgIHBvcyA9IGNjX21hdFZpZXcgKiBwb3M7XFxuICAgIHBvcy54eXogPSBmbG9vcihwb3MueHl6KTtcXG4gICAgcG9zID0gY2NfbWF0UHJvaiAqIHBvcztcXG4gICNlbHNlXFxuICAgIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgI2VuZGlmXFxuICB1djAgPSBhX3RleENvb3JkO1xcbiAgY29sb3IgPSBhX2NvbG9yO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG52ZWM0IENDU2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4LCB2ZWMyIHV2KSB7XFxuI2lmIENDX1VTRV9FTUJFRERFRF9BTFBIQVxcbiAgICByZXR1cm4gdmVjNCh0ZXh0dXJlMkQodGV4LCB1dikucmdiLCB0ZXh0dXJlMkQodGV4LCB1diArIHZlYzIoMC4wLCAwLjUpKS5yKTtcXG4jZWxzZVxcbiAgICByZXR1cm4gdGV4dHVyZTJEKHRleCwgdXYpO1xcbiNlbmRpZlxcbn1cXG52YXJ5aW5nIHZlYzQgY29sb3I7XFxuI2lmIFVTRV9URVhUVVJFXFxuICB2YXJ5aW5nIHZlYzIgdXYwO1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgY2Nfc3ByaXRlVGV4dHVyZTtcXG4jZW5kaWZcXG52ZWM0IGZyYWcgKCkge1xcbiAgdmVjNCBvID0gdmVjNCgxLCAxLCAxLCAxKTtcXG4gICNpZiBVU0VfVEVYVFVSRVxcbiAgICBvICo9IENDU2FtcGxlVGV4dHVyZShjY19zcHJpdGVUZXh0dXJlLCB1djApO1xcbiAgICAjaWYgSVNfR1JBWVxcbiAgICAgIGZsb2F0IGdyYXkgID0gMC4yMTI2ICogby5yICsgMC43MTUyICogby5nICsgMC4wNzIyICogby5iO1xcbiAgICAgIG8uciA9IG8uZyA9IG8uYiA9IGdyYXk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICBvICo9IGNvbG9yO1xcbiAgcmV0dXJuIG87XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsNFwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbiNpZiBVU0VfTE9DQUxcXG5sYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NMb2NhbCB7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZElUO1xcbiAgaGlnaHAgdmVjNCBjY19saWdodGluZ01hcFVWUGFyYW07XFxufTtcXG4jZW5kaWZcXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWMzIGFfcG9zaXRpb247XFxubGF5b3V0KGxvY2F0aW9uID0gMSkgaW4gdmVjMiBhX3RleENvb3JkO1xcbmxheW91dChsb2NhdGlvbiA9IDIpIGluIHZlYzQgYV9jb2xvcjtcXG5sYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCBjb2xvcjtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBvdXQgdmVjMiB1djA7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAxKTtcXG4gICNpZiBVU0VfTE9DQUxcXG4gICAgcG9zID0gY2NfbWF0V29ybGQgKiBwb3M7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfUElYRUxfQUxJR05NRU5UXFxuICAgIHBvcyA9IGNjX21hdFZpZXcgKiBwb3M7XFxuICAgIHBvcy54eXogPSBmbG9vcihwb3MueHl6KTtcXG4gICAgcG9zID0gY2NfbWF0UHJvaiAqIHBvcztcXG4gICNlbHNlXFxuICAgIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgI2VuZGlmXFxuICB1djAgPSBhX3RleENvb3JkO1xcbiAgY29sb3IgPSBhX2NvbG9yO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG52ZWM0IENDU2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4LCB2ZWMyIHV2KSB7XFxuI2lmIENDX1VTRV9FTUJFRERFRF9BTFBIQVxcbiAgICByZXR1cm4gdmVjNCh0ZXh0dXJlKHRleCwgdXYpLnJnYiwgdGV4dHVyZSh0ZXgsIHV2ICsgdmVjMigwLjAsIDAuNSkpLnIpO1xcbiNlbHNlXFxuICAgIHJldHVybiB0ZXh0dXJlKHRleCwgdXYpO1xcbiNlbmRpZlxcbn1cXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWM0IGNvbG9yO1xcbiNpZiBVU0VfVEVYVFVSRVxcbiAgbGF5b3V0KGxvY2F0aW9uID0gMSkgaW4gdmVjMiB1djA7XFxuICBsYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDEwKSB1bmlmb3JtIHNhbXBsZXIyRCBjY19zcHJpdGVUZXh0dXJlO1xcbiNlbmRpZlxcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IG8gPSB2ZWM0KDEsIDEsIDEsIDEpO1xcbiAgI2lmIFVTRV9URVhUVVJFXFxuICAgIG8gKj0gQ0NTYW1wbGVUZXh0dXJlKGNjX3Nwcml0ZVRleHR1cmUsIHV2MCk7XFxuICAgICNpZiBJU19HUkFZXFxuICAgICAgZmxvYXQgZ3JheSAgPSAwLjIxMjYgKiBvLnIgKyAwLjcxNTIgKiBvLmcgKyAwLjA3MjIgKiBvLmI7XFxuICAgICAgby5yID0gby5nID0gby5iID0gZ3JheTtcXG4gICAgI2VuZGlmXFxuICAjZW5kaWZcXG4gIG8gKj0gY29sb3I7XFxuICByZXR1cm4gbztcXG59XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NMb2NhbFwiLCBcImRlZmluZXNcIjogW1wiVVNFX0xPQ0FMXCJdIH1dLCBcInNhbXBsZXJzXCI6IFt7IFwibmFtZVwiOiBcImNjX3Nwcml0ZVRleHR1cmVcIiwgXCJkZWZpbmVzXCI6IFtcIlVTRV9URVhUVVJFXCJdIH1dIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9MT0NBTFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX1BJWEVMX0FMSUdOTUVOVFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0VNQkVEREVEX0FMUEhBXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfVEVYVFVSRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiSVNfR1JBWVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJibG9ja3NcIjogW10sXHJcbiAgICAgICAgXCJzYW1wbGVyc1wiOiBbXSxcclxuICAgICAgICBcImF0dHJpYnV0ZXNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3Bvc2l0aW9uXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmRcIiwgXCJ0eXBlXCI6IDE0LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDIxLCBcImxvY2F0aW9uXCI6IDEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9jb2xvclwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogMiB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJidWlsdGluLXN0YW5kYXJkXCIsXHJcbiAgICBcIl91dWlkXCI6IFwiMWJhZjBmYzktYmVmYS00NTljLThiZGQtYWYxYTQ1MGEwMzE5XCIsXHJcbiAgICBcInRlY2huaXF1ZXNcIjogW1xyXG4gICAgICB7IFwibmFtZVwiOiBcIm9wYXF1ZVwiLCBcInBhc3Nlc1wiOiBbeyBcInByb2dyYW1cIjogXCJidWlsdGluLXN0YW5kYXJkfHN0YW5kYXJkLXZzOnZlcnR8c3RhbmRhcmQtZnM6ZnJhZ1wiLCBcInByb3BlcnRpZXNcIjogeyBcInRpbGluZ09mZnNldFwiOiB7IFwidmFsdWVcIjogWzEsIDEsIDAsIDBdLCBcInR5cGVcIjogMTYgfSwgXCJtYWluQ29sb3JcIjogeyBcInZhbHVlXCI6IFsxLCAxLCAxLCAxXSwgXCJ0eXBlXCI6IDE2LCBcImhhbmRsZUluZm9cIjogW1wiYWxiZWRvXCIsIDAsIDE2XSB9LCBcImFsYmVkb1NjYWxlXCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMV0sIFwidHlwZVwiOiAxNSwgXCJoYW5kbGVJbmZvXCI6IFtcImFsYmVkb1NjYWxlQW5kQ3V0b2ZmXCIsIDAsIDE1XSB9LCBcImFscGhhVGhyZXNob2xkXCI6IHsgXCJ2YWx1ZVwiOiBbMC41XSwgXCJ0eXBlXCI6IDEzLCBcImhhbmRsZUluZm9cIjogW1wiYWxiZWRvU2NhbGVBbmRDdXRvZmZcIiwgMywgMTNdIH0sIFwib2NjbHVzaW9uXCI6IHsgXCJ2YWx1ZVwiOiBbMV0sIFwidHlwZVwiOiAxMywgXCJoYW5kbGVJbmZvXCI6IFtcInBiclBhcmFtc1wiLCAwLCAxM10gfSwgXCJyb3VnaG5lc3NcIjogeyBcInZhbHVlXCI6IFswLjhdLCBcInR5cGVcIjogMTMsIFwiaGFuZGxlSW5mb1wiOiBbXCJwYnJQYXJhbXNcIiwgMSwgMTNdIH0sIFwibWV0YWxsaWNcIjogeyBcInZhbHVlXCI6IFswLjZdLCBcInR5cGVcIjogMTMsIFwiaGFuZGxlSW5mb1wiOiBbXCJwYnJQYXJhbXNcIiwgMiwgMTNdIH0sIFwibm9ybWFsU3RyZW50aFwiOiB7IFwidmFsdWVcIjogWzFdLCBcInR5cGVcIjogMTMsIFwiaGFuZGxlSW5mb1wiOiBbXCJwYnJQYXJhbXNcIiwgMywgMTNdIH0sIFwiZW1pc3NpdmVcIjogeyBcInZhbHVlXCI6IFswLCAwLCAwLCAxXSwgXCJ0eXBlXCI6IDE2IH0sIFwiZW1pc3NpdmVTY2FsZVwiOiB7IFwidmFsdWVcIjogWzEsIDEsIDFdLCBcInR5cGVcIjogMTUsIFwiaGFuZGxlSW5mb1wiOiBbXCJlbWlzc2l2ZVNjYWxlUGFyYW1cIiwgMCwgMTVdIH0sIFwibWFpblRleHR1cmVcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjgsIFwiaGFuZGxlSW5mb1wiOiBbXCJhbGJlZG9NYXBcIiwgMCwgMjhdIH0sIFwibm9ybWFsTWFwXCI6IHsgXCJ2YWx1ZVwiOiBcIm5vcm1hbFwiLCBcInR5cGVcIjogMjggfSwgXCJwYnJNYXBcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjggfSwgXCJtZXRhbGxpY1JvdWdobmVzc01hcFwiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcIm9jY2x1c2lvbk1hcFwiOiB7IFwidmFsdWVcIjogXCJ3aGl0ZVwiLCBcInR5cGVcIjogMjggfSwgXCJlbWlzc2l2ZU1hcFwiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcImFsYmVkb1wiOiB7IFwidHlwZVwiOiAxNiwgXCJ2YWx1ZVwiOiBbMSwgMSwgMSwgMV0gfSwgXCJhbGJlZG9TY2FsZUFuZEN1dG9mZlwiOiB7IFwidHlwZVwiOiAxNiwgXCJ2YWx1ZVwiOiBbMSwgMSwgMSwgMC41XSB9LCBcInBiclBhcmFtc1wiOiB7IFwidHlwZVwiOiAxNiwgXCJ2YWx1ZVwiOiBbMSwgMC44LCAwLjYsIDFdIH0sIFwiZW1pc3NpdmVTY2FsZVBhcmFtXCI6IHsgXCJ0eXBlXCI6IDE2LCBcInZhbHVlXCI6IFsxLCAxLCAxLCAwXSB9LCBcImFsYmVkb01hcFwiOiB7IFwidHlwZVwiOiAyOCwgXCJ2YWx1ZVwiOiBcImdyZXlcIiB9IH0gfSwgeyBcInBoYXNlXCI6IFwiZm9yd2FyZC1hZGRcIiwgXCJwcm9wZXJ0eUluZGV4XCI6IDAsIFwiZW1iZWRkZWRNYWNyb3NcIjogeyBcIkNDX0ZPUldBUkRfQUREXCI6IHRydWUgfSwgXCJibGVuZFN0YXRlXCI6IHsgXCJ0YXJnZXRzXCI6IFt7IFwiYmxlbmRcIjogdHJ1ZSwgXCJibGVuZFNyY1wiOiAxLCBcImJsZW5kRHN0XCI6IDEsIFwiYmxlbmRTcmNBbHBoYVwiOiAwLCBcImJsZW5kRHN0QWxwaGFcIjogMSB9XSB9LCBcInByb2dyYW1cIjogXCJidWlsdGluLXN0YW5kYXJkfHN0YW5kYXJkLXZzOnZlcnR8c3RhbmRhcmQtZnM6ZnJhZ1wiLCBcImRlcHRoU3RlbmNpbFN0YXRlXCI6IHsgXCJkZXB0aEZ1bmNcIjogMiwgXCJkZXB0aFRlc3RcIjogdHJ1ZSwgXCJkZXB0aFdyaXRlXCI6IGZhbHNlIH0sIFwicHJvcGVydGllc1wiOiB7IFwidGlsaW5nT2Zmc2V0XCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMCwgMF0sIFwidHlwZVwiOiAxNiB9LCBcIm1haW5Db2xvclwiOiB7IFwidmFsdWVcIjogWzEsIDEsIDEsIDFdLCBcInR5cGVcIjogMTYsIFwiaGFuZGxlSW5mb1wiOiBbXCJhbGJlZG9cIiwgMCwgMTZdIH0sIFwiYWxiZWRvU2NhbGVcIjogeyBcInZhbHVlXCI6IFsxLCAxLCAxXSwgXCJ0eXBlXCI6IDE1LCBcImhhbmRsZUluZm9cIjogW1wiYWxiZWRvU2NhbGVBbmRDdXRvZmZcIiwgMCwgMTVdIH0sIFwiYWxwaGFUaHJlc2hvbGRcIjogeyBcInZhbHVlXCI6IFswLjVdLCBcInR5cGVcIjogMTMsIFwiaGFuZGxlSW5mb1wiOiBbXCJhbGJlZG9TY2FsZUFuZEN1dG9mZlwiLCAzLCAxM10gfSwgXCJvY2NsdXNpb25cIjogeyBcInZhbHVlXCI6IFsxXSwgXCJ0eXBlXCI6IDEzLCBcImhhbmRsZUluZm9cIjogW1wicGJyUGFyYW1zXCIsIDAsIDEzXSB9LCBcInJvdWdobmVzc1wiOiB7IFwidmFsdWVcIjogWzAuOF0sIFwidHlwZVwiOiAxMywgXCJoYW5kbGVJbmZvXCI6IFtcInBiclBhcmFtc1wiLCAxLCAxM10gfSwgXCJtZXRhbGxpY1wiOiB7IFwidmFsdWVcIjogWzAuNl0sIFwidHlwZVwiOiAxMywgXCJoYW5kbGVJbmZvXCI6IFtcInBiclBhcmFtc1wiLCAyLCAxM10gfSwgXCJub3JtYWxTdHJlbnRoXCI6IHsgXCJ2YWx1ZVwiOiBbMV0sIFwidHlwZVwiOiAxMywgXCJoYW5kbGVJbmZvXCI6IFtcInBiclBhcmFtc1wiLCAzLCAxM10gfSwgXCJlbWlzc2l2ZVwiOiB7IFwidmFsdWVcIjogWzAsIDAsIDAsIDFdLCBcInR5cGVcIjogMTYgfSwgXCJlbWlzc2l2ZVNjYWxlXCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMV0sIFwidHlwZVwiOiAxNSwgXCJoYW5kbGVJbmZvXCI6IFtcImVtaXNzaXZlU2NhbGVQYXJhbVwiLCAwLCAxNV0gfSwgXCJtYWluVGV4dHVyZVwiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCwgXCJoYW5kbGVJbmZvXCI6IFtcImFsYmVkb01hcFwiLCAwLCAyOF0gfSwgXCJub3JtYWxNYXBcIjogeyBcInZhbHVlXCI6IFwibm9ybWFsXCIsIFwidHlwZVwiOiAyOCB9LCBcInBick1hcFwiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcIm1ldGFsbGljUm91Z2huZXNzTWFwXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0sIFwib2NjbHVzaW9uTWFwXCI6IHsgXCJ2YWx1ZVwiOiBcIndoaXRlXCIsIFwidHlwZVwiOiAyOCB9LCBcImVtaXNzaXZlTWFwXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0sIFwiYWxiZWRvXCI6IHsgXCJ0eXBlXCI6IDE2LCBcInZhbHVlXCI6IFsxLCAxLCAxLCAxXSB9LCBcImFsYmVkb1NjYWxlQW5kQ3V0b2ZmXCI6IHsgXCJ0eXBlXCI6IDE2LCBcInZhbHVlXCI6IFsxLCAxLCAxLCAwLjVdIH0sIFwicGJyUGFyYW1zXCI6IHsgXCJ0eXBlXCI6IDE2LCBcInZhbHVlXCI6IFsxLCAwLjgsIDAuNiwgMV0gfSwgXCJlbWlzc2l2ZVNjYWxlUGFyYW1cIjogeyBcInR5cGVcIjogMTYsIFwidmFsdWVcIjogWzEsIDEsIDEsIDBdIH0sIFwiYWxiZWRvTWFwXCI6IHsgXCJ0eXBlXCI6IDI4LCBcInZhbHVlXCI6IFwiZ3JleVwiIH0gfSB9LCB7IFwicGhhc2VcIjogXCJzaGFkb3ctYWRkXCIsIFwicHJvcGVydHlJbmRleFwiOiAwLCBcInJhc3Rlcml6ZXJTdGF0ZVwiOiB7IFwiY3VsbE1vZGVcIjogMSB9LCBcInByb2dyYW1cIjogXCJidWlsdGluLXN0YW5kYXJkfHNoYWRvdy1jYXN0ZXItdnM6dmVydHxzaGFkb3ctY2FzdGVyLWZzOmZyYWdcIiB9XSB9XHJcbiAgICBdLFxyXG4gICAgXCJzaGFkZXJzXCI6IFtcclxuICAgICAge1xyXG4gICAgICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tc3RhbmRhcmR8c3RhbmRhcmQtdnM6dmVydHxzdGFuZGFyZC1mczpmcmFnXCIsXHJcbiAgICAgICAgXCJoYXNoXCI6IDk2NzU1ODcwMixcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmhpZ2hwIGZsb2F0IGRlY29kZTMyIChoaWdocCB2ZWM0IHJnYmEpIHtcXG4gIHJnYmEgPSByZ2JhICogMjU1LjA7XFxuICBoaWdocCBmbG9hdCBTaWduID0gMS4wIC0gc3RlcCgxMjcuOTksIHJnYmFbM10pICogMi4wO1xcbiAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVszXSwgMTI3Ljk5KSArIHN0ZXAoMTI4LjAsIHJnYmFbMl0pIC0gMTI3LjA7XFxuICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IG1vZChyZ2JhWzJdLCAxMjguMCkgKiA2NTUzNi4wICsgcmdiYVsxXSAqIDI1Ni4wICsgcmdiYVswXSArIDgzODg2MDguMDtcXG4gIHJldHVybiBTaWduICogZXhwMihFeHBvbmVudCAtIDIzLjApICogTWFudGlzc2E7XFxufVxcbnN0cnVjdCBTdGFuZGFyZFZlcnRJbnB1dCB7XFxuICBoaWdocCB2ZWM0IHBvc2l0aW9uO1xcbiAgdmVjMyBub3JtYWw7XFxuICB2ZWM0IHRhbmdlbnQ7XFxufTtcXG5pbiB2ZWMzIGFfcG9zaXRpb247XFxuaW4gdmVjMyBhX25vcm1hbDtcXG5pbiB2ZWMyIGFfdGV4Q29vcmQ7XFxuaW4gdmVjNCBhX3RhbmdlbnQ7XFxuI2lmIENDX1VTRV9NT1JQSFxcbiAgICBpbnQgZ2V0VmVydGV4SWQoKSB7XFxuICAgICAgICByZXR1cm4gZ2xfVmVydGV4SUQ7XFxuICAgIH1cXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDTW9ycGgge1xcbiAgICB2ZWM0IGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbMTVdO1xcbiAgICB2ZWM0IGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvO1xcbn07XFxudmVjMiBnZXRQaXhlbExvY2F0aW9uKHZlYzIgdGV4dHVyZVJlc29sdXRpb24sIGludCBwaXhlbEluZGV4KSB7XFxuICAgIGZsb2F0IHBpeGVsSW5kZXhGID0gZmxvYXQocGl4ZWxJbmRleCk7XFxuICAgIGZsb2F0IHggPSBtb2QocGl4ZWxJbmRleEYsIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICBmbG9hdCB5ID0gZmxvb3IocGl4ZWxJbmRleEYgLyB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgcmV0dXJuIHZlYzIoeCwgeSk7XFxufVxcbnZlYzIgZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbih2ZWMyIGxvY2F0aW9uLCB2ZWMyIHRleHR1cmVSZXNvbHV0aW9uKSB7XFxuICAgIHJldHVybiAodmVjMihsb2NhdGlvbi54LCBsb2NhdGlvbi55KSArIC41KSAvIHRleHR1cmVSZXNvbHV0aW9uO1xcbn1cXG4jaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgICAgICB2ZWM0IGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IHBpeGVsSW5kZXgpIHtcXG4gICAgICAgICAgICBpdmVjMiB0ZXhTaXplID0gdGV4dHVyZVNpemUodGV4LCAwKTtcXG4gICAgICAgICAgICByZXR1cm4gdGV4ZWxGZXRjaCh0ZXgsIGl2ZWMyKHBpeGVsSW5kZXggJSB0ZXhTaXplLngsIHBpeGVsSW5kZXggLyB0ZXhTaXplLngpLCAwKTtcXG4gICAgICAgIH1cXG4jZWxzZVxcbiAgICB2ZWM0IGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IGVsZW1lbnRJbmRleCkge1xcbiAgICAgICAgaW50IHBpeGVsSW5kZXggPSBlbGVtZW50SW5kZXggKiA0O1xcbiAgICAgICAgdmVjMiBsb2NhdGlvbiA9IGdldFBpeGVsTG9jYXRpb24oY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHksIHBpeGVsSW5kZXgpO1xcbiAgICAgICAgdmVjMiB4ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMC4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICB2ZWMyIHkgPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigxLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHZlYzIgeiA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDIuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgcmV0dXJuIHZlYzQoXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZSh0ZXgsIHgpKSxcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKHRleCwgeSkpLFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUodGV4LCB6KSksXFxuICAgICAgICAgICAgMS4wXFxuICAgICAgICApO1xcbiAgICB9XFxuI2VuZGlmXFxuZmxvYXQgZ2V0RGlzcGxhY2VtZW50V2VpZ2h0KGludCBpbmRleCkge1xcbiAgICBmbG9hdCBtID0gbW9kKGZsb2F0KGluZGV4KSwgNC4wKTtcXG4gICAgaWYgKG0gPCAxLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueDtcXG4gICAgfSBlbHNlIGlmIChtIDwgMi4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnk7XFxuICAgIH0gZWxzZSBpZiAobSA8IDMuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS56O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS53O1xcbiAgICB9XFxufVxcbnZlYzMgZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCB2ZXJ0ZXhJbmRleCkge1xcbiNpZiBDQ19NT1JQSF9QUkVDT01QVVRFRFxcbiAgICByZXR1cm4gZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZSh0ZXgsIHZlcnRleEluZGV4KS5yZ2I7XFxuI2Vsc2VcXG4gICAgdmVjMyByZXN1bHQgPSB2ZWMzKDAsIDAsIDApO1xcbiAgICBmb3IgKGludCBpVGFyZ2V0ID0gMDsgaVRhcmdldCA8IENDX01PUlBIX1RBUkdFVF9DT1VOVDsgKytpVGFyZ2V0KSB7XFxuICAgICAgICBpbnQgZGF0YVBpeGVsU3RhcnQgPSBpbnQoZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZSh0ZXgsIGlUYXJnZXQpLnIpO1xcbiAgICAgICAgcmVzdWx0ICs9IChmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgZGF0YVBpeGVsU3RhcnQgKyB2ZXJ0ZXhJbmRleCkucmdiICogZ2V0RGlzcGxhY2VtZW50V2VpZ2h0KGlUYXJnZXQpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiNlbmRpZlxcbn1cXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX05vcm1hbERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19Ob3JtYWxEaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1RhbmdlbnREaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldFRhbmdlbnREaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1RhbmdlbnREaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gICAgaW50IHZlcnRleElkID0gZ2V0VmVydGV4SWQoKTtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBhdHRyLnBvc2l0aW9uLnh5eiA9IGF0dHIucG9zaXRpb24ueHl6ICsgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFxcbiAgICBhdHRyLm5vcm1hbC54eXogPSBhdHRyLm5vcm1hbC54eXogKyBnZXROb3JtYWxEaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgYXR0ci50YW5nZW50Lnh5eiA9IGF0dHIudGFuZ2VudC54eXogKyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG59XFxudm9pZCBhcHBseU1vcnBoIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgcG9zaXRpb24ueHl6ID0gcG9zaXRpb24ueHl6ICsgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoZ2V0VmVydGV4SWQoKSk7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbiNpZiBDQ19VU0VfU0tJTk5JTkdcXG5pbiB2ZWM0IGFfam9pbnRzO1xcbmluIHZlYzQgYV93ZWlnaHRzO1xcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgaW4gaGlnaHAgdmVjNCBhX2pvaW50QW5pbUluZm87XFxuICAjZW5kaWZcXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NTa2lubmluZ1RleHR1cmUge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50VGV4dHVyZUluZm87XFxuICB9O1xcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ1NraW5uaW5nQW5pbWF0aW9uIHtcXG4gICAgaGlnaHAgdmVjNCBjY19qb2ludEFuaW1JbmZvO1xcbiAgfTtcXG4gIHVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGNjX2pvaW50VGV4dHVyZTtcXG4gICNlbHNlXFxuICBsYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDU2tpbm5pbmcge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50c1szMCAqIDNdO1xcbiAgfTtcXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYyID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDMuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYyID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDUuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA2LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjMgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA4LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgOS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTEuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4jZWxzZVxcbiAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICBpbnQgaWR4ID0gaW50KGkpO1xcbiAgICB2ZWM0IHYxID0gY2Nfam9pbnRzW2lkeCAqIDNdO1xcbiAgICB2ZWM0IHYyID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAxXTtcXG4gICAgdmVjNCB2MyA9IGNjX2pvaW50c1tpZHggKiAzICsgMl07XFxuICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICB9XFxuI2VuZGlmXFxubWF0NCBza2luTWF0cml4ICgpIHtcXG4gIHJldHVybiBnZXRKb2ludE1hdHJpeChhX2pvaW50cy54KSAqIGFfd2VpZ2h0cy54XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueSkgKiBhX3dlaWdodHMueVxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnopICogYV93ZWlnaHRzLnpcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy53KSAqIGFfd2VpZ2h0cy53O1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgcG9zaXRpb24gPSBtICogcG9zaXRpb247XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBhdHRyLnBvc2l0aW9uID0gbSAqIGF0dHIucG9zaXRpb247XFxuICBhdHRyLm5vcm1hbCA9IChtICogdmVjNChhdHRyLm5vcm1hbCwgMC4wKSkueHl6O1xcbiAgYXR0ci50YW5nZW50Lnh5eiA9IChtICogdmVjNChhdHRyLnRhbmdlbnQueHl6LCAwLjApKS54eXo7XFxufVxcbiNlbmRpZlxcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbiNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgaW4gdmVjNCBhX21hdFdvcmxkMDtcXG4gIGluIHZlYzQgYV9tYXRXb3JsZDE7XFxuICBpbiB2ZWM0IGFfbWF0V29ybGQyO1xcbiAgI2lmIFVTRV9MSUdIVE1BUFxcbiAgICBpbiB2ZWM0IGFfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbiAgI2VuZGlmXFxuI2VsaWYgVVNFX0JBVENISU5HXFxuICBpbiBmbG9hdCBhX2R5bl9iYXRjaF9pZDtcXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NMb2NhbEJhdGNoZWQge1xcbiAgICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkc1sxMF07XFxuICB9O1xcbiNlbHNlXFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbiNlbmRpZlxcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ29uc3RhbnRzIHtcXG4gIHZlYzQgdGlsaW5nT2Zmc2V0O1xcbiAgdmVjNCBhbGJlZG87XFxuICB2ZWM0IGFsYmVkb1NjYWxlQW5kQ3V0b2ZmO1xcbiAgdmVjNCBwYnJQYXJhbXM7XFxuICB2ZWM0IGVtaXNzaXZlO1xcbiAgdmVjNCBlbWlzc2l2ZVNjYWxlUGFyYW07XFxufTtcXG5mbG9hdCBMaW5lYXJGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKTtcXG4gICAgZmxvYXQgZm9nU3RhcnQgPSBjY19mb2dCYXNlLng7XFxuICAgIGZsb2F0IGZvZ0VuZCA9IGNjX2ZvZ0Jhc2UueTtcXG4gICAgcmV0dXJuIGNsYW1wKChmb2dFbmQgLSBjYW1fZGlzKSAvIChmb2dFbmQgLSBmb2dTdGFydCksIDAuLCAxLik7XFxufVxcbmZsb2F0IEV4cEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IGZvZ0RlbnNpdHkgPSBjY19mb2dCYXNlLno7XFxuICAgIGZsb2F0IGNhbV9kaXMgPSBkaXN0YW5jZShjY19jYW1lcmFQb3MsIHdQb3MpIC8gZm9nQXR0ZW4gKiA0LjtcXG4gICAgZmxvYXQgZiA9IGV4cCgtY2FtX2RpcyAqIGZvZ0RlbnNpdHkpO1xcbiAgICByZXR1cm4gZjtcXG59XFxuZmxvYXQgRXhwU3F1YXJlZEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IGZvZ0RlbnNpdHkgPSBjY19mb2dCYXNlLno7XFxuICAgIGZsb2F0IGNhbV9kaXMgPSBkaXN0YW5jZShjY19jYW1lcmFQb3MsIHdQb3MpIC8gZm9nQXR0ZW4gKiA0LjtcXG4gICAgZmxvYXQgZiA9IGV4cCgtY2FtX2RpcyAqIGNhbV9kaXMgKiBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSk7XFxuICAgIHJldHVybiBmO1xcbn1cXG5mbG9hdCBMYXllcmVkRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgZm9nQXR0ZW4gPSBjY19mb2dBZGQuejtcXG4gICAgZmxvYXQgX0ZvZ1RvcCA9IGNjX2ZvZ0FkZC54O1xcbiAgICBmbG9hdCBfRm9nUmFuZ2UgPSBjY19mb2dBZGQueTtcXG4gICAgdmVjMyBjYW1Xb3JsZFByb2ogPSBjY19jYW1lcmFQb3MueHl6O1xcbiAgICBjYW1Xb3JsZFByb2oueSA9IDAuO1xcbiAgICB2ZWMzIHdvcmxkUG9zUHJvaiA9IHdQb3MueHl6O1xcbiAgICB3b3JsZFBvc1Byb2oueSA9IDAuO1xcbiAgICBmbG9hdCBmRGVsdGFEID0gZGlzdGFuY2Uod29ybGRQb3NQcm9qLCBjYW1Xb3JsZFByb2opIC8gZm9nQXR0ZW4gKiAyLjA7XFxuICAgIGZsb2F0IGZEZWx0YVksIGZEZW5zaXR5SW50ZWdyYWw7XFxuICAgIGlmIChjY19jYW1lcmFQb3MueSA+IF9Gb2dUb3ApIHtcXG4gICAgICAgIGlmICh3UG9zLnkgPCBfRm9nVG9wKSB7XFxuICAgICAgICAgICAgZkRlbHRhWSA9IChfRm9nVG9wIC0gd1Bvcy55KSAvIF9Gb2dSYW5nZSAqIDIuMDtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gZkRlbHRhWSAqIGZEZWx0YVkgKiAwLjU7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSAwLjtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gMC47XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAod1Bvcy55IDwgX0ZvZ1RvcCkge1xcbiAgICAgICAgICAgIGZsb2F0IGZEZWx0YUEgPSAoX0ZvZ1RvcCAtIGNjX2NhbWVyYVBvcy55KSAvIF9Gb2dSYW5nZSAqIDIuO1xcbiAgICAgICAgICAgIGZsb2F0IGZEZWx0YUIgPSAoX0ZvZ1RvcCAtIHdQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjtcXG4gICAgICAgICAgICBmRGVsdGFZID0gYWJzKGZEZWx0YUEgLSBmRGVsdGFCKTtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gYWJzKChmRGVsdGFBICogZkRlbHRhQSAqIDAuNSkgLSAoZkRlbHRhQiAqIGZEZWx0YUIgKiAwLjUpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZkRlbHRhWSA9IGFicyhfRm9nVG9wIC0gY2NfY2FtZXJhUG9zLnkpIC8gX0ZvZ1JhbmdlICogMi47XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGFicyhmRGVsdGFZICogZkRlbHRhWSAqIDAuNSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZmxvYXQgZkRlbnNpdHk7XFxuICAgIGlmIChmRGVsdGFZICE9IDAuKSB7XFxuICAgICAgICBmRGVuc2l0eSA9IChzcXJ0KDEuMCArICgoZkRlbHRhRCAvIGZEZWx0YVkpICogKGZEZWx0YUQgLyBmRGVsdGFZKSkpKSAqIGZEZW5zaXR5SW50ZWdyYWw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBmRGVuc2l0eSA9IDAuO1xcbiAgICB9XFxuICAgIGZsb2F0IGYgPSBleHAoLWZEZW5zaXR5KTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbmZsb2F0IENDX1RSQU5TRkVSX0ZPRyh2ZWM0IHBvcykge1xcbiAgICAjaWYgQ0NfVVNFX0ZPRyA9PSAxXFxuICAgICAgICByZXR1cm4gTGluZWFyRm9nKHBvcyk7XFxuXHQjZWxpZiBDQ19VU0VfRk9HID09IDJcXG4gICAgICAgIHJldHVybiBFeHBGb2cocG9zKTtcXG4gICAgI2VsaWYgQ0NfVVNFX0ZPRyA9PSAzXFxuICAgICAgICByZXR1cm4gRXhwU3F1YXJlZEZvZyhwb3MpO1xcbiAgICAjZWxpZiBDQ19VU0VfRk9HID09IDRcXG4gICAgICAgIHJldHVybiBMYXllcmVkRm9nKHBvcyk7XFxuICAgICNlbmRpZlxcbiAgICByZXR1cm4gMS47XFxufVxcbm91dCB2ZWM0IHZfc2hhZG93UG9zO1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NTaGFkb3cge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFBsYW5lUHJvajtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0TGlnaHRWaWV3UHJvajtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dDb2xvcjtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dQQ0Y7XFxuICBsb3dwIHZlYzQgY2Nfc2hhZG93U2l6ZTtcXG59O1xcbiNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICBpbiB2ZWMzIGFfY29sb3I7XFxuICBvdXQgdmVjMyB2X2NvbG9yO1xcbiNlbmRpZlxcbm91dCB2ZWMzIHZfcG9zaXRpb247XFxub3V0IHZlYzMgdl9ub3JtYWw7XFxub3V0IHZlYzIgdl91djtcXG5vdXQgdmVjMiB2X3V2MTtcXG5vdXQgZmxvYXQgdl9mb2dfZmFjdG9yO1xcbiNpZiBVU0VfTk9STUFMX01BUFxcbiAgb3V0IHZlYzMgdl90YW5nZW50O1xcbiAgb3V0IHZlYzMgdl9iaXRhbmdlbnQ7XFxuI2VuZGlmXFxuI2lmIEhBU19TRUNPTkRfVVYgfHwgVVNFX0xJR0hUTUFQXFxuICBpbiB2ZWMyIGFfdGV4Q29vcmQxO1xcbiNlbmRpZlxcbiNpZiBVU0VfTElHSFRNQVAgJiYgIVVTRV9CQVRDSElORyAmJiAhQ0NfRk9SV0FSRF9BRERcXG4gIG91dCB2ZWMyIHZfbHV2O1xcbnZvaWQgQ0NMaWdodGluZ01hcENhY2xVVigpXFxue1xcbiNpZiAhVVNFX0lOU1RBTkNJTkdcXG4gICAgICB2X2x1diA9IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbS54eSArIGFfdGV4Q29vcmQxICogY2NfbGlnaHRpbmdNYXBVVlBhcmFtLnp3O1xcbiNlbHNlXFxuICAgICAgdl9sdXYgPSBhX2xpZ2h0aW5nTWFwVVZQYXJhbS54eSArIGFfdGV4Q29vcmQxICogYV9saWdodGluZ01hcFVWUGFyYW0uenc7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbnZlYzQgdmVydCAoKSB7XFxuICBTdGFuZGFyZFZlcnRJbnB1dCBJbjtcXG4gIEluLnBvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xcbiAgSW4ubm9ybWFsID0gYV9ub3JtYWw7XFxuICBJbi50YW5nZW50ID0gYV90YW5nZW50O1xcbiAgI2lmIENDX1VTRV9NT1JQSFxcbiAgICBhcHBseU1vcnBoKEluKTtcXG4gICNlbmRpZlxcbiAgI2lmIENDX1VTRV9TS0lOTklOR1xcbiAgICBDQ1NraW4oSW4pO1xcbiAgI2VuZGlmXFxuICBtYXQ0IG1hdFdvcmxkLCBtYXRXb3JsZElUO1xcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIG1hdFdvcmxkID0gbWF0NChcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQwLnh5eiwgMC4wKSxcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQxLnh5eiwgMC4wKSxcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQyLnh5eiwgMC4wKSxcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQwLncsIGFfbWF0V29ybGQxLncsIGFfbWF0V29ybGQyLncsIDEuMClcXG4gICAgKTtcXG4gICAgbWF0V29ybGRJVCA9IG1hdFdvcmxkO1xcbiAgI2VsaWYgVVNFX0JBVENISU5HXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGRzW2ludChhX2R5bl9iYXRjaF9pZCldO1xcbiAgICBtYXRXb3JsZElUID0gbWF0V29ybGQ7XFxuICAjZWxzZVxcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkO1xcbiAgICBtYXRXb3JsZElUID0gY2NfbWF0V29ybGRJVDtcXG4gICNlbmRpZlxcbiAgdmVjNCBwb3MgPSBtYXRXb3JsZCAqIEluLnBvc2l0aW9uO1xcbiAgdl9wb3NpdGlvbiA9IHBvcy54eXo7XFxuICB2X25vcm1hbCA9IG5vcm1hbGl6ZSgobWF0V29ybGRJVCAqIHZlYzQoSW4ubm9ybWFsLCAwLjApKS54eXopO1xcbiAgI2lmIFVTRV9OT1JNQUxfTUFQXFxuICAgIHZfdGFuZ2VudCA9IG5vcm1hbGl6ZSgobWF0V29ybGQgKiB2ZWM0KEluLnRhbmdlbnQueHl6LCAwLjApKS54eXopO1xcbiAgICB2X2JpdGFuZ2VudCA9IGNyb3NzKHZfbm9ybWFsLCB2X3RhbmdlbnQpICogSW4udGFuZ2VudC53O1xcbiAgI2VuZGlmXFxuICB2X3V2ID0gYV90ZXhDb29yZCAqIHRpbGluZ09mZnNldC54eSArIHRpbGluZ09mZnNldC56dztcXG4gICNpZiBIQVNfU0VDT05EX1VWXFxuICAgIHZfdXYxID0gYV90ZXhDb29yZDEgKiB0aWxpbmdPZmZzZXQueHkgKyB0aWxpbmdPZmZzZXQuenc7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuICB2X2ZvZ19mYWN0b3IgPSBDQ19UUkFOU0ZFUl9GT0cobWF0V29ybGQgKiBJbi5wb3NpdGlvbik7XFxuICAjaWYgVVNFX0xJR0hUTUFQICYmICFVU0VfQkFUQ0hJTkcgJiYgIUNDX0ZPUldBUkRfQUREXFxuICAgIENDTGlnaHRpbmdNYXBDYWNsVVYoKTtcXG4gICNlbmRpZlxcbiAgICB2X3NoYWRvd1BvcyA9IGNjX21hdExpZ2h0Vmlld1Byb2ogKiBwb3M7XFxuICByZXR1cm4gY2NfbWF0UHJvaiAqIChjY19tYXRWaWV3ICogbWF0V29ybGQpICogSW4ucG9zaXRpb247XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ1NoYWRvdyB7XFxuICBoaWdocCBtYXQ0IGNjX21hdExpZ2h0UGxhbmVQcm9qO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFZpZXdQcm9qO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd0NvbG9yO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd1BDRjtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dTaXplO1xcbn07XFxuI2lmIENDX1VTRV9JQkxcXG51bmlmb3JtIHNhbXBsZXJDdWJlIGNjX2Vudmlyb25tZW50O1xcbnZlYzMgdW5wYWNrUkdCRSAodmVjNCByZ2JlKSB7XFxuICByZXR1cm4gcmdiZS5yZ2IgKiBwb3coMi4wLCByZ2JlLmEgKiAyNTUuMCAtIDEyOC4wKTtcXG59XFxudmVjNCBmcmFnVGV4dHVyZUxvZCAoc2FtcGxlcjJEIHRleCwgdmVjMiBjb29yZCwgZmxvYXQgbG9kKSB7XFxuICAgIHJldHVybiB0ZXh0dXJlTG9kKHRleCwgY29vcmQsIGxvZCk7XFxufVxcbnZlYzQgZnJhZ1RleHR1cmVMb2QgKHNhbXBsZXJDdWJlIHRleCwgdmVjMyBjb29yZCwgZmxvYXQgbG9kKSB7XFxuICAgIHJldHVybiB0ZXh0dXJlTG9kKHRleCwgY29vcmQsIGxvZCk7XFxufVxcbiNlbmRpZlxcbiNpZiBVU0VfTElHSFRNQVAgJiYgIVVTRV9CQVRDSElORyAmJiAhQ0NfRk9SV0FSRF9BRERcXG4gIGluIHZlYzIgdl9sdXY7XFxudW5pZm9ybSBzYW1wbGVyMkQgY2NfbGlnaHRpbmdNYXA7XFxuI2VuZGlmXFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG5mbG9hdCBHR1hNb2JpbGUgKGZsb2F0IHJvdWdobmVzcywgZmxvYXQgTm9ILCB2ZWMzIEgsIHZlYzMgTikge1xcbiAgdmVjMyBOeEggPSBjcm9zcyhOLCBIKTtcXG4gIGZsb2F0IE9uZU1pbnVzTm9IU3FyID0gZG90KE54SCwgTnhIKTtcXG4gIGZsb2F0IGEgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XFxuICBmbG9hdCBuID0gTm9IICogYTtcXG4gIGZsb2F0IHAgPSBhIC8gKE9uZU1pbnVzTm9IU3FyICsgbiAqIG4pO1xcbiAgcmV0dXJuIHAgKiBwO1xcbn1cXG5mbG9hdCBDYWxjU3BlY3VsYXIgKGZsb2F0IHJvdWdobmVzcywgZmxvYXQgTm9ILCB2ZWMzIEgsIHZlYzMgTikge1xcbiAgcmV0dXJuIChyb3VnaG5lc3MqMC4yNSArIDAuMjUpICogR0dYTW9iaWxlKHJvdWdobmVzcywgTm9ILCBILCBOKTtcXG59XFxudmVjMyBCUkRGQXBwcm94ICh2ZWMzIHNwZWN1bGFyLCBmbG9hdCByb3VnaG5lc3MsIGZsb2F0IE5vVikge1xcbiAgY29uc3QgdmVjNCBjMCA9IHZlYzQoLTEuMCwgLTAuMDI3NSwgLTAuNTcyLCAwLjAyMik7XFxuICBjb25zdCB2ZWM0IGMxID0gdmVjNCgxLjAsIDAuMDQyNSwgMS4wNCwgLTAuMDQpO1xcbiAgdmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcXG4gIGZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLTkuMjggKiBOb1YgKSApICogci54ICsgci55O1xcbiAgdmVjMiBBQiA9IHZlYzIoIC0xLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcXG4gIEFCLnkgKj0gY2xhbXAoNTAuMCAqIHNwZWN1bGFyLmcsIDAuMCwgMS4wKTtcXG4gIHJldHVybiBzcGVjdWxhciAqIEFCLnggKyBBQi55O1xcbn1cXG5zdHJ1Y3QgU3RhbmRhcmRTdXJmYWNlIHtcXG4gIHZlYzQgYWxiZWRvO1xcbiAgdmVjMyBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjMyBlbWlzc2l2ZTtcXG4gIGZsb2F0IHJvdWdobmVzcztcXG4gIGZsb2F0IG1ldGFsbGljO1xcbiAgZmxvYXQgb2NjbHVzaW9uO1xcbn07XFxuI2lmIENDX0ZPUldBUkRfQUREXFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0ZvcndhcmRMaWdodCB7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0UG9zWzFdO1xcbiAgdmVjNCBjY19saWdodENvbG9yWzFdO1xcbiAgdmVjNCBjY19saWdodFNpemVSYW5nZUFuZ2xlWzFdO1xcbiAgdmVjNCBjY19saWdodERpclsxXTtcXG59O1xcbmZsb2F0IFNtb290aERpc3RBdHQgKGZsb2F0IGRpc3RTcXIsIGZsb2F0IGludlNxckF0dFJhZGl1cykge1xcbiAgZmxvYXQgZmFjdG9yID0gZGlzdFNxciAqIGludlNxckF0dFJhZGl1cztcXG4gIGZsb2F0IHNtb290aEZhY3RvciA9IGNsYW1wKDEuMCAtIGZhY3RvciAqIGZhY3RvciwgMC4wLCAxLjApO1xcbiAgcmV0dXJuIHNtb290aEZhY3RvciAqIHNtb290aEZhY3RvcjtcXG59XFxuZmxvYXQgR2V0RGlzdEF0dCAoZmxvYXQgZGlzdFNxciwgZmxvYXQgaW52U3FyQXR0UmFkaXVzKSB7XFxuICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMCAvIG1heChkaXN0U3FyLCAwLjAxKjAuMDEpO1xcbiAgYXR0ZW51YXRpb24gKj0gU21vb3RoRGlzdEF0dChkaXN0U3FyICwgaW52U3FyQXR0UmFkaXVzKTtcXG4gIHJldHVybiBhdHRlbnVhdGlvbjtcXG59XFxuZmxvYXQgR2V0QW5nbGVBdHQgKHZlYzMgTCwgdmVjMyBsaXREaXIsIGZsb2F0IGxpdEFuZ2xlU2NhbGUsIGZsb2F0IGxpdEFuZ2xlT2Zmc2V0KSB7XFxuICBmbG9hdCBjZCA9IGRvdChsaXREaXIsIEwpO1xcbiAgZmxvYXQgYXR0ZW51YXRpb24gPSBjbGFtcChjZCAqIGxpdEFuZ2xlU2NhbGUgKyBsaXRBbmdsZU9mZnNldCwgMC4wLCAxLjApO1xcbiAgcmV0dXJuIChhdHRlbnVhdGlvbiAqIGF0dGVudWF0aW9uKTtcXG59XFxuICB2ZWM0IENDU3RhbmRhcmRTaGFkaW5nIChTdGFuZGFyZFN1cmZhY2Ugcykge1xcbiAgICB2ZWMzIGRpZmZ1c2UgPSBzLmFsYmVkby5yZ2IgKiAoMS4wIC0gcy5tZXRhbGxpYyk7XFxuICAgIHZlYzMgc3BlY3VsYXIgPSBtaXgodmVjMygwLjA0KSwgcy5hbGJlZG8ucmdiLCBzLm1ldGFsbGljKTtcXG4gICAgdmVjMyBkaWZmdXNlQ29udHJpYiA9IGRpZmZ1c2UgLyAzLjE0MTU5MjY1MzU5O1xcbiAgICB2ZWMzIE4gPSBub3JtYWxpemUocy5ub3JtYWwpO1xcbiAgICB2ZWMzIFYgPSBub3JtYWxpemUoY2NfY2FtZXJhUG9zLnh5eiAtIHMucG9zaXRpb24pO1xcbiAgICBmbG9hdCBOViA9IG1heChhYnMoZG90KE4sIFYpKSwgMC4wMDEpO1xcbiAgICBzcGVjdWxhciA9IEJSREZBcHByb3goc3BlY3VsYXIsIHMucm91Z2huZXNzLCBOVik7XFxuICAgIHZlYzMgZmluYWxDb2xvciA9IHZlYzMoMC4wKTtcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAxOyBpKyspIHtcXG4gICAgICB2ZWMzIFNMVSA9IGNjX2xpZ2h0UG9zW2ldLnh5eiAtIHMucG9zaXRpb247XFxuICAgICAgdmVjMyBTTCA9IG5vcm1hbGl6ZShTTFUpO1xcbiAgICAgIHZlYzMgU0ggPSBub3JtYWxpemUoU0wgKyBWKTtcXG4gICAgICBmbG9hdCBTTkwgPSBtYXgoZG90KE4sIFNMKSwgMC4wMDEpO1xcbiAgICAgIGZsb2F0IFNOSCA9IG1heChkb3QoTiwgU0gpLCAwLjApO1xcbiAgICAgIGZsb2F0IGRpc3RTcXIgPSBkb3QoU0xVLCBTTFUpO1xcbiAgICAgIGZsb2F0IGxpdFJhZGl1cyA9IGNjX2xpZ2h0U2l6ZVJhbmdlQW5nbGVbaV0ueDtcXG4gICAgICBmbG9hdCBsaXRSYWRpdXNTcXIgPSBsaXRSYWRpdXMgKiBsaXRSYWRpdXM7XFxuICAgICAgZmxvYXQgaWxsdW0gPSAzLjE0MTU5MjY1MzU5ICogKGxpdFJhZGl1c1NxciAvIG1heChsaXRSYWRpdXNTcXIgLCBkaXN0U3FyKSk7XFxuICAgICAgZmxvYXQgYXR0UmFkaXVzU3FySW52ID0gMS4wIC8gbWF4KGNjX2xpZ2h0U2l6ZVJhbmdlQW5nbGVbaV0ueSwgMC4wMSk7XFxuICAgICAgYXR0UmFkaXVzU3FySW52ICo9IGF0dFJhZGl1c1NxckludjtcXG4gICAgICBmbG9hdCBhdHQgPSBHZXREaXN0QXR0KGRpc3RTcXIsIGF0dFJhZGl1c1Nxckludik7XFxuICAgICAgdmVjMyBsc3BlYyA9IHNwZWN1bGFyICogQ2FsY1NwZWN1bGFyKHMucm91Z2huZXNzLCBTTkgsIFNILCBOKTtcXG4gICAgICBpZiAoY2NfbGlnaHRQb3NbaV0udyA+IDAuMCkge1xcbiAgICAgICAgZmxvYXQgY29zSW5uZXIgPSBtYXgoZG90KC1jY19saWdodERpcltpXS54eXosIFNMKSwgMC4wMSk7XFxuICAgICAgICBmbG9hdCBjb3NPdXRlciA9IGNjX2xpZ2h0U2l6ZVJhbmdlQW5nbGVbaV0uejtcXG4gICAgICAgIGZsb2F0IGxpdEFuZ2xlU2NhbGUgPSAxLjAgLyBtYXgoMC4wMDEsIGNvc0lubmVyIC0gY29zT3V0ZXIpO1xcbiAgICAgICAgZmxvYXQgbGl0QW5nbGVPZmZzZXQgPSAtY29zT3V0ZXIgKiBsaXRBbmdsZVNjYWxlO1xcbiAgICAgICAgYXR0ICo9IEdldEFuZ2xlQXR0KFNMLCAtY2NfbGlnaHREaXJbaV0ueHl6LCBsaXRBbmdsZVNjYWxlLCBsaXRBbmdsZU9mZnNldCk7XFxuICAgICAgfVxcbiAgICAgIGZpbmFsQ29sb3IgKz0gU05MICogY2NfbGlnaHRDb2xvcltpXS5yZ2IgKiBjY19saWdodENvbG9yW2ldLncgKiBpbGx1bSAqIGF0dCAqIChkaWZmdXNlQ29udHJpYiArIGxzcGVjKTtcXG4gICAgfVxcbiAgICBmaW5hbENvbG9yID0gZmluYWxDb2xvciAqIHMub2NjbHVzaW9uO1xcbiAgICByZXR1cm4gdmVjNChmaW5hbENvbG9yLCAwLjApO1xcbiAgfVxcbiNlbHNlXFxuICAjaWYgQ0NfUkVDRUlWRV9TSEFET1dcXG5pbiB2ZWM0IHZfc2hhZG93UG9zO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGNjX3NoYWRvd01hcDtcXG52ZWM0IENDR2V0U2hhZG93RmFjdG9yWDEgKCkge1xcbiAgdmVjMyBjbGlwUG9zID0gdl9zaGFkb3dQb3MueHl6IC8gdl9zaGFkb3dQb3MudyAqIDAuNSArIDAuNTtcXG4gIGZsb2F0IGRlcHRoID0gZG90KHRleHR1cmUoY2Nfc2hhZG93TWFwLCBjbGlwUG9zLnh5KSwgdmVjNCgxLjAsIDEuMCAvIDI1NS4wLCAxLjAgLyA2NTAyNS4wLCAxLjAgLyAxNjA1ODEzNzUuMCkpO1xcbiAgaWYgKGRlcHRoIDwgKGNsaXBQb3MueiAtIDAuMDAxKSkgcmV0dXJuIGNjX3NoYWRvd0NvbG9yO1xcbiAgZWxzZSByZXR1cm4gdmVjNCgwKTtcXG59XFxudmVjNCBDQ0dldFNoYWRvd0ZhY3Rvclg1ICgpIHtcXG4gIHZlYzMgY2xpcFBvcyA9IHZfc2hhZG93UG9zLnh5eiAvIHZfc2hhZG93UG9zLncgKiAwLjUgKyAwLjU7XFxuICBmbG9hdCBvZmZzZXR4ID0gMS4wIC8gY2Nfc2hhZG93U2l6ZS54O1xcbiAgZmxvYXQgb2Zmc2V0eSA9IDEuMCAvIGNjX3NoYWRvd1NpemUueTtcXG4gIGZsb2F0IGRlcHRoID0gMC4wO1xcbiAgZGVwdGggKz0gZG90KHRleHR1cmUoY2Nfc2hhZG93TWFwLCB2ZWMyKGNsaXBQb3MueCAtIG9mZnNldHgsIGNsaXBQb3MueSAtIG9mZnNldHkpKSwgdmVjNCgxLjAsIDEuMCAvIDI1NS4wLCAxLjAgLyA2NTAyNS4wLCAxLjAgLyAxNjA1ODEzNzUuMCkpO1xcbiAgZGVwdGggKz0gZG90KHRleHR1cmUoY2Nfc2hhZG93TWFwLCB2ZWMyKGNsaXBQb3MueCAtIG9mZnNldHgsIGNsaXBQb3MueSArIG9mZnNldHkpKSwgdmVjNCgxLjAsIDEuMCAvIDI1NS4wLCAxLjAgLyA2NTAyNS4wLCAxLjAgLyAxNjA1ODEzNzUuMCkpO1xcbiAgZGVwdGggKz0gZG90KHRleHR1cmUoY2Nfc2hhZG93TWFwLCB2ZWMyKGNsaXBQb3MueCwgY2xpcFBvcy55KSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gIGRlcHRoICs9IGRvdCh0ZXh0dXJlKGNjX3NoYWRvd01hcCwgdmVjMihjbGlwUG9zLnggKyBvZmZzZXR4LCBjbGlwUG9zLnkgLSBvZmZzZXR5KSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gIGRlcHRoICs9IGRvdCh0ZXh0dXJlKGNjX3NoYWRvd01hcCwgdmVjMihjbGlwUG9zLnggKyBvZmZzZXR4LCBjbGlwUG9zLnkgKyBvZmZzZXR5KSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gIGRlcHRoIC89IDUuMDtcXG4gIGlmIChkZXB0aCA8IChjbGlwUG9zLnogLSAwLjAwMSkpIHJldHVybiBjY19zaGFkb3dDb2xvcjtcXG4gIGVsc2UgcmV0dXJuIHZlYzQoMCk7XFxufVxcbnZlYzQgQ0NHZXRTaGFkb3dGYWN0b3JYOSAoKSB7XFxuICB2ZWMzIGNsaXBQb3MgPSB2X3NoYWRvd1Bvcy54eXogLyB2X3NoYWRvd1Bvcy53ICogMC41ICsgMC41O1xcbiAgZmxvYXQgb2Zmc2V0eCA9IDEuMCAvIGNjX3NoYWRvd1NpemUueDtcXG4gIGZsb2F0IG9mZnNldHkgPSAxLjAgLyBjY19zaGFkb3dTaXplLnk7XFxuICBmbG9hdCBkZXB0aCA9IDAuMDtcXG4gIGZvciAoaW50IGkgPSAtMTsgaSA8PSAxOyBpKyspIHtcXG4gICAgZm9yIChpbnQgaiA9IC0xOyBqIDw9IDE7IGorKykge1xcbiAgICAgIGRlcHRoICs9IGRvdCh0ZXh0dXJlKGNjX3NoYWRvd01hcCwgY2xpcFBvcy54eSArIHZlYzIoaSwgaikgKiB2ZWMyKG9mZnNldHgsIG9mZnNldHkpKSwgdmVjNCgxLjAsIDEuMCAvIDI1NS4wLCAxLjAgLyA2NTAyNS4wLCAxLjAgLyAxNjA1ODEzNzUuMCkpO1xcbiAgICB9XFxuICB9XFxuICBkZXB0aCAvPSA5LjA7XFxuICBpZiAoZGVwdGggPCAoY2xpcFBvcy56IC0gMC4wMDEpKSByZXR1cm4gY2Nfc2hhZG93Q29sb3I7XFxuICBlbHNlIHJldHVybiB2ZWM0KDApO1xcbn1cXG52ZWM0IENDR2V0U2hhZG93RmFjdG9yWDI1ICgpIHtcXG4gIHZlYzMgY2xpcFBvcyA9IHZfc2hhZG93UG9zLnh5eiAvIHZfc2hhZG93UG9zLncgKiAwLjUgKyAwLjU7XFxuICBmbG9hdCBvZmZzZXR4ID0gMS4wIC8gY2Nfc2hhZG93U2l6ZS54O1xcbiAgZmxvYXQgb2Zmc2V0eSA9IDEuMCAvIGNjX3NoYWRvd1NpemUueTtcXG4gIGZsb2F0IGRlcHRoID0gMC4wO1xcbiAgZm9yIChpbnQgaSA9IC0yOyBpIDw9IDI7IGkrKykge1xcbiAgICBmb3IgKGludCBqID0gLTI7IGogPD0gMjsgaisrKSB7XFxuICAgICAgZGVwdGggKz0gZG90KHRleHR1cmUoY2Nfc2hhZG93TWFwLCBjbGlwUG9zLnh5ICsgdmVjMihpLCBqKSAqIHZlYzIob2Zmc2V0eCwgb2Zmc2V0eSkpLCB2ZWM0KDEuMCwgMS4wIC8gMjU1LjAsIDEuMCAvIDY1MDI1LjAsIDEuMCAvIDE2MDU4MTM3NS4wKSk7XFxuICAgIH1cXG4gIH1cXG4gIGRlcHRoIC89IDI1LjA7XFxuICBpZiAoZGVwdGggPCAoY2xpcFBvcy56IC0gMC4wMDEpKSByZXR1cm4gY2Nfc2hhZG93Q29sb3I7XFxuICBlbHNlIHJldHVybiB2ZWM0KDApO1xcbn1cXG4gICNlbmRpZlxcbiAgdmVjNCBDQ1N0YW5kYXJkU2hhZGluZyAoU3RhbmRhcmRTdXJmYWNlIHMpIHtcXG4gICAgdmVjMyBkaWZmdXNlID0gcy5hbGJlZG8ucmdiICogKDEuMCAtIHMubWV0YWxsaWMpO1xcbiAgICB2ZWMzIHNwZWN1bGFyID0gbWl4KHZlYzMoMC4wNCksIHMuYWxiZWRvLnJnYiwgcy5tZXRhbGxpYyk7XFxuICAgIHZlYzMgTiA9IG5vcm1hbGl6ZShzLm5vcm1hbCk7XFxuICAgIHZlYzMgViA9IG5vcm1hbGl6ZShjY19jYW1lcmFQb3MueHl6IC0gcy5wb3NpdGlvbik7XFxuICAgIGZsb2F0IE5WID0gbWF4KGFicyhkb3QoTiwgVikpLCAwLjAwMSk7XFxuICAgIHNwZWN1bGFyID0gQlJERkFwcHJveChzcGVjdWxhciwgcy5yb3VnaG5lc3MsIE5WKTtcXG4gICAgdmVjMyBMID0gbm9ybWFsaXplKC1jY19tYWluTGl0RGlyLnh5eik7XFxuICAgIHZlYzMgSCA9IG5vcm1hbGl6ZShMK1YpO1xcbiAgICBmbG9hdCBOSCA9IG1heChkb3QoTiwgSCksIDAuMCk7XFxuICAgIGZsb2F0IE5MID0gbWF4KGRvdChOLCBMKSwgMC4wMDEpO1xcbiAgICB2ZWMzIGZpbmFsQ29sb3IgPSBOTCAqIGNjX21haW5MaXRDb2xvci5yZ2IgKiBjY19tYWluTGl0Q29sb3IudztcXG4gICAgI2lmIFVTRV9MSUdIVE1BUCAmJiAhVVNFX0JBVENISU5HICYmICFDQ19GT1JXQVJEX0FERFxcbiAgICAgIHZlYzQgbGlnaHRtYXAgPSB0ZXh0dXJlKGNjX2xpZ2h0aW5nTWFwLCB2X2x1dik7XFxuICAgICAgZmluYWxDb2xvciA9IGxpZ2h0bWFwLmEgKiBsaWdodG1hcC5yZ2IgKyAoMS4wIC0gbGlnaHRtYXAuYSkgKiBmaW5hbENvbG9yO1xcbiAgICAjZW5kaWZcXG4gICAgdmVjMyBkaWZmdXNlQ29udHJpYiA9IGRpZmZ1c2UgLyAzLjE0MTU5MjY1MzU5O1xcbiAgICB2ZWMzIHNwZWN1bGFyQ29udHJpYiA9IHNwZWN1bGFyICogQ2FsY1NwZWN1bGFyKHMucm91Z2huZXNzLCBOSCwgSCwgTik7XFxuICAgIGZpbmFsQ29sb3IgKj0gKGRpZmZ1c2VDb250cmliICsgc3BlY3VsYXJDb250cmliKTtcXG4gICAgZmxvYXQgZkFtYiA9IDAuNSAtIE4ueSAqIDAuNTtcXG4gICAgdmVjMyBhbWJEaWZmID0gbWl4KGNjX2FtYmllbnRTa3kucmdiLCBjY19hbWJpZW50R3JvdW5kLnJnYiwgZkFtYikgKiBjY19hbWJpZW50U2t5Lnc7XFxuICAgIGZpbmFsQ29sb3IgKz0gKGFtYkRpZmYucmdiICogZGlmZnVzZSk7XFxuICAgICNpZiBDQ19VU0VfSUJMXFxuICAgICAgdmVjMyBSID0gbm9ybWFsaXplKHJlZmxlY3QoLVYsIE4pKTtcXG4gICAgICB2ZWM0IGVudm1hcCA9IGZyYWdUZXh0dXJlTG9kKGNjX2Vudmlyb25tZW50LCBSLCBzLnJvdWdobmVzcyAqIGNjX2FtYmllbnRHcm91bmQudyk7XFxuICAgICAgI2lmIENDX1VTRV9JQkwgPT0gMlxcbiAgICAgICAgdmVjMyBlbnYgPSB1bnBhY2tSR0JFKGVudm1hcCk7XFxuICAgICAgI2Vsc2VcXG4gICAgICAgIHZlYzMgZW52ID0gU1JHQlRvTGluZWFyKGVudm1hcC5yZ2IpO1xcbiAgICAgICNlbmRpZlxcbiAgICAgIGZpbmFsQ29sb3IgKz0gZW52ICogY2NfYW1iaWVudFNreS53ICogc3BlY3VsYXI7XFxuICAgICNlbmRpZlxcbiAgICBmaW5hbENvbG9yID0gZmluYWxDb2xvciAqIHMub2NjbHVzaW9uO1xcbiAgICAjaWYgQ0NfVVNFX0hEUlxcbiAgICAgIHMuZW1pc3NpdmUgKj0gY2NfZXhwb3N1cmUudztcXG4gICAgI2VuZGlmXFxuICAgIGZpbmFsQ29sb3IgKz0gcy5lbWlzc2l2ZTtcXG4gICAgI2lmIENDX1JFQ0VJVkVfU0hBRE9XXFxuICAgICAgdmVjNCBzaGFkb3cgPSB2ZWM0KDEuMCk7XFxuICAgICAgZmxvYXQgcGNmID0gY2Nfc2hhZG93UENGLnggKyAwLjAwMTtcXG4gICAgICBpZiAocGNmID4gMy4wKSB7c2hhZG93ID0gQ0NHZXRTaGFkb3dGYWN0b3JYMjUoKTt9XFxuICAgICAgZWxzZSBpZiAoMy4wID4gcGNmICYmIHBjZiA+IDIuMCkge3NoYWRvdyA9IENDR2V0U2hhZG93RmFjdG9yWDkoKTt9XFxuICAgICAgZWxzZSBpZiAoMi4wID4gcGNmICYmIHBjZiA+IDEuMCkge3NoYWRvdyA9IENDR2V0U2hhZG93RmFjdG9yWDUoKTt9XFxuICAgICAgZWxzZSB7c2hhZG93ID0gQ0NHZXRTaGFkb3dGYWN0b3JYMSgpO31cXG4gICAgICBmaW5hbENvbG9yID0gc2hhZG93LnJnYiAqIHNoYWRvdy5hICsgZmluYWxDb2xvciAqICgxLjAgLSBzaGFkb3cuYSk7XFxuICAgICNlbmRpZlxcbiAgICByZXR1cm4gdmVjNChmaW5hbENvbG9yLCBzLmFsYmVkby5hKTtcXG4gIH1cXG4jZW5kaWZcXG52ZWMzIEFDRVNUb25lTWFwICh2ZWMzIGNvbG9yKSB7XFxuICBjb2xvciA9IG1pbihjb2xvciwgdmVjMyg4LjApKTtcXG4gIGNvbnN0IGZsb2F0IEEgPSAyLjUxO1xcbiAgY29uc3QgZmxvYXQgQiA9IDAuMDM7XFxuICBjb25zdCBmbG9hdCBDID0gMi40MztcXG4gIGNvbnN0IGZsb2F0IEQgPSAwLjU5O1xcbiAgY29uc3QgZmxvYXQgRSA9IDAuMTQ7XFxuICByZXR1cm4gKGNvbG9yICogKEEgKiBjb2xvciArIEIpKSAvIChjb2xvciAqIChDICogY29sb3IgKyBEKSArIEUpO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmICFDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IHNxcnQoQUNFU1RvbmVNYXAoY29sb3IucmdiKSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDb25zdGFudHMge1xcbiAgdmVjNCB0aWxpbmdPZmZzZXQ7XFxuICB2ZWM0IGFsYmVkbztcXG4gIHZlYzQgYWxiZWRvU2NhbGVBbmRDdXRvZmY7XFxuICB2ZWM0IHBiclBhcmFtcztcXG4gIHZlYzQgZW1pc3NpdmU7XFxuICB2ZWM0IGVtaXNzaXZlU2NhbGVQYXJhbTtcXG59O1xcbmluIHZlYzMgdl9wb3NpdGlvbjtcXG5pbiB2ZWMyIHZfdXY7XFxuaW4gdmVjMiB2X3V2MTtcXG5pbiB2ZWMzIHZfbm9ybWFsO1xcbmluIGZsb2F0IHZfZm9nX2ZhY3RvcjtcXG4jaWYgVVNFX1ZFUlRFWF9DT0xPUlxcbiAgaW4gdmVjMyB2X2NvbG9yO1xcbiNlbmRpZlxcbiNpZiBVU0VfQUxCRURPX01BUFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgYWxiZWRvTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfTk9STUFMX01BUFxcbiAgaW4gdmVjMyB2X3RhbmdlbnQ7XFxuICBpbiB2ZWMzIHZfYml0YW5nZW50O1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfUEJSX01BUFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgcGJyTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfTUVUQUxMSUNfUk9VR0hORVNTX01BUFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxsaWNSb3VnaG5lc3NNYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9PQ0NMVVNJT05fTUFQXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9FTUlTU0lWRV9NQVBcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfQUxQSEFfVEVTVFxcbiNlbmRpZlxcbnZvaWQgc3VyZiAob3V0IFN0YW5kYXJkU3VyZmFjZSBzKSB7XFxuICB2ZWM0IGJhc2VDb2xvciA9IGFsYmVkbztcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIGJhc2VDb2xvci5yZ2IgKj0gdl9jb2xvcjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTEJFRE9fTUFQXFxuICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlKGFsYmVkb01hcCwgQUxCRURPX1VWKTtcXG4gICAgdGV4Q29sb3IucmdiID0gU1JHQlRvTGluZWFyKHRleENvbG9yLnJnYik7XFxuICAgIGJhc2VDb2xvciAqPSB0ZXhDb2xvcjtcXG4gICNlbmRpZlxcbiAgcy5hbGJlZG8gPSBiYXNlQ29sb3I7XFxuICBzLmFsYmVkby5yZ2IgKj0gYWxiZWRvU2NhbGVBbmRDdXRvZmYueHl6O1xcbiAgI2lmIFVTRV9BTFBIQV9URVNUXFxuICAgIGlmIChzLmFsYmVkby5BTFBIQV9URVNUX0NIQU5ORUwgPCBhbGJlZG9TY2FsZUFuZEN1dG9mZi53KSBkaXNjYXJkO1xcbiAgI2VuZGlmXFxuICBzLm5vcm1hbCA9IHZfbm9ybWFsO1xcbiAgI2lmIFVTRV9OT1JNQUxfTUFQXFxuICAgIHZlYzMgbm1tcCA9IHRleHR1cmUobm9ybWFsTWFwLCBOT1JNQUxfVVYpLnh5eiAtIHZlYzMoMC41KTtcXG4gICAgcy5ub3JtYWwgPVxcbiAgICAgIChubW1wLnggKiBwYnJQYXJhbXMudykgKiBub3JtYWxpemUodl90YW5nZW50KSArXFxuICAgICAgKG5tbXAueSAqIHBiclBhcmFtcy53KSAqIG5vcm1hbGl6ZSh2X2JpdGFuZ2VudCkgK1xcbiAgICAgIG5tbXAueiAqIG5vcm1hbGl6ZShzLm5vcm1hbCk7XFxuICAjZW5kaWZcXG4gIHMucG9zaXRpb24gPSB2X3Bvc2l0aW9uO1xcbiAgdmVjNCBwYnIgPSBwYnJQYXJhbXM7XFxuICAjaWYgVVNFX1BCUl9NQVBcXG4gICAgdmVjNCByZXMgPSB0ZXh0dXJlKHBick1hcCwgUEJSX1VWKTtcXG4gICAgcGJyLnggKj0gcmVzLnI7XFxuICAgIHBici55ICo9IHJlcy5nO1xcbiAgICBwYnIueiAqPSByZXMuYjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9NRVRBTExJQ19ST1VHSE5FU1NfTUFQXFxuICAgIHZlYzQgbWV0YWxsaWNSb3VnaG5lc3MgPSB0ZXh0dXJlKG1ldGFsbGljUm91Z2huZXNzTWFwLCBQQlJfVVYpO1xcbiAgICBwYnIueiAqPSBtZXRhbGxpY1JvdWdobmVzcy5iO1xcbiAgICBwYnIueSAqPSBtZXRhbGxpY1JvdWdobmVzcy5nO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX09DQ0xVU0lPTl9NQVBcXG4gICAgcGJyLnggKj0gdGV4dHVyZShvY2NsdXNpb25NYXAsIFBCUl9VVikucjtcXG4gICNlbmRpZlxcbiAgcy5vY2NsdXNpb24gPSBjbGFtcChwYnIueCwgMC4wLCAwLjk2KTtcXG4gIHMucm91Z2huZXNzID0gY2xhbXAocGJyLnksIDAuMDQsIDEuMCk7XFxuICBzLm1ldGFsbGljID0gcGJyLno7XFxuICBzLmVtaXNzaXZlID0gZW1pc3NpdmUucmdiICogZW1pc3NpdmVTY2FsZVBhcmFtLnh5ejtcXG4gICNpZiBVU0VfRU1JU1NJVkVfTUFQXFxuICAgIHMuZW1pc3NpdmUgKj0gU1JHQlRvTGluZWFyKHRleHR1cmUoZW1pc3NpdmVNYXAsIEVNSVNTSVZFX1VWKS5yZ2IpO1xcbiAgI2VuZGlmXFxufVxcbnZlYzQgZnJhZyAoKSB7XFxuICBTdGFuZGFyZFN1cmZhY2Ugczsgc3VyZihzKTtcXG4gIHZlYzQgY29sb3IgPSBDQ1N0YW5kYXJkU2hhZGluZyhzKTtcXG4gIGNvbG9yID0gdmVjNChtaXgoQ0NfRk9SV0FSRF9BREQgPiAwID8gdmVjMygwLjApIDogY2NfZm9nQ29sb3IucmdiLCBjb2xvci5yZ2IsIHZfZm9nX2ZhY3RvciksIGNvbG9yLmEpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2xvcik7XFxufVxcbm91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xzbDFcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgcmdiYSA9IHJnYmEgKiAyNTUuMDtcXG4gIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyNy45OSwgcmdiYVszXSkgKiAyLjA7XFxuICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjcuOTkpICsgc3RlcCgxMjguMCwgcmdiYVsyXSkgLSAxMjcuMDtcXG4gIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG59XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX3RhbmdlbnQ7XFxuI2lmIENDX1VTRV9NT1JQSFxcbiAgICBhdHRyaWJ1dGUgZmxvYXQgYV92ZXJ0ZXhJZDtcXG4gICAgaW50IGdldFZlcnRleElkKCkge1xcbiAgICAgICAgcmV0dXJuIGludChhX3ZlcnRleElkKTtcXG4gICAgfVxcbnVuaWZvcm0gdmVjNCBjY19kaXNwbGFjZW1lbnRXZWlnaHRzWzE1XTtcXG51bmlmb3JtIHZlYzQgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm87XFxudmVjMiBnZXRQaXhlbExvY2F0aW9uKHZlYzIgdGV4dHVyZVJlc29sdXRpb24sIGludCBwaXhlbEluZGV4KSB7XFxuICAgIGZsb2F0IHBpeGVsSW5kZXhGID0gZmxvYXQocGl4ZWxJbmRleCk7XFxuICAgIGZsb2F0IHggPSBtb2QocGl4ZWxJbmRleEYsIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICBmbG9hdCB5ID0gZmxvb3IocGl4ZWxJbmRleEYgLyB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgcmV0dXJuIHZlYzIoeCwgeSk7XFxufVxcbnZlYzIgZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbih2ZWMyIGxvY2F0aW9uLCB2ZWMyIHRleHR1cmVSZXNvbHV0aW9uKSB7XFxuICAgIHJldHVybiAodmVjMihsb2NhdGlvbi54LCBsb2NhdGlvbi55KSArIC41KSAvIHRleHR1cmVSZXNvbHV0aW9uO1xcbn1cXG4jaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgICAgICB2ZWM0IGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IGVsZW1lbnRJbmRleCkge1xcbiAgICAgICAgICAgIGludCBwaXhlbEluZGV4ID0gZWxlbWVudEluZGV4O1xcbiAgICAgICAgICAgIHZlYzIgbG9jYXRpb24gPSBnZXRQaXhlbExvY2F0aW9uKGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5LCBwaXhlbEluZGV4KTtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCB1dik7XFxuICAgICAgICB9XFxuI2Vsc2VcXG4gICAgdmVjNCBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCBlbGVtZW50SW5kZXgpIHtcXG4gICAgICAgIGludCBwaXhlbEluZGV4ID0gZWxlbWVudEluZGV4ICogNDtcXG4gICAgICAgIHZlYzIgbG9jYXRpb24gPSBnZXRQaXhlbExvY2F0aW9uKGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5LCBwaXhlbEluZGV4KTtcXG4gICAgICAgIHZlYzIgeCA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDAuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB5ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMS4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICB2ZWMyIHogPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigyLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHJldHVybiB2ZWM0KFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUyRCh0ZXgsIHgpKSxcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQodGV4LCB5KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKHRleCwgeikpLFxcbiAgICAgICAgICAgIDEuMFxcbiAgICAgICAgKTtcXG4gICAgfVxcbiNlbmRpZlxcbmZsb2F0IGdldERpc3BsYWNlbWVudFdlaWdodChpbnQgaW5kZXgpIHtcXG4gICAgZmxvYXQgbSA9IG1vZChmbG9hdChpbmRleCksIDQuMCk7XFxuICAgIGlmIChtIDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLng7XFxuICAgIH0gZWxzZSBpZiAobSA8IDIuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS55O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAzLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0uejtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0udztcXG4gICAgfVxcbn1cXG52ZWMzIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgdmVydGV4SW5kZXgpIHtcXG4jaWYgQ0NfTU9SUEhfUFJFQ09NUFVURURcXG4gICAgcmV0dXJuIGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCB2ZXJ0ZXhJbmRleCkucmdiO1xcbiNlbHNlXFxuICAgIHZlYzMgcmVzdWx0ID0gdmVjMygwLCAwLCAwKTtcXG4gICAgZm9yIChpbnQgaVRhcmdldCA9IDA7IGlUYXJnZXQgPCBDQ19NT1JQSF9UQVJHRVRfQ09VTlQ7ICsraVRhcmdldCkge1xcbiAgICAgICAgaW50IGRhdGFQaXhlbFN0YXJ0ID0gaW50KGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBpVGFyZ2V0KS5yKTtcXG4gICAgICAgIHJlc3VsdCArPSAoZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZSh0ZXgsIGRhdGFQaXhlbFN0YXJ0ICsgdmVydGV4SW5kZXgpLnJnYiAqIGdldERpc3BsYWNlbWVudFdlaWdodChpVGFyZ2V0KSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4jZW5kaWZcXG59XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19Ob3JtYWxEaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldE5vcm1hbERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfTm9ybWFsRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19UYW5nZW50RGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19UYW5nZW50RGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxudm9pZCBhcHBseU1vcnBoIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICAgIGludCB2ZXJ0ZXhJZCA9IGdldFZlcnRleElkKCk7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgYXR0ci5wb3NpdGlvbi54eXogPSBhdHRyLnBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgYXR0ci5ub3JtYWwueHl6ID0gYXR0ci5ub3JtYWwueHl6ICsgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIGF0dHIudGFuZ2VudC54eXogPSBhdHRyLnRhbmdlbnQueHl6ICsgZ2V0VGFuZ2VudERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxufVxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHBvc2l0aW9uLnh5eiA9IHBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGdldFZlcnRleElkKCkpO1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX1NLSU5OSU5HXFxuYXR0cmlidXRlIHZlYzQgYV9qb2ludHM7XFxuYXR0cmlidXRlIHZlYzQgYV93ZWlnaHRzO1xcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgYXR0cmlidXRlIGhpZ2hwIHZlYzQgYV9qb2ludEFuaW1JbmZvO1xcbiAgI2VuZGlmXFxuICB1bmlmb3JtIGhpZ2hwIHZlYzQgY2Nfam9pbnRUZXh0dXJlSW5mbztcXG4gIHVuaWZvcm0gaGlnaHAgdmVjNCBjY19qb2ludEFuaW1JbmZvO1xcbiAgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgY2Nfam9pbnRUZXh0dXJlO1xcbiAgI2Vsc2VcXG4gIHVuaWZvcm0gaGlnaHAgdmVjNCBjY19qb2ludHNbOTBdO1xcbiNlbmRpZlxcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MiA9IHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAzLjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MiA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjMgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDguNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDkuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMS41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgIGludCBpZHggPSBpbnQoaSk7XFxuICAgIHZlYzQgdjEgPSBjY19qb2ludHNbaWR4ICogM107XFxuICAgIHZlYzQgdjIgPSBjY19qb2ludHNbaWR4ICogMyArIDFdO1xcbiAgICB2ZWM0IHYzID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAyXTtcXG4gICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gIH1cXG4jZW5kaWZcXG5tYXQ0IHNraW5NYXRyaXggKCkge1xcbiAgcmV0dXJuIGdldEpvaW50TWF0cml4KGFfam9pbnRzLngpICogYV93ZWlnaHRzLnhcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy55KSAqIGFfd2VpZ2h0cy55XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueikgKiBhX3dlaWdodHMuelxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLncpICogYV93ZWlnaHRzLnc7XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBwb3NpdGlvbiA9IG0gKiBwb3NpdGlvbjtcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIGF0dHIucG9zaXRpb24gPSBtICogYXR0ci5wb3NpdGlvbjtcXG4gIGF0dHIubm9ybWFsID0gKG0gKiB2ZWM0KGF0dHIubm9ybWFsLCAwLjApKS54eXo7XFxuICBhdHRyLnRhbmdlbnQueHl6ID0gKG0gKiB2ZWM0KGF0dHIudGFuZ2VudC54eXosIDAuMCkpLnh5ejtcXG59XFxuI2VuZGlmXFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXc7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFByb2o7XFxudW5pZm9ybSBoaWdocCB2ZWM0IGNjX2NhbWVyYVBvcztcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG4jaWYgVVNFX0lOU1RBTkNJTkdcXG4gIGF0dHJpYnV0ZSB2ZWM0IGFfbWF0V29ybGQwO1xcbiAgYXR0cmlidXRlIHZlYzQgYV9tYXRXb3JsZDE7XFxuICBhdHRyaWJ1dGUgdmVjNCBhX21hdFdvcmxkMjtcXG4gICNpZiBVU0VfTElHSFRNQVBcXG4gICAgYXR0cmlidXRlIHZlYzQgYV9saWdodGluZ01hcFVWUGFyYW07XFxuICAjZW5kaWZcXG4jZWxpZiBVU0VfQkFUQ0hJTkdcXG4gIGF0dHJpYnV0ZSBmbG9hdCBhX2R5bl9iYXRjaF9pZDtcXG4gIHVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZHNbMTBdO1xcbiNlbHNlXFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZElUO1xcbnVuaWZvcm0gaGlnaHAgdmVjNCBjY19saWdodGluZ01hcFVWUGFyYW07XFxuI2VuZGlmXFxudW5pZm9ybSB2ZWM0IHRpbGluZ09mZnNldDtcXG5mbG9hdCBMaW5lYXJGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKTtcXG4gICAgZmxvYXQgZm9nU3RhcnQgPSBjY19mb2dCYXNlLng7XFxuICAgIGZsb2F0IGZvZ0VuZCA9IGNjX2ZvZ0Jhc2UueTtcXG4gICAgcmV0dXJuIGNsYW1wKChmb2dFbmQgLSBjYW1fZGlzKSAvIChmb2dFbmQgLSBmb2dTdGFydCksIDAuLCAxLik7XFxufVxcbmZsb2F0IEV4cEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IGZvZ0RlbnNpdHkgPSBjY19mb2dCYXNlLno7XFxuICAgIGZsb2F0IGNhbV9kaXMgPSBkaXN0YW5jZShjY19jYW1lcmFQb3MsIHdQb3MpIC8gZm9nQXR0ZW4gKiA0LjtcXG4gICAgZmxvYXQgZiA9IGV4cCgtY2FtX2RpcyAqIGZvZ0RlbnNpdHkpO1xcbiAgICByZXR1cm4gZjtcXG59XFxuZmxvYXQgRXhwU3F1YXJlZEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IGZvZ0RlbnNpdHkgPSBjY19mb2dCYXNlLno7XFxuICAgIGZsb2F0IGNhbV9kaXMgPSBkaXN0YW5jZShjY19jYW1lcmFQb3MsIHdQb3MpIC8gZm9nQXR0ZW4gKiA0LjtcXG4gICAgZmxvYXQgZiA9IGV4cCgtY2FtX2RpcyAqIGNhbV9kaXMgKiBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSk7XFxuICAgIHJldHVybiBmO1xcbn1cXG5mbG9hdCBMYXllcmVkRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgZm9nQXR0ZW4gPSBjY19mb2dBZGQuejtcXG4gICAgZmxvYXQgX0ZvZ1RvcCA9IGNjX2ZvZ0FkZC54O1xcbiAgICBmbG9hdCBfRm9nUmFuZ2UgPSBjY19mb2dBZGQueTtcXG4gICAgdmVjMyBjYW1Xb3JsZFByb2ogPSBjY19jYW1lcmFQb3MueHl6O1xcbiAgICBjYW1Xb3JsZFByb2oueSA9IDAuO1xcbiAgICB2ZWMzIHdvcmxkUG9zUHJvaiA9IHdQb3MueHl6O1xcbiAgICB3b3JsZFBvc1Byb2oueSA9IDAuO1xcbiAgICBmbG9hdCBmRGVsdGFEID0gZGlzdGFuY2Uod29ybGRQb3NQcm9qLCBjYW1Xb3JsZFByb2opIC8gZm9nQXR0ZW4gKiAyLjA7XFxuICAgIGZsb2F0IGZEZWx0YVksIGZEZW5zaXR5SW50ZWdyYWw7XFxuICAgIGlmIChjY19jYW1lcmFQb3MueSA+IF9Gb2dUb3ApIHtcXG4gICAgICAgIGlmICh3UG9zLnkgPCBfRm9nVG9wKSB7XFxuICAgICAgICAgICAgZkRlbHRhWSA9IChfRm9nVG9wIC0gd1Bvcy55KSAvIF9Gb2dSYW5nZSAqIDIuMDtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gZkRlbHRhWSAqIGZEZWx0YVkgKiAwLjU7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSAwLjtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gMC47XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAod1Bvcy55IDwgX0ZvZ1RvcCkge1xcbiAgICAgICAgICAgIGZsb2F0IGZEZWx0YUEgPSAoX0ZvZ1RvcCAtIGNjX2NhbWVyYVBvcy55KSAvIF9Gb2dSYW5nZSAqIDIuO1xcbiAgICAgICAgICAgIGZsb2F0IGZEZWx0YUIgPSAoX0ZvZ1RvcCAtIHdQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjtcXG4gICAgICAgICAgICBmRGVsdGFZID0gYWJzKGZEZWx0YUEgLSBmRGVsdGFCKTtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gYWJzKChmRGVsdGFBICogZkRlbHRhQSAqIDAuNSkgLSAoZkRlbHRhQiAqIGZEZWx0YUIgKiAwLjUpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZkRlbHRhWSA9IGFicyhfRm9nVG9wIC0gY2NfY2FtZXJhUG9zLnkpIC8gX0ZvZ1JhbmdlICogMi47XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGFicyhmRGVsdGFZICogZkRlbHRhWSAqIDAuNSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZmxvYXQgZkRlbnNpdHk7XFxuICAgIGlmIChmRGVsdGFZICE9IDAuKSB7XFxuICAgICAgICBmRGVuc2l0eSA9IChzcXJ0KDEuMCArICgoZkRlbHRhRCAvIGZEZWx0YVkpICogKGZEZWx0YUQgLyBmRGVsdGFZKSkpKSAqIGZEZW5zaXR5SW50ZWdyYWw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBmRGVuc2l0eSA9IDAuO1xcbiAgICB9XFxuICAgIGZsb2F0IGYgPSBleHAoLWZEZW5zaXR5KTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbmZsb2F0IENDX1RSQU5TRkVSX0ZPRyh2ZWM0IHBvcykge1xcbiAgICAjaWYgQ0NfVVNFX0ZPRyA9PSAxXFxuICAgICAgICByZXR1cm4gTGluZWFyRm9nKHBvcyk7XFxuXHQjZWxpZiBDQ19VU0VfRk9HID09IDJcXG4gICAgICAgIHJldHVybiBFeHBGb2cocG9zKTtcXG4gICAgI2VsaWYgQ0NfVVNFX0ZPRyA9PSAzXFxuICAgICAgICByZXR1cm4gRXhwU3F1YXJlZEZvZyhwb3MpO1xcbiAgICAjZWxpZiBDQ19VU0VfRk9HID09IDRcXG4gICAgICAgIHJldHVybiBMYXllcmVkRm9nKHBvcyk7XFxuICAgICNlbmRpZlxcbiAgICByZXR1cm4gMS47XFxufVxcbnZhcnlpbmcgdmVjNCB2X3NoYWRvd1BvcztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0TGlnaHRWaWV3UHJvajtcXG4jaWYgVVNFX1ZFUlRFWF9DT0xPUlxcbiAgYXR0cmlidXRlIHZlYzMgYV9jb2xvcjtcXG4gIHZhcnlpbmcgdmVjMyB2X2NvbG9yO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xcbnZhcnlpbmcgdmVjMyB2X25vcm1hbDtcXG52YXJ5aW5nIHZlYzIgdl91djtcXG52YXJ5aW5nIHZlYzIgdl91djE7XFxudmFyeWluZyBmbG9hdCB2X2ZvZ19mYWN0b3I7XFxuI2lmIFVTRV9OT1JNQUxfTUFQXFxuICB2YXJ5aW5nIHZlYzMgdl90YW5nZW50O1xcbiAgdmFyeWluZyB2ZWMzIHZfYml0YW5nZW50O1xcbiNlbmRpZlxcbiNpZiBIQVNfU0VDT05EX1VWIHx8IFVTRV9MSUdIVE1BUFxcbiAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDE7XFxuI2VuZGlmXFxuI2lmIFVTRV9MSUdIVE1BUCAmJiAhVVNFX0JBVENISU5HICYmICFDQ19GT1JXQVJEX0FERFxcbiAgdmFyeWluZyB2ZWMyIHZfbHV2O1xcbnZvaWQgQ0NMaWdodGluZ01hcENhY2xVVigpXFxue1xcbiNpZiAhVVNFX0lOU1RBTkNJTkdcXG4gICAgICB2X2x1diA9IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbS54eSArIGFfdGV4Q29vcmQxICogY2NfbGlnaHRpbmdNYXBVVlBhcmFtLnp3O1xcbiNlbHNlXFxuICAgICAgdl9sdXYgPSBhX2xpZ2h0aW5nTWFwVVZQYXJhbS54eSArIGFfdGV4Q29vcmQxICogYV9saWdodGluZ01hcFVWUGFyYW0uenc7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbnZlYzQgdmVydCAoKSB7XFxuICBTdGFuZGFyZFZlcnRJbnB1dCBJbjtcXG4gIEluLnBvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xcbiAgSW4ubm9ybWFsID0gYV9ub3JtYWw7XFxuICBJbi50YW5nZW50ID0gYV90YW5nZW50O1xcbiAgI2lmIENDX1VTRV9NT1JQSFxcbiAgICBhcHBseU1vcnBoKEluKTtcXG4gICNlbmRpZlxcbiAgI2lmIENDX1VTRV9TS0lOTklOR1xcbiAgICBDQ1NraW4oSW4pO1xcbiAgI2VuZGlmXFxuICBtYXQ0IG1hdFdvcmxkLCBtYXRXb3JsZElUO1xcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIG1hdFdvcmxkID0gbWF0NChcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQwLnh5eiwgMC4wKSxcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQxLnh5eiwgMC4wKSxcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQyLnh5eiwgMC4wKSxcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQwLncsIGFfbWF0V29ybGQxLncsIGFfbWF0V29ybGQyLncsIDEuMClcXG4gICAgKTtcXG4gICAgbWF0V29ybGRJVCA9IG1hdFdvcmxkO1xcbiAgI2VsaWYgVVNFX0JBVENISU5HXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGRzW2ludChhX2R5bl9iYXRjaF9pZCldO1xcbiAgICBtYXRXb3JsZElUID0gbWF0V29ybGQ7XFxuICAjZWxzZVxcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkO1xcbiAgICBtYXRXb3JsZElUID0gY2NfbWF0V29ybGRJVDtcXG4gICNlbmRpZlxcbiAgdmVjNCBwb3MgPSBtYXRXb3JsZCAqIEluLnBvc2l0aW9uO1xcbiAgdl9wb3NpdGlvbiA9IHBvcy54eXo7XFxuICB2X25vcm1hbCA9IG5vcm1hbGl6ZSgobWF0V29ybGRJVCAqIHZlYzQoSW4ubm9ybWFsLCAwLjApKS54eXopO1xcbiAgI2lmIFVTRV9OT1JNQUxfTUFQXFxuICAgIHZfdGFuZ2VudCA9IG5vcm1hbGl6ZSgobWF0V29ybGQgKiB2ZWM0KEluLnRhbmdlbnQueHl6LCAwLjApKS54eXopO1xcbiAgICB2X2JpdGFuZ2VudCA9IGNyb3NzKHZfbm9ybWFsLCB2X3RhbmdlbnQpICogSW4udGFuZ2VudC53O1xcbiAgI2VuZGlmXFxuICB2X3V2ID0gYV90ZXhDb29yZCAqIHRpbGluZ09mZnNldC54eSArIHRpbGluZ09mZnNldC56dztcXG4gICNpZiBIQVNfU0VDT05EX1VWXFxuICAgIHZfdXYxID0gYV90ZXhDb29yZDEgKiB0aWxpbmdPZmZzZXQueHkgKyB0aWxpbmdPZmZzZXQuenc7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuICB2X2ZvZ19mYWN0b3IgPSBDQ19UUkFOU0ZFUl9GT0cobWF0V29ybGQgKiBJbi5wb3NpdGlvbik7XFxuICAjaWYgVVNFX0xJR0hUTUFQICYmICFVU0VfQkFUQ0hJTkcgJiYgIUNDX0ZPUldBUkRfQUREXFxuICAgIENDTGlnaHRpbmdNYXBDYWNsVVYoKTtcXG4gICNlbmRpZlxcbiAgICB2X3NoYWRvd1BvcyA9IGNjX21hdExpZ2h0Vmlld1Byb2ogKiBwb3M7XFxuICByZXR1cm4gY2NfbWF0UHJvaiAqIChjY19tYXRWaWV3ICogbWF0V29ybGQpICogSW4ucG9zaXRpb247XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG4jaWZkZWYgR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxcbiNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZDogZW5hYmxlXFxuI2VuZGlmXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnVuaWZvcm0gaGlnaHAgdmVjNCBjY19jYW1lcmFQb3M7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbnVuaWZvcm0gbG93cCB2ZWM0IGNjX3NoYWRvd0NvbG9yO1xcbnVuaWZvcm0gbG93cCB2ZWM0IGNjX3NoYWRvd1BDRjtcXG51bmlmb3JtIGxvd3AgdmVjNCBjY19zaGFkb3dTaXplO1xcbiNpZiBDQ19VU0VfSUJMXFxudW5pZm9ybSBzYW1wbGVyQ3ViZSBjY19lbnZpcm9ubWVudDtcXG52ZWMzIHVucGFja1JHQkUgKHZlYzQgcmdiZSkge1xcbiAgcmV0dXJuIHJnYmUucmdiICogcG93KDIuMCwgcmdiZS5hICogMjU1LjAgLSAxMjguMCk7XFxufVxcbnZlYzQgZnJhZ1RleHR1cmVMb2QgKHNhbXBsZXIyRCB0ZXgsIHZlYzIgY29vcmQsIGZsb2F0IGxvZCkge1xcbiAgICAjaWZkZWYgR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxcbiAgICAgIHJldHVybiB0ZXh0dXJlMkRMb2RFWFQodGV4LCBjb29yZCwgbG9kKTtcXG4gICAgI2Vsc2VcXG4gICAgICByZXR1cm4gdGV4dHVyZTJEKHRleCwgY29vcmQsIGxvZCk7XFxuICAgICNlbmRpZlxcbn1cXG52ZWM0IGZyYWdUZXh0dXJlTG9kIChzYW1wbGVyQ3ViZSB0ZXgsIHZlYzMgY29vcmQsIGZsb2F0IGxvZCkge1xcbiAgICAjaWZkZWYgR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxcbiAgICAgIHJldHVybiB0ZXh0dXJlQ3ViZUxvZEVYVCh0ZXgsIGNvb3JkLCBsb2QpO1xcbiAgICAjZWxzZVxcbiAgICAgIHJldHVybiB0ZXh0dXJlQ3ViZSh0ZXgsIGNvb3JkLCBsb2QpO1xcbiAgICAjZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIFVTRV9MSUdIVE1BUCAmJiAhVVNFX0JBVENISU5HICYmICFDQ19GT1JXQVJEX0FERFxcbiAgdmFyeWluZyB2ZWMyIHZfbHV2O1xcbnVuaWZvcm0gc2FtcGxlcjJEIGNjX2xpZ2h0aW5nTWFwO1xcbiNlbmRpZlxcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxuZmxvYXQgR0dYTW9iaWxlIChmbG9hdCByb3VnaG5lc3MsIGZsb2F0IE5vSCwgdmVjMyBILCB2ZWMzIE4pIHtcXG4gIHZlYzMgTnhIID0gY3Jvc3MoTiwgSCk7XFxuICBmbG9hdCBPbmVNaW51c05vSFNxciA9IGRvdChOeEgsIE54SCk7XFxuICBmbG9hdCBhID0gcm91Z2huZXNzICogcm91Z2huZXNzO1xcbiAgZmxvYXQgbiA9IE5vSCAqIGE7XFxuICBmbG9hdCBwID0gYSAvIChPbmVNaW51c05vSFNxciArIG4gKiBuKTtcXG4gIHJldHVybiBwICogcDtcXG59XFxuZmxvYXQgQ2FsY1NwZWN1bGFyIChmbG9hdCByb3VnaG5lc3MsIGZsb2F0IE5vSCwgdmVjMyBILCB2ZWMzIE4pIHtcXG4gIHJldHVybiAocm91Z2huZXNzKjAuMjUgKyAwLjI1KSAqIEdHWE1vYmlsZShyb3VnaG5lc3MsIE5vSCwgSCwgTik7XFxufVxcbnZlYzMgQlJERkFwcHJveCAodmVjMyBzcGVjdWxhciwgZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBOb1YpIHtcXG4gIGNvbnN0IHZlYzQgYzAgPSB2ZWM0KC0xLjAsIC0wLjAyNzUsIC0wLjU3MiwgMC4wMjIpO1xcbiAgY29uc3QgdmVjNCBjMSA9IHZlYzQoMS4wLCAwLjA0MjUsIDEuMDQsIC0wLjA0KTtcXG4gIHZlYzQgciA9IHJvdWdobmVzcyAqIGMwICsgYzE7XFxuICBmbG9hdCBhMDA0ID0gbWluKCByLnggKiByLngsIGV4cDIoIC05LjI4ICogTm9WICkgKSAqIHIueCArIHIueTtcXG4gIHZlYzIgQUIgPSB2ZWMyKCAtMS4wNCwgMS4wNCApICogYTAwNCArIHIuenc7XFxuICBBQi55ICo9IGNsYW1wKDUwLjAgKiBzcGVjdWxhci5nLCAwLjAsIDEuMCk7XFxuICByZXR1cm4gc3BlY3VsYXIgKiBBQi54ICsgQUIueTtcXG59XFxuc3RydWN0IFN0YW5kYXJkU3VyZmFjZSB7XFxuICB2ZWM0IGFsYmVkbztcXG4gIHZlYzMgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzMgZW1pc3NpdmU7XFxuICBmbG9hdCByb3VnaG5lc3M7XFxuICBmbG9hdCBtZXRhbGxpYztcXG4gIGZsb2F0IG9jY2x1c2lvbjtcXG59O1xcbiNpZiBDQ19GT1JXQVJEX0FERFxcbnVuaWZvcm0gaGlnaHAgdmVjNCBjY19saWdodFBvc1sxXTtcXG51bmlmb3JtIHZlYzQgY2NfbGlnaHRDb2xvclsxXTtcXG51bmlmb3JtIHZlYzQgY2NfbGlnaHRTaXplUmFuZ2VBbmdsZVsxXTtcXG51bmlmb3JtIHZlYzQgY2NfbGlnaHREaXJbMV07XFxuZmxvYXQgU21vb3RoRGlzdEF0dCAoZmxvYXQgZGlzdFNxciwgZmxvYXQgaW52U3FyQXR0UmFkaXVzKSB7XFxuICBmbG9hdCBmYWN0b3IgPSBkaXN0U3FyICogaW52U3FyQXR0UmFkaXVzO1xcbiAgZmxvYXQgc21vb3RoRmFjdG9yID0gY2xhbXAoMS4wIC0gZmFjdG9yICogZmFjdG9yLCAwLjAsIDEuMCk7XFxuICByZXR1cm4gc21vb3RoRmFjdG9yICogc21vb3RoRmFjdG9yO1xcbn1cXG5mbG9hdCBHZXREaXN0QXR0IChmbG9hdCBkaXN0U3FyLCBmbG9hdCBpbnZTcXJBdHRSYWRpdXMpIHtcXG4gIGZsb2F0IGF0dGVudWF0aW9uID0gMS4wIC8gbWF4KGRpc3RTcXIsIDAuMDEqMC4wMSk7XFxuICBhdHRlbnVhdGlvbiAqPSBTbW9vdGhEaXN0QXR0KGRpc3RTcXIgLCBpbnZTcXJBdHRSYWRpdXMpO1xcbiAgcmV0dXJuIGF0dGVudWF0aW9uO1xcbn1cXG5mbG9hdCBHZXRBbmdsZUF0dCAodmVjMyBMLCB2ZWMzIGxpdERpciwgZmxvYXQgbGl0QW5nbGVTY2FsZSwgZmxvYXQgbGl0QW5nbGVPZmZzZXQpIHtcXG4gIGZsb2F0IGNkID0gZG90KGxpdERpciwgTCk7XFxuICBmbG9hdCBhdHRlbnVhdGlvbiA9IGNsYW1wKGNkICogbGl0QW5nbGVTY2FsZSArIGxpdEFuZ2xlT2Zmc2V0LCAwLjAsIDEuMCk7XFxuICByZXR1cm4gKGF0dGVudWF0aW9uICogYXR0ZW51YXRpb24pO1xcbn1cXG4gIHZlYzQgQ0NTdGFuZGFyZFNoYWRpbmcgKFN0YW5kYXJkU3VyZmFjZSBzKSB7XFxuICAgIHZlYzMgZGlmZnVzZSA9IHMuYWxiZWRvLnJnYiAqICgxLjAgLSBzLm1ldGFsbGljKTtcXG4gICAgdmVjMyBzcGVjdWxhciA9IG1peCh2ZWMzKDAuMDQpLCBzLmFsYmVkby5yZ2IsIHMubWV0YWxsaWMpO1xcbiAgICB2ZWMzIGRpZmZ1c2VDb250cmliID0gZGlmZnVzZSAvIDMuMTQxNTkyNjUzNTk7XFxuICAgIHZlYzMgTiA9IG5vcm1hbGl6ZShzLm5vcm1hbCk7XFxuICAgIHZlYzMgViA9IG5vcm1hbGl6ZShjY19jYW1lcmFQb3MueHl6IC0gcy5wb3NpdGlvbik7XFxuICAgIGZsb2F0IE5WID0gbWF4KGFicyhkb3QoTiwgVikpLCAwLjAwMSk7XFxuICAgIHNwZWN1bGFyID0gQlJERkFwcHJveChzcGVjdWxhciwgcy5yb3VnaG5lc3MsIE5WKTtcXG4gICAgdmVjMyBmaW5hbENvbG9yID0gdmVjMygwLjApO1xcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IDE7IGkrKykge1xcbiAgICAgIHZlYzMgU0xVID0gY2NfbGlnaHRQb3NbaV0ueHl6IC0gcy5wb3NpdGlvbjtcXG4gICAgICB2ZWMzIFNMID0gbm9ybWFsaXplKFNMVSk7XFxuICAgICAgdmVjMyBTSCA9IG5vcm1hbGl6ZShTTCArIFYpO1xcbiAgICAgIGZsb2F0IFNOTCA9IG1heChkb3QoTiwgU0wpLCAwLjAwMSk7XFxuICAgICAgZmxvYXQgU05IID0gbWF4KGRvdChOLCBTSCksIDAuMCk7XFxuICAgICAgZmxvYXQgZGlzdFNxciA9IGRvdChTTFUsIFNMVSk7XFxuICAgICAgZmxvYXQgbGl0UmFkaXVzID0gY2NfbGlnaHRTaXplUmFuZ2VBbmdsZVtpXS54O1xcbiAgICAgIGZsb2F0IGxpdFJhZGl1c1NxciA9IGxpdFJhZGl1cyAqIGxpdFJhZGl1cztcXG4gICAgICBmbG9hdCBpbGx1bSA9IDMuMTQxNTkyNjUzNTkgKiAobGl0UmFkaXVzU3FyIC8gbWF4KGxpdFJhZGl1c1NxciAsIGRpc3RTcXIpKTtcXG4gICAgICBmbG9hdCBhdHRSYWRpdXNTcXJJbnYgPSAxLjAgLyBtYXgoY2NfbGlnaHRTaXplUmFuZ2VBbmdsZVtpXS55LCAwLjAxKTtcXG4gICAgICBhdHRSYWRpdXNTcXJJbnYgKj0gYXR0UmFkaXVzU3FySW52O1xcbiAgICAgIGZsb2F0IGF0dCA9IEdldERpc3RBdHQoZGlzdFNxciwgYXR0UmFkaXVzU3FySW52KTtcXG4gICAgICB2ZWMzIGxzcGVjID0gc3BlY3VsYXIgKiBDYWxjU3BlY3VsYXIocy5yb3VnaG5lc3MsIFNOSCwgU0gsIE4pO1xcbiAgICAgIGlmIChjY19saWdodFBvc1tpXS53ID4gMC4wKSB7XFxuICAgICAgICBmbG9hdCBjb3NJbm5lciA9IG1heChkb3QoLWNjX2xpZ2h0RGlyW2ldLnh5eiwgU0wpLCAwLjAxKTtcXG4gICAgICAgIGZsb2F0IGNvc091dGVyID0gY2NfbGlnaHRTaXplUmFuZ2VBbmdsZVtpXS56O1xcbiAgICAgICAgZmxvYXQgbGl0QW5nbGVTY2FsZSA9IDEuMCAvIG1heCgwLjAwMSwgY29zSW5uZXIgLSBjb3NPdXRlcik7XFxuICAgICAgICBmbG9hdCBsaXRBbmdsZU9mZnNldCA9IC1jb3NPdXRlciAqIGxpdEFuZ2xlU2NhbGU7XFxuICAgICAgICBhdHQgKj0gR2V0QW5nbGVBdHQoU0wsIC1jY19saWdodERpcltpXS54eXosIGxpdEFuZ2xlU2NhbGUsIGxpdEFuZ2xlT2Zmc2V0KTtcXG4gICAgICB9XFxuICAgICAgZmluYWxDb2xvciArPSBTTkwgKiBjY19saWdodENvbG9yW2ldLnJnYiAqIGNjX2xpZ2h0Q29sb3JbaV0udyAqIGlsbHVtICogYXR0ICogKGRpZmZ1c2VDb250cmliICsgbHNwZWMpO1xcbiAgICB9XFxuICAgIGZpbmFsQ29sb3IgPSBmaW5hbENvbG9yICogcy5vY2NsdXNpb247XFxuICAgIHJldHVybiB2ZWM0KGZpbmFsQ29sb3IsIDAuMCk7XFxuICB9XFxuI2Vsc2VcXG4gICNpZiBDQ19SRUNFSVZFX1NIQURPV1xcbnZhcnlpbmcgdmVjNCB2X3NoYWRvd1BvcztcXG51bmlmb3JtIHNhbXBsZXIyRCBjY19zaGFkb3dNYXA7XFxudmVjNCBDQ0dldFNoYWRvd0ZhY3RvclgxICgpIHtcXG4gIHZlYzMgY2xpcFBvcyA9IHZfc2hhZG93UG9zLnh5eiAvIHZfc2hhZG93UG9zLncgKiAwLjUgKyAwLjU7XFxuICBmbG9hdCBkZXB0aCA9IGRvdCh0ZXh0dXJlMkQoY2Nfc2hhZG93TWFwLCBjbGlwUG9zLnh5KSwgdmVjNCgxLjAsIDEuMCAvIDI1NS4wLCAxLjAgLyA2NTAyNS4wLCAxLjAgLyAxNjA1ODEzNzUuMCkpO1xcbiAgaWYgKGRlcHRoIDwgKGNsaXBQb3MueiAtIDAuMDAxKSkgcmV0dXJuIGNjX3NoYWRvd0NvbG9yO1xcbiAgZWxzZSByZXR1cm4gdmVjNCgwKTtcXG59XFxudmVjNCBDQ0dldFNoYWRvd0ZhY3Rvclg1ICgpIHtcXG4gIHZlYzMgY2xpcFBvcyA9IHZfc2hhZG93UG9zLnh5eiAvIHZfc2hhZG93UG9zLncgKiAwLjUgKyAwLjU7XFxuICBmbG9hdCBvZmZzZXR4ID0gMS4wIC8gY2Nfc2hhZG93U2l6ZS54O1xcbiAgZmxvYXQgb2Zmc2V0eSA9IDEuMCAvIGNjX3NoYWRvd1NpemUueTtcXG4gIGZsb2F0IGRlcHRoID0gMC4wO1xcbiAgZGVwdGggKz0gZG90KHRleHR1cmUyRChjY19zaGFkb3dNYXAsIHZlYzIoY2xpcFBvcy54IC0gb2Zmc2V0eCwgY2xpcFBvcy55IC0gb2Zmc2V0eSkpLCB2ZWM0KDEuMCwgMS4wIC8gMjU1LjAsIDEuMCAvIDY1MDI1LjAsIDEuMCAvIDE2MDU4MTM3NS4wKSk7XFxuICBkZXB0aCArPSBkb3QodGV4dHVyZTJEKGNjX3NoYWRvd01hcCwgdmVjMihjbGlwUG9zLnggLSBvZmZzZXR4LCBjbGlwUG9zLnkgKyBvZmZzZXR5KSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gIGRlcHRoICs9IGRvdCh0ZXh0dXJlMkQoY2Nfc2hhZG93TWFwLCB2ZWMyKGNsaXBQb3MueCwgY2xpcFBvcy55KSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gIGRlcHRoICs9IGRvdCh0ZXh0dXJlMkQoY2Nfc2hhZG93TWFwLCB2ZWMyKGNsaXBQb3MueCArIG9mZnNldHgsIGNsaXBQb3MueSAtIG9mZnNldHkpKSwgdmVjNCgxLjAsIDEuMCAvIDI1NS4wLCAxLjAgLyA2NTAyNS4wLCAxLjAgLyAxNjA1ODEzNzUuMCkpO1xcbiAgZGVwdGggKz0gZG90KHRleHR1cmUyRChjY19zaGFkb3dNYXAsIHZlYzIoY2xpcFBvcy54ICsgb2Zmc2V0eCwgY2xpcFBvcy55ICsgb2Zmc2V0eSkpLCB2ZWM0KDEuMCwgMS4wIC8gMjU1LjAsIDEuMCAvIDY1MDI1LjAsIDEuMCAvIDE2MDU4MTM3NS4wKSk7XFxuICBkZXB0aCAvPSA1LjA7XFxuICBpZiAoZGVwdGggPCAoY2xpcFBvcy56IC0gMC4wMDEpKSByZXR1cm4gY2Nfc2hhZG93Q29sb3I7XFxuICBlbHNlIHJldHVybiB2ZWM0KDApO1xcbn1cXG52ZWM0IENDR2V0U2hhZG93RmFjdG9yWDkgKCkge1xcbiAgdmVjMyBjbGlwUG9zID0gdl9zaGFkb3dQb3MueHl6IC8gdl9zaGFkb3dQb3MudyAqIDAuNSArIDAuNTtcXG4gIGZsb2F0IG9mZnNldHggPSAxLjAgLyBjY19zaGFkb3dTaXplLng7XFxuICBmbG9hdCBvZmZzZXR5ID0gMS4wIC8gY2Nfc2hhZG93U2l6ZS55O1xcbiAgZmxvYXQgZGVwdGggPSAwLjA7XFxuICBmb3IgKGludCBpID0gLTE7IGkgPD0gMTsgaSsrKSB7XFxuICAgIGZvciAoaW50IGogPSAtMTsgaiA8PSAxOyBqKyspIHtcXG4gICAgICBkZXB0aCArPSBkb3QodGV4dHVyZTJEKGNjX3NoYWRvd01hcCwgY2xpcFBvcy54eSArIHZlYzIoaSwgaikgKiB2ZWMyKG9mZnNldHgsIG9mZnNldHkpKSwgdmVjNCgxLjAsIDEuMCAvIDI1NS4wLCAxLjAgLyA2NTAyNS4wLCAxLjAgLyAxNjA1ODEzNzUuMCkpO1xcbiAgICB9XFxuICB9XFxuICBkZXB0aCAvPSA5LjA7XFxuICBpZiAoZGVwdGggPCAoY2xpcFBvcy56IC0gMC4wMDEpKSByZXR1cm4gY2Nfc2hhZG93Q29sb3I7XFxuICBlbHNlIHJldHVybiB2ZWM0KDApO1xcbn1cXG52ZWM0IENDR2V0U2hhZG93RmFjdG9yWDI1ICgpIHtcXG4gIHZlYzMgY2xpcFBvcyA9IHZfc2hhZG93UG9zLnh5eiAvIHZfc2hhZG93UG9zLncgKiAwLjUgKyAwLjU7XFxuICBmbG9hdCBvZmZzZXR4ID0gMS4wIC8gY2Nfc2hhZG93U2l6ZS54O1xcbiAgZmxvYXQgb2Zmc2V0eSA9IDEuMCAvIGNjX3NoYWRvd1NpemUueTtcXG4gIGZsb2F0IGRlcHRoID0gMC4wO1xcbiAgZm9yIChpbnQgaSA9IC0yOyBpIDw9IDI7IGkrKykge1xcbiAgICBmb3IgKGludCBqID0gLTI7IGogPD0gMjsgaisrKSB7XFxuICAgICAgZGVwdGggKz0gZG90KHRleHR1cmUyRChjY19zaGFkb3dNYXAsIGNsaXBQb3MueHkgKyB2ZWMyKGksIGopICogdmVjMihvZmZzZXR4LCBvZmZzZXR5KSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gICAgfVxcbiAgfVxcbiAgZGVwdGggLz0gMjUuMDtcXG4gIGlmIChkZXB0aCA8IChjbGlwUG9zLnogLSAwLjAwMSkpIHJldHVybiBjY19zaGFkb3dDb2xvcjtcXG4gIGVsc2UgcmV0dXJuIHZlYzQoMCk7XFxufVxcbiAgI2VuZGlmXFxuICB2ZWM0IENDU3RhbmRhcmRTaGFkaW5nIChTdGFuZGFyZFN1cmZhY2Ugcykge1xcbiAgICB2ZWMzIGRpZmZ1c2UgPSBzLmFsYmVkby5yZ2IgKiAoMS4wIC0gcy5tZXRhbGxpYyk7XFxuICAgIHZlYzMgc3BlY3VsYXIgPSBtaXgodmVjMygwLjA0KSwgcy5hbGJlZG8ucmdiLCBzLm1ldGFsbGljKTtcXG4gICAgdmVjMyBOID0gbm9ybWFsaXplKHMubm9ybWFsKTtcXG4gICAgdmVjMyBWID0gbm9ybWFsaXplKGNjX2NhbWVyYVBvcy54eXogLSBzLnBvc2l0aW9uKTtcXG4gICAgZmxvYXQgTlYgPSBtYXgoYWJzKGRvdChOLCBWKSksIDAuMDAxKTtcXG4gICAgc3BlY3VsYXIgPSBCUkRGQXBwcm94KHNwZWN1bGFyLCBzLnJvdWdobmVzcywgTlYpO1xcbiAgICB2ZWMzIEwgPSBub3JtYWxpemUoLWNjX21haW5MaXREaXIueHl6KTtcXG4gICAgdmVjMyBIID0gbm9ybWFsaXplKEwrVik7XFxuICAgIGZsb2F0IE5IID0gbWF4KGRvdChOLCBIKSwgMC4wKTtcXG4gICAgZmxvYXQgTkwgPSBtYXgoZG90KE4sIEwpLCAwLjAwMSk7XFxuICAgIHZlYzMgZmluYWxDb2xvciA9IE5MICogY2NfbWFpbkxpdENvbG9yLnJnYiAqIGNjX21haW5MaXRDb2xvci53O1xcbiAgICAjaWYgVVNFX0xJR0hUTUFQICYmICFVU0VfQkFUQ0hJTkcgJiYgIUNDX0ZPUldBUkRfQUREXFxuICAgICAgdmVjNCBsaWdodG1hcCA9IHRleHR1cmUyRChjY19saWdodGluZ01hcCwgdl9sdXYpO1xcbiAgICAgIGZpbmFsQ29sb3IgPSBsaWdodG1hcC5hICogbGlnaHRtYXAucmdiICsgKDEuMCAtIGxpZ2h0bWFwLmEpICogZmluYWxDb2xvcjtcXG4gICAgI2VuZGlmXFxuICAgIHZlYzMgZGlmZnVzZUNvbnRyaWIgPSBkaWZmdXNlIC8gMy4xNDE1OTI2NTM1OTtcXG4gICAgdmVjMyBzcGVjdWxhckNvbnRyaWIgPSBzcGVjdWxhciAqIENhbGNTcGVjdWxhcihzLnJvdWdobmVzcywgTkgsIEgsIE4pO1xcbiAgICBmaW5hbENvbG9yICo9IChkaWZmdXNlQ29udHJpYiArIHNwZWN1bGFyQ29udHJpYik7XFxuICAgIGZsb2F0IGZBbWIgPSAwLjUgLSBOLnkgKiAwLjU7XFxuICAgIHZlYzMgYW1iRGlmZiA9IG1peChjY19hbWJpZW50U2t5LnJnYiwgY2NfYW1iaWVudEdyb3VuZC5yZ2IsIGZBbWIpICogY2NfYW1iaWVudFNreS53O1xcbiAgICBmaW5hbENvbG9yICs9IChhbWJEaWZmLnJnYiAqIGRpZmZ1c2UpO1xcbiAgICAjaWYgQ0NfVVNFX0lCTFxcbiAgICAgIHZlYzMgUiA9IG5vcm1hbGl6ZShyZWZsZWN0KC1WLCBOKSk7XFxuICAgICAgdmVjNCBlbnZtYXAgPSBmcmFnVGV4dHVyZUxvZChjY19lbnZpcm9ubWVudCwgUiwgcy5yb3VnaG5lc3MgKiBjY19hbWJpZW50R3JvdW5kLncpO1xcbiAgICAgICNpZiBDQ19VU0VfSUJMID09IDJcXG4gICAgICAgIHZlYzMgZW52ID0gdW5wYWNrUkdCRShlbnZtYXApO1xcbiAgICAgICNlbHNlXFxuICAgICAgICB2ZWMzIGVudiA9IFNSR0JUb0xpbmVhcihlbnZtYXAucmdiKTtcXG4gICAgICAjZW5kaWZcXG4gICAgICBmaW5hbENvbG9yICs9IGVudiAqIGNjX2FtYmllbnRTa3kudyAqIHNwZWN1bGFyO1xcbiAgICAjZW5kaWZcXG4gICAgZmluYWxDb2xvciA9IGZpbmFsQ29sb3IgKiBzLm9jY2x1c2lvbjtcXG4gICAgI2lmIENDX1VTRV9IRFJcXG4gICAgICBzLmVtaXNzaXZlICo9IGNjX2V4cG9zdXJlLnc7XFxuICAgICNlbmRpZlxcbiAgICBmaW5hbENvbG9yICs9IHMuZW1pc3NpdmU7XFxuICAgICNpZiBDQ19SRUNFSVZFX1NIQURPV1xcbiAgICAgIHZlYzQgc2hhZG93ID0gdmVjNCgxLjApO1xcbiAgICAgIGZsb2F0IHBjZiA9IGNjX3NoYWRvd1BDRi54ICsgMC4wMDE7XFxuICAgICAgaWYgKHBjZiA+IDMuMCkge3NoYWRvdyA9IENDR2V0U2hhZG93RmFjdG9yWDI1KCk7fVxcbiAgICAgIGVsc2UgaWYgKDMuMCA+IHBjZiAmJiBwY2YgPiAyLjApIHtzaGFkb3cgPSBDQ0dldFNoYWRvd0ZhY3Rvclg5KCk7fVxcbiAgICAgIGVsc2UgaWYgKDIuMCA+IHBjZiAmJiBwY2YgPiAxLjApIHtzaGFkb3cgPSBDQ0dldFNoYWRvd0ZhY3Rvclg1KCk7fVxcbiAgICAgIGVsc2Uge3NoYWRvdyA9IENDR2V0U2hhZG93RmFjdG9yWDEoKTt9XFxuICAgICAgZmluYWxDb2xvciA9IHNoYWRvdy5yZ2IgKiBzaGFkb3cuYSArIGZpbmFsQ29sb3IgKiAoMS4wIC0gc2hhZG93LmEpO1xcbiAgICAjZW5kaWZcXG4gICAgcmV0dXJuIHZlYzQoZmluYWxDb2xvciwgcy5hbGJlZG8uYSk7XFxuICB9XFxuI2VuZGlmXFxudmVjMyBBQ0VTVG9uZU1hcCAodmVjMyBjb2xvcikge1xcbiAgY29sb3IgPSBtaW4oY29sb3IsIHZlYzMoOC4wKSk7XFxuICBjb25zdCBmbG9hdCBBID0gMi41MTtcXG4gIGNvbnN0IGZsb2F0IEIgPSAwLjAzO1xcbiAgY29uc3QgZmxvYXQgQyA9IDIuNDM7XFxuICBjb25zdCBmbG9hdCBEID0gMC41OTtcXG4gIGNvbnN0IGZsb2F0IEUgPSAwLjE0O1xcbiAgcmV0dXJuIChjb2xvciAqIChBICogY29sb3IgKyBCKSkgLyAoY29sb3IgKiAoQyAqIGNvbG9yICsgRCkgKyBFKTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiAhQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBzcXJ0KEFDRVNUb25lTWFwKGNvbG9yLnJnYikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbnVuaWZvcm0gdmVjNCBhbGJlZG87XFxudW5pZm9ybSB2ZWM0IGFsYmVkb1NjYWxlQW5kQ3V0b2ZmO1xcbnVuaWZvcm0gdmVjNCBwYnJQYXJhbXM7XFxudW5pZm9ybSB2ZWM0IGVtaXNzaXZlO1xcbnVuaWZvcm0gdmVjNCBlbWlzc2l2ZVNjYWxlUGFyYW07XFxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHZfdXY7XFxudmFyeWluZyB2ZWMyIHZfdXYxO1xcbnZhcnlpbmcgdmVjMyB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfZm9nX2ZhY3RvcjtcXG4jaWYgVVNFX1ZFUlRFWF9DT0xPUlxcbiAgdmFyeWluZyB2ZWMzIHZfY29sb3I7XFxuI2VuZGlmXFxuI2lmIFVTRV9BTEJFRE9fTUFQXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBhbGJlZG9NYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9OT1JNQUxfTUFQXFxuICB2YXJ5aW5nIHZlYzMgdl90YW5nZW50O1xcbiAgdmFyeWluZyB2ZWMzIHZfYml0YW5nZW50O1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfUEJSX01BUFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgcGJyTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfTUVUQUxMSUNfUk9VR0hORVNTX01BUFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxsaWNSb3VnaG5lc3NNYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9PQ0NMVVNJT05fTUFQXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9FTUlTU0lWRV9NQVBcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfQUxQSEFfVEVTVFxcbiNlbmRpZlxcbnZvaWQgc3VyZiAob3V0IFN0YW5kYXJkU3VyZmFjZSBzKSB7XFxuICB2ZWM0IGJhc2VDb2xvciA9IGFsYmVkbztcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIGJhc2VDb2xvci5yZ2IgKj0gdl9jb2xvcjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTEJFRE9fTUFQXFxuICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQoYWxiZWRvTWFwLCBBTEJFRE9fVVYpO1xcbiAgICB0ZXhDb2xvci5yZ2IgPSBTUkdCVG9MaW5lYXIodGV4Q29sb3IucmdiKTtcXG4gICAgYmFzZUNvbG9yICo9IHRleENvbG9yO1xcbiAgI2VuZGlmXFxuICBzLmFsYmVkbyA9IGJhc2VDb2xvcjtcXG4gIHMuYWxiZWRvLnJnYiAqPSBhbGJlZG9TY2FsZUFuZEN1dG9mZi54eXo7XFxuICAjaWYgVVNFX0FMUEhBX1RFU1RcXG4gICAgaWYgKHMuYWxiZWRvLkFMUEhBX1RFU1RfQ0hBTk5FTCA8IGFsYmVkb1NjYWxlQW5kQ3V0b2ZmLncpIGRpc2NhcmQ7XFxuICAjZW5kaWZcXG4gIHMubm9ybWFsID0gdl9ub3JtYWw7XFxuICAjaWYgVVNFX05PUk1BTF9NQVBcXG4gICAgdmVjMyBubW1wID0gdGV4dHVyZTJEKG5vcm1hbE1hcCwgTk9STUFMX1VWKS54eXogLSB2ZWMzKDAuNSk7XFxuICAgIHMubm9ybWFsID1cXG4gICAgICAobm1tcC54ICogcGJyUGFyYW1zLncpICogbm9ybWFsaXplKHZfdGFuZ2VudCkgK1xcbiAgICAgIChubW1wLnkgKiBwYnJQYXJhbXMudykgKiBub3JtYWxpemUodl9iaXRhbmdlbnQpICtcXG4gICAgICBubW1wLnogKiBub3JtYWxpemUocy5ub3JtYWwpO1xcbiAgI2VuZGlmXFxuICBzLnBvc2l0aW9uID0gdl9wb3NpdGlvbjtcXG4gIHZlYzQgcGJyID0gcGJyUGFyYW1zO1xcbiAgI2lmIFVTRV9QQlJfTUFQXFxuICAgIHZlYzQgcmVzID0gdGV4dHVyZTJEKHBick1hcCwgUEJSX1VWKTtcXG4gICAgcGJyLnggKj0gcmVzLnI7XFxuICAgIHBici55ICo9IHJlcy5nO1xcbiAgICBwYnIueiAqPSByZXMuYjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9NRVRBTExJQ19ST1VHSE5FU1NfTUFQXFxuICAgIHZlYzQgbWV0YWxsaWNSb3VnaG5lc3MgPSB0ZXh0dXJlMkQobWV0YWxsaWNSb3VnaG5lc3NNYXAsIFBCUl9VVik7XFxuICAgIHBici56ICo9IG1ldGFsbGljUm91Z2huZXNzLmI7XFxuICAgIHBici55ICo9IG1ldGFsbGljUm91Z2huZXNzLmc7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfT0NDTFVTSU9OX01BUFxcbiAgICBwYnIueCAqPSB0ZXh0dXJlMkQob2NjbHVzaW9uTWFwLCBQQlJfVVYpLnI7XFxuICAjZW5kaWZcXG4gIHMub2NjbHVzaW9uID0gY2xhbXAocGJyLngsIDAuMCwgMC45Nik7XFxuICBzLnJvdWdobmVzcyA9IGNsYW1wKHBici55LCAwLjA0LCAxLjApO1xcbiAgcy5tZXRhbGxpYyA9IHBici56O1xcbiAgcy5lbWlzc2l2ZSA9IGVtaXNzaXZlLnJnYiAqIGVtaXNzaXZlU2NhbGVQYXJhbS54eXo7XFxuICAjaWYgVVNFX0VNSVNTSVZFX01BUFxcbiAgICBzLmVtaXNzaXZlICo9IFNSR0JUb0xpbmVhcih0ZXh0dXJlMkQoZW1pc3NpdmVNYXAsIEVNSVNTSVZFX1VWKS5yZ2IpO1xcbiAgI2VuZGlmXFxufVxcbnZlYzQgZnJhZyAoKSB7XFxuICBTdGFuZGFyZFN1cmZhY2Ugczsgc3VyZihzKTtcXG4gIHZlYzQgY29sb3IgPSBDQ1N0YW5kYXJkU2hhZGluZyhzKTtcXG4gIGNvbG9yID0gdmVjNChtaXgoQ0NfRk9SV0FSRF9BREQgPiAwID8gdmVjMygwLjApIDogY2NfZm9nQ29sb3IucmdiLCBjb2xvci5yZ2IsIHZfZm9nX2ZhY3RvciksIGNvbG9yLmEpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2xvcik7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsNFwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbiNpZmRlZiBHTF9FWFRfc2hhZGVyX2V4cGxpY2l0X2FyaXRobWV0aWNfdHlwZXNfaW50MTZcXG4jZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfZXhwbGljaXRfYXJpdGhtZXRpY190eXBlc19pbnQxNjogZW5hYmxlXFxuI2VuZGlmXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmhpZ2hwIGZsb2F0IGRlY29kZTMyIChoaWdocCB2ZWM0IHJnYmEpIHtcXG4gIHJnYmEgPSByZ2JhICogMjU1LjA7XFxuICBoaWdocCBmbG9hdCBTaWduID0gMS4wIC0gc3RlcCgxMjcuOTksIHJnYmFbM10pICogMi4wO1xcbiAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVszXSwgMTI3Ljk5KSArIHN0ZXAoMTI4LjAsIHJnYmFbMl0pIC0gMTI3LjA7XFxuICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IG1vZChyZ2JhWzJdLCAxMjguMCkgKiA2NTUzNi4wICsgcmdiYVsxXSAqIDI1Ni4wICsgcmdiYVswXSArIDgzODg2MDguMDtcXG4gIHJldHVybiBTaWduICogZXhwMihFeHBvbmVudCAtIDIzLjApICogTWFudGlzc2E7XFxufVxcbnN0cnVjdCBTdGFuZGFyZFZlcnRJbnB1dCB7XFxuICBoaWdocCB2ZWM0IHBvc2l0aW9uO1xcbiAgdmVjMyBub3JtYWw7XFxuICB2ZWM0IHRhbmdlbnQ7XFxufTtcXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWMzIGFfcG9zaXRpb247XFxubGF5b3V0KGxvY2F0aW9uID0gMSkgaW4gdmVjMyBhX25vcm1hbDtcXG5sYXlvdXQobG9jYXRpb24gPSAyKSBpbiB2ZWMyIGFfdGV4Q29vcmQ7XFxubGF5b3V0KGxvY2F0aW9uID0gMykgaW4gdmVjNCBhX3RhbmdlbnQ7XFxuI2lmIENDX1VTRV9NT1JQSFxcbiAgICBpbnQgZ2V0VmVydGV4SWQoKSB7XFxuICAgICAgICByZXR1cm4gZ2xfVmVydGV4SW5kZXg7XFxuICAgIH1cXG5sYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDQpIHVuaWZvcm0gQ0NNb3JwaCB7XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1sxNV07XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm87XFxufTtcXG52ZWMyIGdldFBpeGVsTG9jYXRpb24odmVjMiB0ZXh0dXJlUmVzb2x1dGlvbiwgaW50IHBpeGVsSW5kZXgpIHtcXG4gICAgZmxvYXQgcGl4ZWxJbmRleEYgPSBmbG9hdChwaXhlbEluZGV4KTtcXG4gICAgZmxvYXQgeCA9IG1vZChwaXhlbEluZGV4RiwgdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgIGZsb2F0IHkgPSBmbG9vcihwaXhlbEluZGV4RiAvIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICByZXR1cm4gdmVjMih4LCB5KTtcXG59XFxudmVjMiBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKHZlYzIgbG9jYXRpb24sIHZlYzIgdGV4dHVyZVJlc29sdXRpb24pIHtcXG4gICAgcmV0dXJuICh2ZWMyKGxvY2F0aW9uLngsIGxvY2F0aW9uLnkpICsgLjUpIC8gdGV4dHVyZVJlc29sdXRpb247XFxufVxcbiNpZiBDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICAgICAgICAgIGl2ZWMyIHRleFNpemUgPSB0ZXh0dXJlU2l6ZSh0ZXgsIDApO1xcbiAgICAgICAgICAgIHJldHVybiB0ZXhlbEZldGNoKHRleCwgaXZlYzIocGl4ZWxJbmRleCAlIHRleFNpemUueCwgcGl4ZWxJbmRleCAvIHRleFNpemUueCksIDApO1xcbiAgICAgICAgfVxcbiNlbHNlXFxuICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgZWxlbWVudEluZGV4KSB7XFxuICAgICAgICBpbnQgcGl4ZWxJbmRleCA9IGVsZW1lbnRJbmRleCAqIDQ7XFxuICAgICAgICB2ZWMyIGxvY2F0aW9uID0gZ2V0UGl4ZWxMb2NhdGlvbihjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSwgcGl4ZWxJbmRleCk7XFxuICAgICAgICB2ZWMyIHggPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigwLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHZlYzIgeSA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDEuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB6ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMi4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICByZXR1cm4gdmVjNChcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKHRleCwgeCkpLFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUodGV4LCB5KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZSh0ZXgsIHopKSxcXG4gICAgICAgICAgICAxLjBcXG4gICAgICAgICk7XFxuICAgIH1cXG4jZW5kaWZcXG5mbG9hdCBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaW50IGluZGV4KSB7XFxuICAgIGZsb2F0IG0gPSBtb2QoZmxvYXQoaW5kZXgpLCA0LjApO1xcbiAgICBpZiAobSA8IDEuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS54O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAyLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueTtcXG4gICAgfSBlbHNlIGlmIChtIDwgMy4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLno7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnc7XFxuICAgIH1cXG59XFxudmVjMyBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IHZlcnRleEluZGV4KSB7XFxuI2lmIENDX01PUlBIX1BSRUNPTVBVVEVEXFxuICAgIHJldHVybiBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgdmVydGV4SW5kZXgpLnJnYjtcXG4jZWxzZVxcbiAgICB2ZWMzIHJlc3VsdCA9IHZlYzMoMCwgMCwgMCk7XFxuICAgIGZvciAoaW50IGlUYXJnZXQgPSAwOyBpVGFyZ2V0IDwgQ0NfTU9SUEhfVEFSR0VUX0NPVU5UOyArK2lUYXJnZXQpIHtcXG4gICAgICAgIGludCBkYXRhUGl4ZWxTdGFydCA9IGludChmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgaVRhcmdldCkucik7XFxuICAgICAgICByZXN1bHQgKz0gKGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBkYXRhUGl4ZWxTdGFydCArIHZlcnRleEluZGV4KS5yZ2IgKiBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaVRhcmdldCkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuI2VuZGlmXFxufVxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gNikgdW5pZm9ybSBzYW1wbGVyMkQgY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFxcbiAgICBsYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDcpIHVuaWZvcm0gc2FtcGxlcjJEIGNjX05vcm1hbERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19Ob3JtYWxEaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gOCkgdW5pZm9ybSBzYW1wbGVyMkQgY2NfVGFuZ2VudERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0VGFuZ2VudERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfVGFuZ2VudERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgICBpbnQgdmVydGV4SWQgPSBnZXRWZXJ0ZXhJZCgpO1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIGF0dHIucG9zaXRpb24ueHl6ID0gYXR0ci5wb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGF0dHIubm9ybWFsLnh5eiA9IGF0dHIubm9ybWFsLnh5eiArIGdldE5vcm1hbERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICBhdHRyLnRhbmdlbnQueHl6ID0gYXR0ci50YW5nZW50Lnh5eiArIGdldFRhbmdlbnREaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbn1cXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBwb3NpdGlvbi54eXogPSBwb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChnZXRWZXJ0ZXhJZCgpKTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9TS0lOTklOR1xcbmxheW91dChsb2NhdGlvbiA9IDQpIGluIHUxNnZlYzQgYV9qb2ludHM7XFxubGF5b3V0KGxvY2F0aW9uID0gNSkgaW4gdmVjNCBhX3dlaWdodHM7XFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBsYXlvdXQobG9jYXRpb24gPSA3KSBpbiBoaWdocCB2ZWM0IGFfam9pbnRBbmltSW5mbztcXG4gICNlbmRpZlxcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAzKSB1bmlmb3JtIENDU2tpbm5pbmdUZXh0dXJlIHtcXG4gICAgaGlnaHAgdmVjNCBjY19qb2ludFRleHR1cmVJbmZvO1xcbiAgfTtcXG4gIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMikgdW5pZm9ybSBDQ1NraW5uaW5nQW5pbWF0aW9uIHtcXG4gICAgaGlnaHAgdmVjNCBjY19qb2ludEFuaW1JbmZvO1xcbiAgfTtcXG4gIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gNSkgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgY2Nfam9pbnRUZXh0dXJlO1xcbiAgI2Vsc2VcXG4gIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMykgdW5pZm9ybSBDQ1NraW5uaW5nIHtcXG4gICAgaGlnaHAgdmVjNCBjY19qb2ludHNbMzAgKiAzXTtcXG4gIH07XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoY2Nfam9pbnRBbmltSW5mby54ICogY2Nfam9pbnRUZXh0dXJlSW5mby55ICsgaSkgKyBjY19qb2ludFRleHR1cmVJbmZvLno7XFxuICAgICNlbmRpZlxcbiAgICBoaWdocCBmbG9hdCBpbnZTaXplID0gY2Nfam9pbnRUZXh0dXJlSW5mby53O1xcbiAgICBoaWdocCBmbG9hdCB5ID0gZmxvb3IoaiAqIGludlNpemUpO1xcbiAgICBoaWdocCBmbG9hdCB4ID0gaiAtIHkgKiBjY19qb2ludFRleHR1cmVJbmZvLng7XFxuICAgIHkgPSAoeSArIDAuNSkgKiBpbnZTaXplO1xcbiAgICAgIHZlYzQgdjEgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MiA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMS41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYzID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbHNlXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDEyLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDEyLjAgKiAoY2Nfam9pbnRBbmltSW5mby54ICogY2Nfam9pbnRUZXh0dXJlSW5mby55ICsgaSkgKyBjY19qb2ludFRleHR1cmVJbmZvLno7XFxuICAgICNlbmRpZlxcbiAgICBoaWdocCBmbG9hdCBpbnZTaXplID0gY2Nfam9pbnRUZXh0dXJlSW5mby53O1xcbiAgICBoaWdocCBmbG9hdCB5ID0gZmxvb3IoaiAqIGludlNpemUpO1xcbiAgICBoaWdocCBmbG9hdCB4ID0gaiAtIHkgKiBjY19qb2ludFRleHR1cmVJbmZvLng7XFxuICAgIHkgPSAoeSArIDAuNSkgKiBpbnZTaXplO1xcbiAgICAgIHZlYzQgdjEgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAzLjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MiA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDQuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA1LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDcuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYzID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgOC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDkuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDExLjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2VuZGlmXFxuI2Vsc2VcXG4gIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgaW50IGlkeCA9IGludChpKTtcXG4gICAgdmVjNCB2MSA9IGNjX2pvaW50c1tpZHggKiAzXTtcXG4gICAgdmVjNCB2MiA9IGNjX2pvaW50c1tpZHggKiAzICsgMV07XFxuICAgIHZlYzQgdjMgPSBjY19qb2ludHNbaWR4ICogMyArIDJdO1xcbiAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgfVxcbiNlbmRpZlxcbm1hdDQgc2tpbk1hdHJpeCAoKSB7XFxuICByZXR1cm4gZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueCkgKiBhX3dlaWdodHMueFxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnkpICogYV93ZWlnaHRzLnlcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy56KSAqIGFfd2VpZ2h0cy56XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMudykgKiBhX3dlaWdodHMudztcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIHBvc2l0aW9uID0gbSAqIHBvc2l0aW9uO1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgYXR0ci5wb3NpdGlvbiA9IG0gKiBhdHRyLnBvc2l0aW9uO1xcbiAgYXR0ci5ub3JtYWwgPSAobSAqIHZlYzQoYXR0ci5ub3JtYWwsIDAuMCkpLnh5ejtcXG4gIGF0dHIudGFuZ2VudC54eXogPSAobSAqIHZlYzQoYXR0ci50YW5nZW50Lnh5eiwgMC4wKSkueHl6O1xcbn1cXG4jZW5kaWZcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbiNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gOCkgaW4gdmVjNCBhX21hdFdvcmxkMDtcXG4gIGxheW91dChsb2NhdGlvbiA9IDkpIGluIHZlYzQgYV9tYXRXb3JsZDE7XFxuICBsYXlvdXQobG9jYXRpb24gPSAxMCkgaW4gdmVjNCBhX21hdFdvcmxkMjtcXG4gICNpZiBVU0VfTElHSFRNQVBcXG4gICAgbGF5b3V0KGxvY2F0aW9uID0gMTEpIGluIHZlYzQgYV9saWdodGluZ01hcFVWUGFyYW07XFxuICAjZW5kaWZcXG4jZWxpZiBVU0VfQkFUQ0hJTkdcXG4gIGxheW91dChsb2NhdGlvbiA9IDEyKSBpbiBmbG9hdCBhX2R5bl9iYXRjaF9pZDtcXG4gIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0xvY2FsQmF0Y2hlZCB7XFxuICAgIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRzWzEwXTtcXG4gIH07XFxuI2Vsc2VcXG5sYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NMb2NhbCB7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZElUO1xcbiAgaGlnaHAgdmVjNCBjY19saWdodGluZ01hcFVWUGFyYW07XFxufTtcXG4jZW5kaWZcXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDApIHVuaWZvcm0gQ29uc3RhbnRzIHtcXG4gIHZlYzQgdGlsaW5nT2Zmc2V0O1xcbiAgdmVjNCBhbGJlZG87XFxuICB2ZWM0IGFsYmVkb1NjYWxlQW5kQ3V0b2ZmO1xcbiAgdmVjNCBwYnJQYXJhbXM7XFxuICB2ZWM0IGVtaXNzaXZlO1xcbiAgdmVjNCBlbWlzc2l2ZVNjYWxlUGFyYW07XFxufTtcXG5mbG9hdCBMaW5lYXJGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKTtcXG4gICAgZmxvYXQgZm9nU3RhcnQgPSBjY19mb2dCYXNlLng7XFxuICAgIGZsb2F0IGZvZ0VuZCA9IGNjX2ZvZ0Jhc2UueTtcXG4gICAgcmV0dXJuIGNsYW1wKChmb2dFbmQgLSBjYW1fZGlzKSAvIChmb2dFbmQgLSBmb2dTdGFydCksIDAuLCAxLik7XFxufVxcbmZsb2F0IEV4cEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IGZvZ0RlbnNpdHkgPSBjY19mb2dCYXNlLno7XFxuICAgIGZsb2F0IGNhbV9kaXMgPSBkaXN0YW5jZShjY19jYW1lcmFQb3MsIHdQb3MpIC8gZm9nQXR0ZW4gKiA0LjtcXG4gICAgZmxvYXQgZiA9IGV4cCgtY2FtX2RpcyAqIGZvZ0RlbnNpdHkpO1xcbiAgICByZXR1cm4gZjtcXG59XFxuZmxvYXQgRXhwU3F1YXJlZEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IGZvZ0RlbnNpdHkgPSBjY19mb2dCYXNlLno7XFxuICAgIGZsb2F0IGNhbV9kaXMgPSBkaXN0YW5jZShjY19jYW1lcmFQb3MsIHdQb3MpIC8gZm9nQXR0ZW4gKiA0LjtcXG4gICAgZmxvYXQgZiA9IGV4cCgtY2FtX2RpcyAqIGNhbV9kaXMgKiBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSk7XFxuICAgIHJldHVybiBmO1xcbn1cXG5mbG9hdCBMYXllcmVkRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgZm9nQXR0ZW4gPSBjY19mb2dBZGQuejtcXG4gICAgZmxvYXQgX0ZvZ1RvcCA9IGNjX2ZvZ0FkZC54O1xcbiAgICBmbG9hdCBfRm9nUmFuZ2UgPSBjY19mb2dBZGQueTtcXG4gICAgdmVjMyBjYW1Xb3JsZFByb2ogPSBjY19jYW1lcmFQb3MueHl6O1xcbiAgICBjYW1Xb3JsZFByb2oueSA9IDAuO1xcbiAgICB2ZWMzIHdvcmxkUG9zUHJvaiA9IHdQb3MueHl6O1xcbiAgICB3b3JsZFBvc1Byb2oueSA9IDAuO1xcbiAgICBmbG9hdCBmRGVsdGFEID0gZGlzdGFuY2Uod29ybGRQb3NQcm9qLCBjYW1Xb3JsZFByb2opIC8gZm9nQXR0ZW4gKiAyLjA7XFxuICAgIGZsb2F0IGZEZWx0YVksIGZEZW5zaXR5SW50ZWdyYWw7XFxuICAgIGlmIChjY19jYW1lcmFQb3MueSA+IF9Gb2dUb3ApIHtcXG4gICAgICAgIGlmICh3UG9zLnkgPCBfRm9nVG9wKSB7XFxuICAgICAgICAgICAgZkRlbHRhWSA9IChfRm9nVG9wIC0gd1Bvcy55KSAvIF9Gb2dSYW5nZSAqIDIuMDtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gZkRlbHRhWSAqIGZEZWx0YVkgKiAwLjU7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSAwLjtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gMC47XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAod1Bvcy55IDwgX0ZvZ1RvcCkge1xcbiAgICAgICAgICAgIGZsb2F0IGZEZWx0YUEgPSAoX0ZvZ1RvcCAtIGNjX2NhbWVyYVBvcy55KSAvIF9Gb2dSYW5nZSAqIDIuO1xcbiAgICAgICAgICAgIGZsb2F0IGZEZWx0YUIgPSAoX0ZvZ1RvcCAtIHdQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjtcXG4gICAgICAgICAgICBmRGVsdGFZID0gYWJzKGZEZWx0YUEgLSBmRGVsdGFCKTtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gYWJzKChmRGVsdGFBICogZkRlbHRhQSAqIDAuNSkgLSAoZkRlbHRhQiAqIGZEZWx0YUIgKiAwLjUpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZkRlbHRhWSA9IGFicyhfRm9nVG9wIC0gY2NfY2FtZXJhUG9zLnkpIC8gX0ZvZ1JhbmdlICogMi47XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGFicyhmRGVsdGFZICogZkRlbHRhWSAqIDAuNSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZmxvYXQgZkRlbnNpdHk7XFxuICAgIGlmIChmRGVsdGFZICE9IDAuKSB7XFxuICAgICAgICBmRGVuc2l0eSA9IChzcXJ0KDEuMCArICgoZkRlbHRhRCAvIGZEZWx0YVkpICogKGZEZWx0YUQgLyBmRGVsdGFZKSkpKSAqIGZEZW5zaXR5SW50ZWdyYWw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBmRGVuc2l0eSA9IDAuO1xcbiAgICB9XFxuICAgIGZsb2F0IGYgPSBleHAoLWZEZW5zaXR5KTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbmZsb2F0IENDX1RSQU5TRkVSX0ZPRyh2ZWM0IHBvcykge1xcbiAgICAjaWYgQ0NfVVNFX0ZPRyA9PSAxXFxuICAgICAgICByZXR1cm4gTGluZWFyRm9nKHBvcyk7XFxuXHQjZWxpZiBDQ19VU0VfRk9HID09IDJcXG4gICAgICAgIHJldHVybiBFeHBGb2cocG9zKTtcXG4gICAgI2VsaWYgQ0NfVVNFX0ZPRyA9PSAzXFxuICAgICAgICByZXR1cm4gRXhwU3F1YXJlZEZvZyhwb3MpO1xcbiAgICAjZWxpZiBDQ19VU0VfRk9HID09IDRcXG4gICAgICAgIHJldHVybiBMYXllcmVkRm9nKHBvcyk7XFxuICAgICNlbmRpZlxcbiAgICByZXR1cm4gMS47XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IHZfc2hhZG93UG9zO1xcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMSkgdW5pZm9ybSBDQ1NoYWRvdyB7XFxuICBoaWdocCBtYXQ0IGNjX21hdExpZ2h0UGxhbmVQcm9qO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFZpZXdQcm9qO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd0NvbG9yO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd1BDRjtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dTaXplO1xcbn07XFxuI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gIGxheW91dChsb2NhdGlvbiA9IDEzKSBpbiB2ZWMzIGFfY29sb3I7XFxuICBsYXlvdXQobG9jYXRpb24gPSAxKSBvdXQgdmVjMyB2X2NvbG9yO1xcbiNlbmRpZlxcbmxheW91dChsb2NhdGlvbiA9IDIpIG91dCB2ZWMzIHZfcG9zaXRpb247XFxubGF5b3V0KGxvY2F0aW9uID0gMykgb3V0IHZlYzMgdl9ub3JtYWw7XFxubGF5b3V0KGxvY2F0aW9uID0gNCkgb3V0IHZlYzIgdl91djtcXG5sYXlvdXQobG9jYXRpb24gPSA1KSBvdXQgdmVjMiB2X3V2MTtcXG5sYXlvdXQobG9jYXRpb24gPSA2KSBvdXQgZmxvYXQgdl9mb2dfZmFjdG9yO1xcbiNpZiBVU0VfTk9STUFMX01BUFxcbiAgbGF5b3V0KGxvY2F0aW9uID0gNykgb3V0IHZlYzMgdl90YW5nZW50O1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gOCkgb3V0IHZlYzMgdl9iaXRhbmdlbnQ7XFxuI2VuZGlmXFxuI2lmIEhBU19TRUNPTkRfVVYgfHwgVVNFX0xJR0hUTUFQXFxuICBsYXlvdXQobG9jYXRpb24gPSAxNCkgaW4gdmVjMiBhX3RleENvb3JkMTtcXG4jZW5kaWZcXG4jaWYgVVNFX0xJR0hUTUFQICYmICFVU0VfQkFUQ0hJTkcgJiYgIUNDX0ZPUldBUkRfQUREXFxuICBsYXlvdXQobG9jYXRpb24gPSA5KSBvdXQgdmVjMiB2X2x1djtcXG52b2lkIENDTGlnaHRpbmdNYXBDYWNsVVYoKVxcbntcXG4jaWYgIVVTRV9JTlNUQU5DSU5HXFxuICAgICAgdl9sdXYgPSBjY19saWdodGluZ01hcFVWUGFyYW0ueHkgKyBhX3RleENvb3JkMSAqIGNjX2xpZ2h0aW5nTWFwVVZQYXJhbS56dztcXG4jZWxzZVxcbiAgICAgIHZfbHV2ID0gYV9saWdodGluZ01hcFVWUGFyYW0ueHkgKyBhX3RleENvb3JkMSAqIGFfbGlnaHRpbmdNYXBVVlBhcmFtLnp3O1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG52ZWM0IHZlcnQgKCkge1xcbiAgU3RhbmRhcmRWZXJ0SW5wdXQgSW47XFxuICBJbi5wb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gIEluLm5vcm1hbCA9IGFfbm9ybWFsO1xcbiAgSW4udGFuZ2VudCA9IGFfdGFuZ2VudDtcXG4gICNpZiBDQ19VU0VfTU9SUEhcXG4gICAgYXBwbHlNb3JwaChJbik7XFxuICAjZW5kaWZcXG4gICNpZiBDQ19VU0VfU0tJTk5JTkdcXG4gICAgQ0NTa2luKEluKTtcXG4gICNlbmRpZlxcbiAgbWF0NCBtYXRXb3JsZCwgbWF0V29ybGRJVDtcXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBtYXRXb3JsZCA9IG1hdDQoXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMS54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMi54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC53LCBhX21hdFdvcmxkMS53LCBhX21hdFdvcmxkMi53LCAxLjApXFxuICAgICk7XFxuICAgIG1hdFdvcmxkSVQgPSBtYXRXb3JsZDtcXG4gICNlbGlmIFVTRV9CQVRDSElOR1xcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkc1tpbnQoYV9keW5fYmF0Y2hfaWQpXTtcXG4gICAgbWF0V29ybGRJVCA9IG1hdFdvcmxkO1xcbiAgI2Vsc2VcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZDtcXG4gICAgbWF0V29ybGRJVCA9IGNjX21hdFdvcmxkSVQ7XFxuICAjZW5kaWZcXG4gIHZlYzQgcG9zID0gbWF0V29ybGQgKiBJbi5wb3NpdGlvbjtcXG4gIHZfcG9zaXRpb24gPSBwb3MueHl6O1xcbiAgdl9ub3JtYWwgPSBub3JtYWxpemUoKG1hdFdvcmxkSVQgKiB2ZWM0KEluLm5vcm1hbCwgMC4wKSkueHl6KTtcXG4gICNpZiBVU0VfTk9STUFMX01BUFxcbiAgICB2X3RhbmdlbnQgPSBub3JtYWxpemUoKG1hdFdvcmxkICogdmVjNChJbi50YW5nZW50Lnh5eiwgMC4wKSkueHl6KTtcXG4gICAgdl9iaXRhbmdlbnQgPSBjcm9zcyh2X25vcm1hbCwgdl90YW5nZW50KSAqIEluLnRhbmdlbnQudztcXG4gICNlbmRpZlxcbiAgdl91diA9IGFfdGV4Q29vcmQgKiB0aWxpbmdPZmZzZXQueHkgKyB0aWxpbmdPZmZzZXQuenc7XFxuICAjaWYgSEFTX1NFQ09ORF9VVlxcbiAgICB2X3V2MSA9IGFfdGV4Q29vcmQxICogdGlsaW5nT2Zmc2V0Lnh5ICsgdGlsaW5nT2Zmc2V0Lnp3O1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX1ZFUlRFWF9DT0xPUlxcbiAgICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcbiAgdl9mb2dfZmFjdG9yID0gQ0NfVFJBTlNGRVJfRk9HKG1hdFdvcmxkICogSW4ucG9zaXRpb24pO1xcbiAgI2lmIFVTRV9MSUdIVE1BUCAmJiAhVVNFX0JBVENISU5HICYmICFDQ19GT1JXQVJEX0FERFxcbiAgICBDQ0xpZ2h0aW5nTWFwQ2FjbFVWKCk7XFxuICAjZW5kaWZcXG4gICAgdl9zaGFkb3dQb3MgPSBjY19tYXRMaWdodFZpZXdQcm9qICogcG9zO1xcbiAgcmV0dXJuIGNjX21hdFByb2ogKiAoY2NfbWF0VmlldyAqIG1hdFdvcmxkKSAqIEluLnBvc2l0aW9uO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxubGF5b3V0KHNldCA9IDAsIGJpbmRpbmcgPSAxKSB1bmlmb3JtIENDU2hhZG93IHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0TGlnaHRQbGFuZVByb2o7XFxuICBoaWdocCBtYXQ0IGNjX21hdExpZ2h0Vmlld1Byb2o7XFxuICBsb3dwIHZlYzQgY2Nfc2hhZG93Q29sb3I7XFxuICBsb3dwIHZlYzQgY2Nfc2hhZG93UENGO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd1NpemU7XFxufTtcXG4jaWYgQ0NfVVNFX0lCTFxcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMykgdW5pZm9ybSBzYW1wbGVyQ3ViZSBjY19lbnZpcm9ubWVudDtcXG52ZWMzIHVucGFja1JHQkUgKHZlYzQgcmdiZSkge1xcbiAgcmV0dXJuIHJnYmUucmdiICogcG93KDIuMCwgcmdiZS5hICogMjU1LjAgLSAxMjguMCk7XFxufVxcbnZlYzQgZnJhZ1RleHR1cmVMb2QgKHNhbXBsZXIyRCB0ZXgsIHZlYzIgY29vcmQsIGZsb2F0IGxvZCkge1xcbiAgICByZXR1cm4gdGV4dHVyZUxvZCh0ZXgsIGNvb3JkLCBsb2QpO1xcbn1cXG52ZWM0IGZyYWdUZXh0dXJlTG9kIChzYW1wbGVyQ3ViZSB0ZXgsIHZlYzMgY29vcmQsIGZsb2F0IGxvZCkge1xcbiAgICByZXR1cm4gdGV4dHVyZUxvZCh0ZXgsIGNvb3JkLCBsb2QpO1xcbn1cXG4jZW5kaWZcXG4jaWYgVVNFX0xJR0hUTUFQICYmICFVU0VfQkFUQ0hJTkcgJiYgIUNDX0ZPUldBUkRfQUREXFxuICBsYXlvdXQobG9jYXRpb24gPSA5KSBpbiB2ZWMyIHZfbHV2O1xcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gOSkgdW5pZm9ybSBzYW1wbGVyMkQgY2NfbGlnaHRpbmdNYXA7XFxuI2VuZGlmXFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG5mbG9hdCBHR1hNb2JpbGUgKGZsb2F0IHJvdWdobmVzcywgZmxvYXQgTm9ILCB2ZWMzIEgsIHZlYzMgTikge1xcbiAgdmVjMyBOeEggPSBjcm9zcyhOLCBIKTtcXG4gIGZsb2F0IE9uZU1pbnVzTm9IU3FyID0gZG90KE54SCwgTnhIKTtcXG4gIGZsb2F0IGEgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XFxuICBmbG9hdCBuID0gTm9IICogYTtcXG4gIGZsb2F0IHAgPSBhIC8gKE9uZU1pbnVzTm9IU3FyICsgbiAqIG4pO1xcbiAgcmV0dXJuIHAgKiBwO1xcbn1cXG5mbG9hdCBDYWxjU3BlY3VsYXIgKGZsb2F0IHJvdWdobmVzcywgZmxvYXQgTm9ILCB2ZWMzIEgsIHZlYzMgTikge1xcbiAgcmV0dXJuIChyb3VnaG5lc3MqMC4yNSArIDAuMjUpICogR0dYTW9iaWxlKHJvdWdobmVzcywgTm9ILCBILCBOKTtcXG59XFxudmVjMyBCUkRGQXBwcm94ICh2ZWMzIHNwZWN1bGFyLCBmbG9hdCByb3VnaG5lc3MsIGZsb2F0IE5vVikge1xcbiAgY29uc3QgdmVjNCBjMCA9IHZlYzQoLTEuMCwgLTAuMDI3NSwgLTAuNTcyLCAwLjAyMik7XFxuICBjb25zdCB2ZWM0IGMxID0gdmVjNCgxLjAsIDAuMDQyNSwgMS4wNCwgLTAuMDQpO1xcbiAgdmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcXG4gIGZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLTkuMjggKiBOb1YgKSApICogci54ICsgci55O1xcbiAgdmVjMiBBQiA9IHZlYzIoIC0xLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcXG4gIEFCLnkgKj0gY2xhbXAoNTAuMCAqIHNwZWN1bGFyLmcsIDAuMCwgMS4wKTtcXG4gIHJldHVybiBzcGVjdWxhciAqIEFCLnggKyBBQi55O1xcbn1cXG5zdHJ1Y3QgU3RhbmRhcmRTdXJmYWNlIHtcXG4gIHZlYzQgYWxiZWRvO1xcbiAgdmVjMyBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjMyBlbWlzc2l2ZTtcXG4gIGZsb2F0IHJvdWdobmVzcztcXG4gIGZsb2F0IG1ldGFsbGljO1xcbiAgZmxvYXQgb2NjbHVzaW9uO1xcbn07XFxuI2lmIENDX0ZPUldBUkRfQUREXFxubGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAxKSB1bmlmb3JtIENDRm9yd2FyZExpZ2h0IHtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRQb3NbMV07XFxuICB2ZWM0IGNjX2xpZ2h0Q29sb3JbMV07XFxuICB2ZWM0IGNjX2xpZ2h0U2l6ZVJhbmdlQW5nbGVbMV07XFxuICB2ZWM0IGNjX2xpZ2h0RGlyWzFdO1xcbn07XFxuZmxvYXQgU21vb3RoRGlzdEF0dCAoZmxvYXQgZGlzdFNxciwgZmxvYXQgaW52U3FyQXR0UmFkaXVzKSB7XFxuICBmbG9hdCBmYWN0b3IgPSBkaXN0U3FyICogaW52U3FyQXR0UmFkaXVzO1xcbiAgZmxvYXQgc21vb3RoRmFjdG9yID0gY2xhbXAoMS4wIC0gZmFjdG9yICogZmFjdG9yLCAwLjAsIDEuMCk7XFxuICByZXR1cm4gc21vb3RoRmFjdG9yICogc21vb3RoRmFjdG9yO1xcbn1cXG5mbG9hdCBHZXREaXN0QXR0IChmbG9hdCBkaXN0U3FyLCBmbG9hdCBpbnZTcXJBdHRSYWRpdXMpIHtcXG4gIGZsb2F0IGF0dGVudWF0aW9uID0gMS4wIC8gbWF4KGRpc3RTcXIsIDAuMDEqMC4wMSk7XFxuICBhdHRlbnVhdGlvbiAqPSBTbW9vdGhEaXN0QXR0KGRpc3RTcXIgLCBpbnZTcXJBdHRSYWRpdXMpO1xcbiAgcmV0dXJuIGF0dGVudWF0aW9uO1xcbn1cXG5mbG9hdCBHZXRBbmdsZUF0dCAodmVjMyBMLCB2ZWMzIGxpdERpciwgZmxvYXQgbGl0QW5nbGVTY2FsZSwgZmxvYXQgbGl0QW5nbGVPZmZzZXQpIHtcXG4gIGZsb2F0IGNkID0gZG90KGxpdERpciwgTCk7XFxuICBmbG9hdCBhdHRlbnVhdGlvbiA9IGNsYW1wKGNkICogbGl0QW5nbGVTY2FsZSArIGxpdEFuZ2xlT2Zmc2V0LCAwLjAsIDEuMCk7XFxuICByZXR1cm4gKGF0dGVudWF0aW9uICogYXR0ZW51YXRpb24pO1xcbn1cXG4gIHZlYzQgQ0NTdGFuZGFyZFNoYWRpbmcgKFN0YW5kYXJkU3VyZmFjZSBzKSB7XFxuICAgIHZlYzMgZGlmZnVzZSA9IHMuYWxiZWRvLnJnYiAqICgxLjAgLSBzLm1ldGFsbGljKTtcXG4gICAgdmVjMyBzcGVjdWxhciA9IG1peCh2ZWMzKDAuMDQpLCBzLmFsYmVkby5yZ2IsIHMubWV0YWxsaWMpO1xcbiAgICB2ZWMzIGRpZmZ1c2VDb250cmliID0gZGlmZnVzZSAvIDMuMTQxNTkyNjUzNTk7XFxuICAgIHZlYzMgTiA9IG5vcm1hbGl6ZShzLm5vcm1hbCk7XFxuICAgIHZlYzMgViA9IG5vcm1hbGl6ZShjY19jYW1lcmFQb3MueHl6IC0gcy5wb3NpdGlvbik7XFxuICAgIGZsb2F0IE5WID0gbWF4KGFicyhkb3QoTiwgVikpLCAwLjAwMSk7XFxuICAgIHNwZWN1bGFyID0gQlJERkFwcHJveChzcGVjdWxhciwgcy5yb3VnaG5lc3MsIE5WKTtcXG4gICAgdmVjMyBmaW5hbENvbG9yID0gdmVjMygwLjApO1xcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IDE7IGkrKykge1xcbiAgICAgIHZlYzMgU0xVID0gY2NfbGlnaHRQb3NbaV0ueHl6IC0gcy5wb3NpdGlvbjtcXG4gICAgICB2ZWMzIFNMID0gbm9ybWFsaXplKFNMVSk7XFxuICAgICAgdmVjMyBTSCA9IG5vcm1hbGl6ZShTTCArIFYpO1xcbiAgICAgIGZsb2F0IFNOTCA9IG1heChkb3QoTiwgU0wpLCAwLjAwMSk7XFxuICAgICAgZmxvYXQgU05IID0gbWF4KGRvdChOLCBTSCksIDAuMCk7XFxuICAgICAgZmxvYXQgZGlzdFNxciA9IGRvdChTTFUsIFNMVSk7XFxuICAgICAgZmxvYXQgbGl0UmFkaXVzID0gY2NfbGlnaHRTaXplUmFuZ2VBbmdsZVtpXS54O1xcbiAgICAgIGZsb2F0IGxpdFJhZGl1c1NxciA9IGxpdFJhZGl1cyAqIGxpdFJhZGl1cztcXG4gICAgICBmbG9hdCBpbGx1bSA9IDMuMTQxNTkyNjUzNTkgKiAobGl0UmFkaXVzU3FyIC8gbWF4KGxpdFJhZGl1c1NxciAsIGRpc3RTcXIpKTtcXG4gICAgICBmbG9hdCBhdHRSYWRpdXNTcXJJbnYgPSAxLjAgLyBtYXgoY2NfbGlnaHRTaXplUmFuZ2VBbmdsZVtpXS55LCAwLjAxKTtcXG4gICAgICBhdHRSYWRpdXNTcXJJbnYgKj0gYXR0UmFkaXVzU3FySW52O1xcbiAgICAgIGZsb2F0IGF0dCA9IEdldERpc3RBdHQoZGlzdFNxciwgYXR0UmFkaXVzU3FySW52KTtcXG4gICAgICB2ZWMzIGxzcGVjID0gc3BlY3VsYXIgKiBDYWxjU3BlY3VsYXIocy5yb3VnaG5lc3MsIFNOSCwgU0gsIE4pO1xcbiAgICAgIGlmIChjY19saWdodFBvc1tpXS53ID4gMC4wKSB7XFxuICAgICAgICBmbG9hdCBjb3NJbm5lciA9IG1heChkb3QoLWNjX2xpZ2h0RGlyW2ldLnh5eiwgU0wpLCAwLjAxKTtcXG4gICAgICAgIGZsb2F0IGNvc091dGVyID0gY2NfbGlnaHRTaXplUmFuZ2VBbmdsZVtpXS56O1xcbiAgICAgICAgZmxvYXQgbGl0QW5nbGVTY2FsZSA9IDEuMCAvIG1heCgwLjAwMSwgY29zSW5uZXIgLSBjb3NPdXRlcik7XFxuICAgICAgICBmbG9hdCBsaXRBbmdsZU9mZnNldCA9IC1jb3NPdXRlciAqIGxpdEFuZ2xlU2NhbGU7XFxuICAgICAgICBhdHQgKj0gR2V0QW5nbGVBdHQoU0wsIC1jY19saWdodERpcltpXS54eXosIGxpdEFuZ2xlU2NhbGUsIGxpdEFuZ2xlT2Zmc2V0KTtcXG4gICAgICB9XFxuICAgICAgZmluYWxDb2xvciArPSBTTkwgKiBjY19saWdodENvbG9yW2ldLnJnYiAqIGNjX2xpZ2h0Q29sb3JbaV0udyAqIGlsbHVtICogYXR0ICogKGRpZmZ1c2VDb250cmliICsgbHNwZWMpO1xcbiAgICB9XFxuICAgIGZpbmFsQ29sb3IgPSBmaW5hbENvbG9yICogcy5vY2NsdXNpb247XFxuICAgIHJldHVybiB2ZWM0KGZpbmFsQ29sb3IsIDAuMCk7XFxuICB9XFxuI2Vsc2VcXG4gICNpZiBDQ19SRUNFSVZFX1NIQURPV1xcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzQgdl9zaGFkb3dQb3M7XFxubGF5b3V0KHNldCA9IDAsIGJpbmRpbmcgPSA0KSB1bmlmb3JtIHNhbXBsZXIyRCBjY19zaGFkb3dNYXA7XFxudmVjNCBDQ0dldFNoYWRvd0ZhY3RvclgxICgpIHtcXG4gIHZlYzMgY2xpcFBvcyA9IHZfc2hhZG93UG9zLnh5eiAvIHZfc2hhZG93UG9zLncgKiAwLjUgKyAwLjU7XFxuICBmbG9hdCBkZXB0aCA9IGRvdCh0ZXh0dXJlKGNjX3NoYWRvd01hcCwgY2xpcFBvcy54eSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gIGlmIChkZXB0aCA8IChjbGlwUG9zLnogLSAwLjAwMSkpIHJldHVybiBjY19zaGFkb3dDb2xvcjtcXG4gIGVsc2UgcmV0dXJuIHZlYzQoMCk7XFxufVxcbnZlYzQgQ0NHZXRTaGFkb3dGYWN0b3JYNSAoKSB7XFxuICB2ZWMzIGNsaXBQb3MgPSB2X3NoYWRvd1Bvcy54eXogLyB2X3NoYWRvd1Bvcy53ICogMC41ICsgMC41O1xcbiAgZmxvYXQgb2Zmc2V0eCA9IDEuMCAvIGNjX3NoYWRvd1NpemUueDtcXG4gIGZsb2F0IG9mZnNldHkgPSAxLjAgLyBjY19zaGFkb3dTaXplLnk7XFxuICBmbG9hdCBkZXB0aCA9IDAuMDtcXG4gIGRlcHRoICs9IGRvdCh0ZXh0dXJlKGNjX3NoYWRvd01hcCwgdmVjMihjbGlwUG9zLnggLSBvZmZzZXR4LCBjbGlwUG9zLnkgLSBvZmZzZXR5KSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gIGRlcHRoICs9IGRvdCh0ZXh0dXJlKGNjX3NoYWRvd01hcCwgdmVjMihjbGlwUG9zLnggLSBvZmZzZXR4LCBjbGlwUG9zLnkgKyBvZmZzZXR5KSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gIGRlcHRoICs9IGRvdCh0ZXh0dXJlKGNjX3NoYWRvd01hcCwgdmVjMihjbGlwUG9zLngsIGNsaXBQb3MueSkpLCB2ZWM0KDEuMCwgMS4wIC8gMjU1LjAsIDEuMCAvIDY1MDI1LjAsIDEuMCAvIDE2MDU4MTM3NS4wKSk7XFxuICBkZXB0aCArPSBkb3QodGV4dHVyZShjY19zaGFkb3dNYXAsIHZlYzIoY2xpcFBvcy54ICsgb2Zmc2V0eCwgY2xpcFBvcy55IC0gb2Zmc2V0eSkpLCB2ZWM0KDEuMCwgMS4wIC8gMjU1LjAsIDEuMCAvIDY1MDI1LjAsIDEuMCAvIDE2MDU4MTM3NS4wKSk7XFxuICBkZXB0aCArPSBkb3QodGV4dHVyZShjY19zaGFkb3dNYXAsIHZlYzIoY2xpcFBvcy54ICsgb2Zmc2V0eCwgY2xpcFBvcy55ICsgb2Zmc2V0eSkpLCB2ZWM0KDEuMCwgMS4wIC8gMjU1LjAsIDEuMCAvIDY1MDI1LjAsIDEuMCAvIDE2MDU4MTM3NS4wKSk7XFxuICBkZXB0aCAvPSA1LjA7XFxuICBpZiAoZGVwdGggPCAoY2xpcFBvcy56IC0gMC4wMDEpKSByZXR1cm4gY2Nfc2hhZG93Q29sb3I7XFxuICBlbHNlIHJldHVybiB2ZWM0KDApO1xcbn1cXG52ZWM0IENDR2V0U2hhZG93RmFjdG9yWDkgKCkge1xcbiAgdmVjMyBjbGlwUG9zID0gdl9zaGFkb3dQb3MueHl6IC8gdl9zaGFkb3dQb3MudyAqIDAuNSArIDAuNTtcXG4gIGZsb2F0IG9mZnNldHggPSAxLjAgLyBjY19zaGFkb3dTaXplLng7XFxuICBmbG9hdCBvZmZzZXR5ID0gMS4wIC8gY2Nfc2hhZG93U2l6ZS55O1xcbiAgZmxvYXQgZGVwdGggPSAwLjA7XFxuICBmb3IgKGludCBpID0gLTE7IGkgPD0gMTsgaSsrKSB7XFxuICAgIGZvciAoaW50IGogPSAtMTsgaiA8PSAxOyBqKyspIHtcXG4gICAgICBkZXB0aCArPSBkb3QodGV4dHVyZShjY19zaGFkb3dNYXAsIGNsaXBQb3MueHkgKyB2ZWMyKGksIGopICogdmVjMihvZmZzZXR4LCBvZmZzZXR5KSksIHZlYzQoMS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gNjUwMjUuMCwgMS4wIC8gMTYwNTgxMzc1LjApKTtcXG4gICAgfVxcbiAgfVxcbiAgZGVwdGggLz0gOS4wO1xcbiAgaWYgKGRlcHRoIDwgKGNsaXBQb3MueiAtIDAuMDAxKSkgcmV0dXJuIGNjX3NoYWRvd0NvbG9yO1xcbiAgZWxzZSByZXR1cm4gdmVjNCgwKTtcXG59XFxudmVjNCBDQ0dldFNoYWRvd0ZhY3RvclgyNSAoKSB7XFxuICB2ZWMzIGNsaXBQb3MgPSB2X3NoYWRvd1Bvcy54eXogLyB2X3NoYWRvd1Bvcy53ICogMC41ICsgMC41O1xcbiAgZmxvYXQgb2Zmc2V0eCA9IDEuMCAvIGNjX3NoYWRvd1NpemUueDtcXG4gIGZsb2F0IG9mZnNldHkgPSAxLjAgLyBjY19zaGFkb3dTaXplLnk7XFxuICBmbG9hdCBkZXB0aCA9IDAuMDtcXG4gIGZvciAoaW50IGkgPSAtMjsgaSA8PSAyOyBpKyspIHtcXG4gICAgZm9yIChpbnQgaiA9IC0yOyBqIDw9IDI7IGorKykge1xcbiAgICAgIGRlcHRoICs9IGRvdCh0ZXh0dXJlKGNjX3NoYWRvd01hcCwgY2xpcFBvcy54eSArIHZlYzIoaSwgaikgKiB2ZWMyKG9mZnNldHgsIG9mZnNldHkpKSwgdmVjNCgxLjAsIDEuMCAvIDI1NS4wLCAxLjAgLyA2NTAyNS4wLCAxLjAgLyAxNjA1ODEzNzUuMCkpO1xcbiAgICB9XFxuICB9XFxuICBkZXB0aCAvPSAyNS4wO1xcbiAgaWYgKGRlcHRoIDwgKGNsaXBQb3MueiAtIDAuMDAxKSkgcmV0dXJuIGNjX3NoYWRvd0NvbG9yO1xcbiAgZWxzZSByZXR1cm4gdmVjNCgwKTtcXG59XFxuICAjZW5kaWZcXG4gIHZlYzQgQ0NTdGFuZGFyZFNoYWRpbmcgKFN0YW5kYXJkU3VyZmFjZSBzKSB7XFxuICAgIHZlYzMgZGlmZnVzZSA9IHMuYWxiZWRvLnJnYiAqICgxLjAgLSBzLm1ldGFsbGljKTtcXG4gICAgdmVjMyBzcGVjdWxhciA9IG1peCh2ZWMzKDAuMDQpLCBzLmFsYmVkby5yZ2IsIHMubWV0YWxsaWMpO1xcbiAgICB2ZWMzIE4gPSBub3JtYWxpemUocy5ub3JtYWwpO1xcbiAgICB2ZWMzIFYgPSBub3JtYWxpemUoY2NfY2FtZXJhUG9zLnh5eiAtIHMucG9zaXRpb24pO1xcbiAgICBmbG9hdCBOViA9IG1heChhYnMoZG90KE4sIFYpKSwgMC4wMDEpO1xcbiAgICBzcGVjdWxhciA9IEJSREZBcHByb3goc3BlY3VsYXIsIHMucm91Z2huZXNzLCBOVik7XFxuICAgIHZlYzMgTCA9IG5vcm1hbGl6ZSgtY2NfbWFpbkxpdERpci54eXopO1xcbiAgICB2ZWMzIEggPSBub3JtYWxpemUoTCtWKTtcXG4gICAgZmxvYXQgTkggPSBtYXgoZG90KE4sIEgpLCAwLjApO1xcbiAgICBmbG9hdCBOTCA9IG1heChkb3QoTiwgTCksIDAuMDAxKTtcXG4gICAgdmVjMyBmaW5hbENvbG9yID0gTkwgKiBjY19tYWluTGl0Q29sb3IucmdiICogY2NfbWFpbkxpdENvbG9yLnc7XFxuICAgICNpZiBVU0VfTElHSFRNQVAgJiYgIVVTRV9CQVRDSElORyAmJiAhQ0NfRk9SV0FSRF9BRERcXG4gICAgICB2ZWM0IGxpZ2h0bWFwID0gdGV4dHVyZShjY19saWdodGluZ01hcCwgdl9sdXYpO1xcbiAgICAgIGZpbmFsQ29sb3IgPSBsaWdodG1hcC5hICogbGlnaHRtYXAucmdiICsgKDEuMCAtIGxpZ2h0bWFwLmEpICogZmluYWxDb2xvcjtcXG4gICAgI2VuZGlmXFxuICAgIHZlYzMgZGlmZnVzZUNvbnRyaWIgPSBkaWZmdXNlIC8gMy4xNDE1OTI2NTM1OTtcXG4gICAgdmVjMyBzcGVjdWxhckNvbnRyaWIgPSBzcGVjdWxhciAqIENhbGNTcGVjdWxhcihzLnJvdWdobmVzcywgTkgsIEgsIE4pO1xcbiAgICBmaW5hbENvbG9yICo9IChkaWZmdXNlQ29udHJpYiArIHNwZWN1bGFyQ29udHJpYik7XFxuICAgIGZsb2F0IGZBbWIgPSAwLjUgLSBOLnkgKiAwLjU7XFxuICAgIHZlYzMgYW1iRGlmZiA9IG1peChjY19hbWJpZW50U2t5LnJnYiwgY2NfYW1iaWVudEdyb3VuZC5yZ2IsIGZBbWIpICogY2NfYW1iaWVudFNreS53O1xcbiAgICBmaW5hbENvbG9yICs9IChhbWJEaWZmLnJnYiAqIGRpZmZ1c2UpO1xcbiAgICAjaWYgQ0NfVVNFX0lCTFxcbiAgICAgIHZlYzMgUiA9IG5vcm1hbGl6ZShyZWZsZWN0KC1WLCBOKSk7XFxuICAgICAgdmVjNCBlbnZtYXAgPSBmcmFnVGV4dHVyZUxvZChjY19lbnZpcm9ubWVudCwgUiwgcy5yb3VnaG5lc3MgKiBjY19hbWJpZW50R3JvdW5kLncpO1xcbiAgICAgICNpZiBDQ19VU0VfSUJMID09IDJcXG4gICAgICAgIHZlYzMgZW52ID0gdW5wYWNrUkdCRShlbnZtYXApO1xcbiAgICAgICNlbHNlXFxuICAgICAgICB2ZWMzIGVudiA9IFNSR0JUb0xpbmVhcihlbnZtYXAucmdiKTtcXG4gICAgICAjZW5kaWZcXG4gICAgICBmaW5hbENvbG9yICs9IGVudiAqIGNjX2FtYmllbnRTa3kudyAqIHNwZWN1bGFyO1xcbiAgICAjZW5kaWZcXG4gICAgZmluYWxDb2xvciA9IGZpbmFsQ29sb3IgKiBzLm9jY2x1c2lvbjtcXG4gICAgI2lmIENDX1VTRV9IRFJcXG4gICAgICBzLmVtaXNzaXZlICo9IGNjX2V4cG9zdXJlLnc7XFxuICAgICNlbmRpZlxcbiAgICBmaW5hbENvbG9yICs9IHMuZW1pc3NpdmU7XFxuICAgICNpZiBDQ19SRUNFSVZFX1NIQURPV1xcbiAgICAgIHZlYzQgc2hhZG93ID0gdmVjNCgxLjApO1xcbiAgICAgIGZsb2F0IHBjZiA9IGNjX3NoYWRvd1BDRi54ICsgMC4wMDE7XFxuICAgICAgaWYgKHBjZiA+IDMuMCkge3NoYWRvdyA9IENDR2V0U2hhZG93RmFjdG9yWDI1KCk7fVxcbiAgICAgIGVsc2UgaWYgKDMuMCA+IHBjZiAmJiBwY2YgPiAyLjApIHtzaGFkb3cgPSBDQ0dldFNoYWRvd0ZhY3Rvclg5KCk7fVxcbiAgICAgIGVsc2UgaWYgKDIuMCA+IHBjZiAmJiBwY2YgPiAxLjApIHtzaGFkb3cgPSBDQ0dldFNoYWRvd0ZhY3Rvclg1KCk7fVxcbiAgICAgIGVsc2Uge3NoYWRvdyA9IENDR2V0U2hhZG93RmFjdG9yWDEoKTt9XFxuICAgICAgZmluYWxDb2xvciA9IHNoYWRvdy5yZ2IgKiBzaGFkb3cuYSArIGZpbmFsQ29sb3IgKiAoMS4wIC0gc2hhZG93LmEpO1xcbiAgICAjZW5kaWZcXG4gICAgcmV0dXJuIHZlYzQoZmluYWxDb2xvciwgcy5hbGJlZG8uYSk7XFxuICB9XFxuI2VuZGlmXFxudmVjMyBBQ0VTVG9uZU1hcCAodmVjMyBjb2xvcikge1xcbiAgY29sb3IgPSBtaW4oY29sb3IsIHZlYzMoOC4wKSk7XFxuICBjb25zdCBmbG9hdCBBID0gMi41MTtcXG4gIGNvbnN0IGZsb2F0IEIgPSAwLjAzO1xcbiAgY29uc3QgZmxvYXQgQyA9IDIuNDM7XFxuICBjb25zdCBmbG9hdCBEID0gMC41OTtcXG4gIGNvbnN0IGZsb2F0IEUgPSAwLjE0O1xcbiAgcmV0dXJuIChjb2xvciAqIChBICogY29sb3IgKyBCKSkgLyAoY29sb3IgKiAoQyAqIGNvbG9yICsgRCkgKyBFKTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiAhQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBzcXJ0KEFDRVNUb25lTWFwKGNvbG9yLnJnYikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbmxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDb25zdGFudHMge1xcbiAgdmVjNCB0aWxpbmdPZmZzZXQ7XFxuICB2ZWM0IGFsYmVkbztcXG4gIHZlYzQgYWxiZWRvU2NhbGVBbmRDdXRvZmY7XFxuICB2ZWM0IHBiclBhcmFtcztcXG4gIHZlYzQgZW1pc3NpdmU7XFxuICB2ZWM0IGVtaXNzaXZlU2NhbGVQYXJhbTtcXG59O1xcbmxheW91dChsb2NhdGlvbiA9IDIpIGluIHZlYzMgdl9wb3NpdGlvbjtcXG5sYXlvdXQobG9jYXRpb24gPSA0KSBpbiB2ZWMyIHZfdXY7XFxubGF5b3V0KGxvY2F0aW9uID0gNSkgaW4gdmVjMiB2X3V2MTtcXG5sYXlvdXQobG9jYXRpb24gPSAzKSBpbiB2ZWMzIHZfbm9ybWFsO1xcbmxheW91dChsb2NhdGlvbiA9IDYpIGluIGZsb2F0IHZfZm9nX2ZhY3RvcjtcXG4jaWYgVVNFX1ZFUlRFWF9DT0xPUlxcbiAgbGF5b3V0KGxvY2F0aW9uID0gMSkgaW4gdmVjMyB2X2NvbG9yO1xcbiNlbmRpZlxcbiNpZiBVU0VfQUxCRURPX01BUFxcbiAgbGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSAxKSB1bmlmb3JtIHNhbXBsZXIyRCBhbGJlZG9NYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9OT1JNQUxfTUFQXFxuICBsYXlvdXQobG9jYXRpb24gPSA3KSBpbiB2ZWMzIHZfdGFuZ2VudDtcXG4gIGxheW91dChsb2NhdGlvbiA9IDgpIGluIHZlYzMgdl9iaXRhbmdlbnQ7XFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDIpIHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG4jZW5kaWZcXG4jaWYgVVNFX1BCUl9NQVBcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMykgdW5pZm9ybSBzYW1wbGVyMkQgcGJyTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfTUVUQUxMSUNfUk9VR0hORVNTX01BUFxcbiAgbGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSA0KSB1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbGxpY1JvdWdobmVzc01hcDtcXG4jZW5kaWZcXG4jaWYgVVNFX09DQ0xVU0lPTl9NQVBcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gNSkgdW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfRU1JU1NJVkVfTUFQXFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDYpIHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfQUxQSEFfVEVTVFxcbiNlbmRpZlxcbnZvaWQgc3VyZiAob3V0IFN0YW5kYXJkU3VyZmFjZSBzKSB7XFxuICB2ZWM0IGJhc2VDb2xvciA9IGFsYmVkbztcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIGJhc2VDb2xvci5yZ2IgKj0gdl9jb2xvcjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTEJFRE9fTUFQXFxuICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlKGFsYmVkb01hcCwgQUxCRURPX1VWKTtcXG4gICAgdGV4Q29sb3IucmdiID0gU1JHQlRvTGluZWFyKHRleENvbG9yLnJnYik7XFxuICAgIGJhc2VDb2xvciAqPSB0ZXhDb2xvcjtcXG4gICNlbmRpZlxcbiAgcy5hbGJlZG8gPSBiYXNlQ29sb3I7XFxuICBzLmFsYmVkby5yZ2IgKj0gYWxiZWRvU2NhbGVBbmRDdXRvZmYueHl6O1xcbiAgI2lmIFVTRV9BTFBIQV9URVNUXFxuICAgIGlmIChzLmFsYmVkby5BTFBIQV9URVNUX0NIQU5ORUwgPCBhbGJlZG9TY2FsZUFuZEN1dG9mZi53KSBkaXNjYXJkO1xcbiAgI2VuZGlmXFxuICBzLm5vcm1hbCA9IHZfbm9ybWFsO1xcbiAgI2lmIFVTRV9OT1JNQUxfTUFQXFxuICAgIHZlYzMgbm1tcCA9IHRleHR1cmUobm9ybWFsTWFwLCBOT1JNQUxfVVYpLnh5eiAtIHZlYzMoMC41KTtcXG4gICAgcy5ub3JtYWwgPVxcbiAgICAgIChubW1wLnggKiBwYnJQYXJhbXMudykgKiBub3JtYWxpemUodl90YW5nZW50KSArXFxuICAgICAgKG5tbXAueSAqIHBiclBhcmFtcy53KSAqIG5vcm1hbGl6ZSh2X2JpdGFuZ2VudCkgK1xcbiAgICAgIG5tbXAueiAqIG5vcm1hbGl6ZShzLm5vcm1hbCk7XFxuICAjZW5kaWZcXG4gIHMucG9zaXRpb24gPSB2X3Bvc2l0aW9uO1xcbiAgdmVjNCBwYnIgPSBwYnJQYXJhbXM7XFxuICAjaWYgVVNFX1BCUl9NQVBcXG4gICAgdmVjNCByZXMgPSB0ZXh0dXJlKHBick1hcCwgUEJSX1VWKTtcXG4gICAgcGJyLnggKj0gcmVzLnI7XFxuICAgIHBici55ICo9IHJlcy5nO1xcbiAgICBwYnIueiAqPSByZXMuYjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9NRVRBTExJQ19ST1VHSE5FU1NfTUFQXFxuICAgIHZlYzQgbWV0YWxsaWNSb3VnaG5lc3MgPSB0ZXh0dXJlKG1ldGFsbGljUm91Z2huZXNzTWFwLCBQQlJfVVYpO1xcbiAgICBwYnIueiAqPSBtZXRhbGxpY1JvdWdobmVzcy5iO1xcbiAgICBwYnIueSAqPSBtZXRhbGxpY1JvdWdobmVzcy5nO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX09DQ0xVU0lPTl9NQVBcXG4gICAgcGJyLnggKj0gdGV4dHVyZShvY2NsdXNpb25NYXAsIFBCUl9VVikucjtcXG4gICNlbmRpZlxcbiAgcy5vY2NsdXNpb24gPSBjbGFtcChwYnIueCwgMC4wLCAwLjk2KTtcXG4gIHMucm91Z2huZXNzID0gY2xhbXAocGJyLnksIDAuMDQsIDEuMCk7XFxuICBzLm1ldGFsbGljID0gcGJyLno7XFxuICBzLmVtaXNzaXZlID0gZW1pc3NpdmUucmdiICogZW1pc3NpdmVTY2FsZVBhcmFtLnh5ejtcXG4gICNpZiBVU0VfRU1JU1NJVkVfTUFQXFxuICAgIHMuZW1pc3NpdmUgKj0gU1JHQlRvTGluZWFyKHRleHR1cmUoZW1pc3NpdmVNYXAsIEVNSVNTSVZFX1VWKS5yZ2IpO1xcbiAgI2VuZGlmXFxufVxcbnZlYzQgZnJhZyAoKSB7XFxuICBTdGFuZGFyZFN1cmZhY2Ugczsgc3VyZihzKTtcXG4gIHZlYzQgY29sb3IgPSBDQ1N0YW5kYXJkU2hhZGluZyhzKTtcXG4gIGNvbG9yID0gdmVjNChtaXgoQ0NfRk9SV0FSRF9BREQgPiAwID8gdmVjMygwLjApIDogY2NfZm9nQ29sb3IucmdiLCBjb2xvci5yZ2IsIHZfZm9nX2ZhY3RvciksIGNvbG9yLmEpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2xvcik7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnVpbHRpbnNcIjoge1xyXG4gICAgICAgICAgXCJnbG9iYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NHbG9iYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTaGFkb3dcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFt7IFwibmFtZVwiOiBcImNjX2Vudmlyb25tZW50XCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfSUJMXCJdIH0sIHsgXCJuYW1lXCI6IFwiY2Nfc2hhZG93TWFwXCIsIFwiZGVmaW5lc1wiOiBbXCIhQ0NfRk9SV0FSRF9BRERcIiwgXCJDQ19SRUNFSVZFX1NIQURPV1wiXSB9XSB9LFxyXG4gICAgICAgICAgXCJsb2NhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ01vcnBoXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIl0gfSwgeyBcIm5hbWVcIjogXCJDQ1NraW5uaW5nVGV4dHVyZVwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiXSB9LCB7IFwibmFtZVwiOiBcIkNDU2tpbm5pbmdBbmltYXRpb25cIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJDQ1NraW5uaW5nXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCIhQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiXSB9LCB7IFwibmFtZVwiOiBcIkNDTG9jYWxCYXRjaGVkXCIsIFwiZGVmaW5lc1wiOiBbXCIhVVNFX0lOU1RBTkNJTkdcIiwgXCJVU0VfQkFUQ0hJTkdcIl0gfSwgeyBcIm5hbWVcIjogXCJDQ0xvY2FsXCIsIFwiZGVmaW5lc1wiOiBbXCIhVVNFX0lOU1RBTkNJTkdcIiwgXCIhVVNFX0JBVENISU5HXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NGb3J3YXJkTGlnaHRcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX0ZPUldBUkRfQUREXCJdIH1dLCBcInNhbXBsZXJzXCI6IFt7IFwibmFtZVwiOiBcImNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50c1wiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCIsIFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlwiXSB9LCB7IFwibmFtZVwiOiBcImNjX05vcm1hbERpc3BsYWNlbWVudHNcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiLCBcIkNDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXCJdIH0sIHsgXCJuYW1lXCI6IFwiY2NfVGFuZ2VudERpc3BsYWNlbWVudHNcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiLCBcIkNDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFwiXSB9LCB7IFwibmFtZVwiOiBcImNjX2pvaW50VGV4dHVyZVwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiXSB9LCB7IFwibmFtZVwiOiBcImNjX2xpZ2h0aW5nTWFwXCIsIFwiZGVmaW5lc1wiOiBbXCJVU0VfTElHSFRNQVBcIiwgXCIhVVNFX0JBVENISU5HXCIsIFwiIUNDX0ZPUldBUkRfQUREXCJdIH1dIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9NT1JQSFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0NPVU5UXCIsIFwidHlwZVwiOiBcIm51bWJlclwiLCBcInJhbmdlXCI6IFsyLCA4XSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1BSRUNPTVBVVEVEXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9JTlNUQU5DSU5HXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfQkFUQ0hJTkdcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9MSUdIVE1BUFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0ZPR1wiLCBcInR5cGVcIjogXCJudW1iZXJcIiwgXCJyYW5nZVwiOiBbMCwgNF0gfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfRk9SV0FSRF9BRERcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9WRVJURVhfQ09MT1JcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9OT1JNQUxfTUFQXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJIQVNfU0VDT05EX1VWXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfSUJMXCIsIFwidHlwZVwiOiBcIm51bWJlclwiLCBcInJhbmdlXCI6IFswLCAyXSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19SRUNFSVZFX1NIQURPV1wiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0hEUlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX0FMQkVET19NQVBcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkFMQkVET19VVlwiLCBcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJvcHRpb25zXCI6IFtcInZfdXZcIiwgXCJ2X3V2MVwiXSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJOT1JNQUxfVVZcIiwgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwib3B0aW9uc1wiOiBbXCJ2X3V2XCIsIFwidl91djFcIl0gfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiUEJSX1VWXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm9wdGlvbnNcIjogW1widl91dlwiLCBcInZfdXYxXCJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9QQlJfTUFQXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfTUVUQUxMSUNfUk9VR0hORVNTX01BUFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX09DQ0xVU0lPTl9NQVBcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9FTUlTU0lWRV9NQVBcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkVNSVNTSVZFX1VWXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm9wdGlvbnNcIjogW1widl91dlwiLCBcInZfdXYxXCJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9BTFBIQV9URVNUXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJBTFBIQV9URVNUX0NIQU5ORUxcIiwgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwib3B0aW9uc1wiOiBbXCJhXCIsIFwiclwiXSB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImJsb2Nrc1wiOiBbXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiQ29uc3RhbnRzXCIsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDAsIFwic3RhZ2VGbGFnc1wiOiAxNywgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ0aWxpbmdPZmZzZXRcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJhbGJlZG9cIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJhbGJlZG9TY2FsZUFuZEN1dG9mZlwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInBiclBhcmFtc1wiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcImVtaXNzaXZlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH0sXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW1pc3NpdmVTY2FsZVBhcmFtXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcInNhbXBsZXJzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYWxiZWRvTWFwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0FMQkVET19NQVBcIl0sIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJiaW5kaW5nXCI6IDEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwibm9ybWFsTWFwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX05PUk1BTF9NQVBcIl0sIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJiaW5kaW5nXCI6IDIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwicGJyTWFwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX1BCUl9NQVBcIl0sIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJiaW5kaW5nXCI6IDMgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwibWV0YWxsaWNSb3VnaG5lc3NNYXBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfTUVUQUxMSUNfUk9VR0hORVNTX01BUFwiXSwgXCJzdGFnZUZsYWdzXCI6IDE2LCBcImJpbmRpbmdcIjogNCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJvY2NsdXNpb25NYXBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfT0NDTFVTSU9OX01BUFwiXSwgXCJzdGFnZUZsYWdzXCI6IDE2LCBcImJpbmRpbmdcIjogNSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJlbWlzc2l2ZU1hcFwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9FTUlTU0lWRV9NQVBcIl0sIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJiaW5kaW5nXCI6IDYgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX25vcm1hbFwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkXCIsIFwidHlwZVwiOiAxNCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAyMSwgXCJsb2NhdGlvblwiOiAyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGFuZ2VudFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3ZlcnRleElkXCIsIFwidHlwZVwiOiAxMywgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMTEsIFwibG9jYXRpb25cIjogNiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2pvaW50c1wiLCBcInR5cGVcIjogMTIsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQyLCBcImxvY2F0aW9uXCI6IDQgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV93ZWlnaHRzXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogNSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2pvaW50QW5pbUluZm9cIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCIsIFwiVVNFX0lOU1RBTkNJTkdcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDcgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9tYXRXb3JsZDBcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfSU5TVEFOQ0lOR1wiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQ0LCBcImlzSW5zdGFuY2VkXCI6IHRydWUsIFwibG9jYXRpb25cIjogOCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX21hdFdvcmxkMVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9JTlNUQU5DSU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiA5IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbWF0V29ybGQyXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDEwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbGlnaHRpbmdNYXBVVlBhcmFtXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIiwgXCJVU0VfTElHSFRNQVBcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDExIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfZHluX2JhdGNoX2lkXCIsIFwidHlwZVwiOiAxMywgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiVVNFX0JBVENISU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMTEsIFwibG9jYXRpb25cIjogMTIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9jb2xvclwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9WRVJURVhfQ09MT1JcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAxMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkMVwiLCBcInR5cGVcIjogMTQsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMjEsIFwibG9jYXRpb25cIjogMTQgfVxyXG4gICAgICAgIF1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tc3RhbmRhcmR8c2hhZG93LWNhc3Rlci12czp2ZXJ0fHNoYWRvdy1jYXN0ZXItZnM6ZnJhZ1wiLFxyXG4gICAgICAgIFwiaGFzaFwiOiAxNDMxNjM4NjI1LFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgcmdiYSA9IHJnYmEgKiAyNTUuMDtcXG4gIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyNy45OSwgcmdiYVszXSkgKiAyLjA7XFxuICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjcuOTkpICsgc3RlcCgxMjguMCwgcmdiYVsyXSkgLSAxMjcuMDtcXG4gIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG59XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmluIHZlYzMgYV9wb3NpdGlvbjtcXG5pbiB2ZWMzIGFfbm9ybWFsO1xcbmluIHZlYzIgYV90ZXhDb29yZDtcXG5pbiB2ZWM0IGFfdGFuZ2VudDtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGludCBnZXRWZXJ0ZXhJZCgpIHtcXG4gICAgICAgIHJldHVybiBnbF9WZXJ0ZXhJRDtcXG4gICAgfVxcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NNb3JwaCB7XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1sxNV07XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm87XFxufTtcXG52ZWMyIGdldFBpeGVsTG9jYXRpb24odmVjMiB0ZXh0dXJlUmVzb2x1dGlvbiwgaW50IHBpeGVsSW5kZXgpIHtcXG4gICAgZmxvYXQgcGl4ZWxJbmRleEYgPSBmbG9hdChwaXhlbEluZGV4KTtcXG4gICAgZmxvYXQgeCA9IG1vZChwaXhlbEluZGV4RiwgdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgIGZsb2F0IHkgPSBmbG9vcihwaXhlbEluZGV4RiAvIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICByZXR1cm4gdmVjMih4LCB5KTtcXG59XFxudmVjMiBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKHZlYzIgbG9jYXRpb24sIHZlYzIgdGV4dHVyZVJlc29sdXRpb24pIHtcXG4gICAgcmV0dXJuICh2ZWMyKGxvY2F0aW9uLngsIGxvY2F0aW9uLnkpICsgLjUpIC8gdGV4dHVyZVJlc29sdXRpb247XFxufVxcbiNpZiBDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICAgICAgICAgIGl2ZWMyIHRleFNpemUgPSB0ZXh0dXJlU2l6ZSh0ZXgsIDApO1xcbiAgICAgICAgICAgIHJldHVybiB0ZXhlbEZldGNoKHRleCwgaXZlYzIocGl4ZWxJbmRleCAlIHRleFNpemUueCwgcGl4ZWxJbmRleCAvIHRleFNpemUueCksIDApO1xcbiAgICAgICAgfVxcbiNlbHNlXFxuICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgZWxlbWVudEluZGV4KSB7XFxuICAgICAgICBpbnQgcGl4ZWxJbmRleCA9IGVsZW1lbnRJbmRleCAqIDQ7XFxuICAgICAgICB2ZWMyIGxvY2F0aW9uID0gZ2V0UGl4ZWxMb2NhdGlvbihjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSwgcGl4ZWxJbmRleCk7XFxuICAgICAgICB2ZWMyIHggPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigwLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHZlYzIgeSA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDEuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB6ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMi4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICByZXR1cm4gdmVjNChcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKHRleCwgeCkpLFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUodGV4LCB5KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZSh0ZXgsIHopKSxcXG4gICAgICAgICAgICAxLjBcXG4gICAgICAgICk7XFxuICAgIH1cXG4jZW5kaWZcXG5mbG9hdCBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaW50IGluZGV4KSB7XFxuICAgIGZsb2F0IG0gPSBtb2QoZmxvYXQoaW5kZXgpLCA0LjApO1xcbiAgICBpZiAobSA8IDEuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS54O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAyLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueTtcXG4gICAgfSBlbHNlIGlmIChtIDwgMy4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLno7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnc7XFxuICAgIH1cXG59XFxudmVjMyBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IHZlcnRleEluZGV4KSB7XFxuI2lmIENDX01PUlBIX1BSRUNPTVBVVEVEXFxuICAgIHJldHVybiBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgdmVydGV4SW5kZXgpLnJnYjtcXG4jZWxzZVxcbiAgICB2ZWMzIHJlc3VsdCA9IHZlYzMoMCwgMCwgMCk7XFxuICAgIGZvciAoaW50IGlUYXJnZXQgPSAwOyBpVGFyZ2V0IDwgQ0NfTU9SUEhfVEFSR0VUX0NPVU5UOyArK2lUYXJnZXQpIHtcXG4gICAgICAgIGludCBkYXRhUGl4ZWxTdGFydCA9IGludChmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgaVRhcmdldCkucik7XFxuICAgICAgICByZXN1bHQgKz0gKGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBkYXRhUGl4ZWxTdGFydCArIHZlcnRleEluZGV4KS5yZ2IgKiBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaVRhcmdldCkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuI2VuZGlmXFxufVxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfVGFuZ2VudERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0VGFuZ2VudERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfVGFuZ2VudERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgICBpbnQgdmVydGV4SWQgPSBnZXRWZXJ0ZXhJZCgpO1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIGF0dHIucG9zaXRpb24ueHl6ID0gYXR0ci5wb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGF0dHIubm9ybWFsLnh5eiA9IGF0dHIubm9ybWFsLnh5eiArIGdldE5vcm1hbERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICBhdHRyLnRhbmdlbnQueHl6ID0gYXR0ci50YW5nZW50Lnh5eiArIGdldFRhbmdlbnREaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbn1cXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBwb3NpdGlvbi54eXogPSBwb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChnZXRWZXJ0ZXhJZCgpKTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9TS0lOTklOR1xcbmluIHZlYzQgYV9qb2ludHM7XFxuaW4gdmVjNCBhX3dlaWdodHM7XFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBpbiBoaWdocCB2ZWM0IGFfam9pbnRBbmltSW5mbztcXG4gICNlbmRpZlxcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ1NraW5uaW5nVGV4dHVyZSB7XFxuICAgIGhpZ2hwIHZlYzQgY2Nfam9pbnRUZXh0dXJlSW5mbztcXG4gIH07XFxuICBsYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDU2tpbm5pbmdBbmltYXRpb24ge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50QW5pbUluZm87XFxuICB9O1xcbiAgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgY2Nfam9pbnRUZXh0dXJlO1xcbiAgI2Vsc2VcXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NTa2lubmluZyB7XFxuICAgIGhpZ2hwIHZlYzQgY2Nfam9pbnRzWzMwICogM107XFxuICB9O1xcbiNlbmRpZlxcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjIgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MyA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjIgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA0LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDYuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA3LjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MyA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDguNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA5LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMS41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgIGludCBpZHggPSBpbnQoaSk7XFxuICAgIHZlYzQgdjEgPSBjY19qb2ludHNbaWR4ICogM107XFxuICAgIHZlYzQgdjIgPSBjY19qb2ludHNbaWR4ICogMyArIDFdO1xcbiAgICB2ZWM0IHYzID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAyXTtcXG4gICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gIH1cXG4jZW5kaWZcXG5tYXQ0IHNraW5NYXRyaXggKCkge1xcbiAgcmV0dXJuIGdldEpvaW50TWF0cml4KGFfam9pbnRzLngpICogYV93ZWlnaHRzLnhcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy55KSAqIGFfd2VpZ2h0cy55XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueikgKiBhX3dlaWdodHMuelxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLncpICogYV93ZWlnaHRzLnc7XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBwb3NpdGlvbiA9IG0gKiBwb3NpdGlvbjtcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIGF0dHIucG9zaXRpb24gPSBtICogYXR0ci5wb3NpdGlvbjtcXG4gIGF0dHIubm9ybWFsID0gKG0gKiB2ZWM0KGF0dHIubm9ybWFsLCAwLjApKS54eXo7XFxuICBhdHRyLnRhbmdlbnQueHl6ID0gKG0gKiB2ZWM0KGF0dHIudGFuZ2VudC54eXosIDAuMCkpLnh5ejtcXG59XFxuI2VuZGlmXFxuI2lmIFVTRV9JTlNUQU5DSU5HXFxuICBpbiB2ZWM0IGFfbWF0V29ybGQwO1xcbiAgaW4gdmVjNCBhX21hdFdvcmxkMTtcXG4gIGluIHZlYzQgYV9tYXRXb3JsZDI7XFxuICAjaWYgVVNFX0xJR0hUTUFQXFxuICAgIGluIHZlYzQgYV9saWdodGluZ01hcFVWUGFyYW07XFxuICAjZW5kaWZcXG4jZWxpZiBVU0VfQkFUQ0hJTkdcXG4gIGluIGZsb2F0IGFfZHluX2JhdGNoX2lkO1xcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0xvY2FsQmF0Y2hlZCB7XFxuICAgIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRzWzEwXTtcXG4gIH07XFxuI2Vsc2VcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxuI2VuZGlmXFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDb25zdGFudHMge1xcbiAgdmVjNCB0aWxpbmdPZmZzZXQ7XFxuICB2ZWM0IGFsYmVkbztcXG4gIHZlYzQgYWxiZWRvU2NhbGVBbmRDdXRvZmY7XFxuICB2ZWM0IHBiclBhcmFtcztcXG4gIHZlYzQgZW1pc3NpdmU7XFxuICB2ZWM0IGVtaXNzaXZlU2NhbGVQYXJhbTtcXG59O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NTaGFkb3cge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFBsYW5lUHJvajtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0TGlnaHRWaWV3UHJvajtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dDb2xvcjtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dQQ0Y7XFxuICBsb3dwIHZlYzQgY2Nfc2hhZG93U2l6ZTtcXG59O1xcbiNpZiBIQVNfU0VDT05EX1VWIHx8IFVTRV9MSUdIVE1BUFxcbiAgaW4gdmVjMiBhX3RleENvb3JkMTtcXG4jZW5kaWZcXG5vdXQgdmVjMiB2X3V2O1xcbm91dCB2ZWMyIHZfdXYxO1xcbm91dCB2ZWMyIHZfY2xpcF9kZXB0aDtcXG52ZWM0IHZlcnQgKCkge1xcbiAgU3RhbmRhcmRWZXJ0SW5wdXQgSW47XFxuICBJbi5wb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gIEluLm5vcm1hbCA9IGFfbm9ybWFsO1xcbiAgSW4udGFuZ2VudCA9IGFfdGFuZ2VudDtcXG4gICNpZiBDQ19VU0VfTU9SUEhcXG4gICAgYXBwbHlNb3JwaChJbik7XFxuICAjZW5kaWZcXG4gICNpZiBDQ19VU0VfU0tJTk5JTkdcXG4gICAgQ0NTa2luKEluKTtcXG4gICNlbmRpZlxcbiAgbWF0NCBtYXRXb3JsZCwgbWF0V29ybGRJVDtcXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBtYXRXb3JsZCA9IG1hdDQoXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMS54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMi54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC53LCBhX21hdFdvcmxkMS53LCBhX21hdFdvcmxkMi53LCAxLjApXFxuICAgICk7XFxuICAgIG1hdFdvcmxkSVQgPSBtYXRXb3JsZDtcXG4gICNlbGlmIFVTRV9CQVRDSElOR1xcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkc1tpbnQoYV9keW5fYmF0Y2hfaWQpXTtcXG4gICAgbWF0V29ybGRJVCA9IG1hdFdvcmxkO1xcbiAgI2Vsc2VcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZDtcXG4gICAgbWF0V29ybGRJVCA9IGNjX21hdFdvcmxkSVQ7XFxuICAjZW5kaWZcXG4gIHZlYzQgd29ybGRQb3MgPSBtYXRXb3JsZCAqIEluLnBvc2l0aW9uO1xcbiAgdmVjNCBjbGlwUG9zID0gY2NfbWF0TGlnaHRWaWV3UHJvaiAqIHdvcmxkUG9zO1xcbiAgdl91diA9IGFfdGV4Q29vcmQgKiB0aWxpbmdPZmZzZXQueHkgKyB0aWxpbmdPZmZzZXQuenc7XFxuICAjaWYgSEFTX1NFQ09ORF9VVlxcbiAgICB2X3V2MSA9IGFfdGV4Q29vcmQxICogdGlsaW5nT2Zmc2V0Lnh5ICsgdGlsaW5nT2Zmc2V0Lnp3O1xcbiAgI2VuZGlmXFxuICB2X2NsaXBfZGVwdGggPSBjbGlwUG9zLnp3O1xcbiAgcmV0dXJuIGNsaXBQb3M7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDb25zdGFudHMge1xcbiAgdmVjNCB0aWxpbmdPZmZzZXQ7XFxuICB2ZWM0IGFsYmVkbztcXG4gIHZlYzQgYWxiZWRvU2NhbGVBbmRDdXRvZmY7XFxuICB2ZWM0IHBiclBhcmFtcztcXG4gIHZlYzQgZW1pc3NpdmU7XFxuICB2ZWM0IGVtaXNzaXZlU2NhbGVQYXJhbTtcXG59O1xcbnZlYzQgcGFja0RlcHRoVG9SR0JBIChmbG9hdCBkZXB0aCkge1xcbiAgdmVjNCByZXQgPSB2ZWM0KDEuMCwgMjU1LjAsIDY1MDI1LjAsIDE2MDU4MTM3NS4wKSAqIGRlcHRoO1xcbiAgcmV0ID0gZnJhY3QocmV0KTtcXG4gIHJldCAtPSByZXQueXp3dyAqIHZlYzQoMS4wIC8gMjU1LjAsIDEuMCAvIDI1NS4wLCAxLjAgLyAyNTUuMCwgMC4wKTtcXG4gIHJldHVybiByZXQ7XFxufVxcbmluIHZlYzIgdl91djtcXG5pbiB2ZWMyIHZfdXYxO1xcbmluIHZlYzIgdl9jbGlwX2RlcHRoO1xcbiNpZiBVU0VfQUxCRURPX01BUFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgYWxiZWRvTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfQUxQSEFfVEVTVFxcbiNlbmRpZlxcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IGJhc2VDb2xvciA9IGFsYmVkbztcXG4gICNpZiBVU0VfQUxCRURPX01BUFxcbiAgICBiYXNlQ29sb3IgKj0gdGV4dHVyZShhbGJlZG9NYXAsIEFMQkVET19VVik7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfQUxQSEFfVEVTVFxcbiAgICBpZiAoYmFzZUNvbG9yLkFMUEhBX1RFU1RfQ0hBTk5FTCA8IGFsYmVkb1NjYWxlQW5kQ3V0b2ZmLncpIGRpc2NhcmQ7XFxuICAjZW5kaWZcXG4gIHJldHVybiBwYWNrRGVwdGhUb1JHQkEodl9jbGlwX2RlcHRoLnggLyB2X2NsaXBfZGVwdGgueSAqIDAuNSArIDAuNSk7XFxufVxcbm91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xzbDFcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgcmdiYSA9IHJnYmEgKiAyNTUuMDtcXG4gIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyNy45OSwgcmdiYVszXSkgKiAyLjA7XFxuICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjcuOTkpICsgc3RlcCgxMjguMCwgcmdiYVsyXSkgLSAxMjcuMDtcXG4gIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG59XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX3RhbmdlbnQ7XFxuI2lmIENDX1VTRV9NT1JQSFxcbiAgICBhdHRyaWJ1dGUgZmxvYXQgYV92ZXJ0ZXhJZDtcXG4gICAgaW50IGdldFZlcnRleElkKCkge1xcbiAgICAgICAgcmV0dXJuIGludChhX3ZlcnRleElkKTtcXG4gICAgfVxcbnVuaWZvcm0gdmVjNCBjY19kaXNwbGFjZW1lbnRXZWlnaHRzWzE1XTtcXG51bmlmb3JtIHZlYzQgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm87XFxudmVjMiBnZXRQaXhlbExvY2F0aW9uKHZlYzIgdGV4dHVyZVJlc29sdXRpb24sIGludCBwaXhlbEluZGV4KSB7XFxuICAgIGZsb2F0IHBpeGVsSW5kZXhGID0gZmxvYXQocGl4ZWxJbmRleCk7XFxuICAgIGZsb2F0IHggPSBtb2QocGl4ZWxJbmRleEYsIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICBmbG9hdCB5ID0gZmxvb3IocGl4ZWxJbmRleEYgLyB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgcmV0dXJuIHZlYzIoeCwgeSk7XFxufVxcbnZlYzIgZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbih2ZWMyIGxvY2F0aW9uLCB2ZWMyIHRleHR1cmVSZXNvbHV0aW9uKSB7XFxuICAgIHJldHVybiAodmVjMihsb2NhdGlvbi54LCBsb2NhdGlvbi55KSArIC41KSAvIHRleHR1cmVSZXNvbHV0aW9uO1xcbn1cXG4jaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgICAgICB2ZWM0IGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IGVsZW1lbnRJbmRleCkge1xcbiAgICAgICAgICAgIGludCBwaXhlbEluZGV4ID0gZWxlbWVudEluZGV4O1xcbiAgICAgICAgICAgIHZlYzIgbG9jYXRpb24gPSBnZXRQaXhlbExvY2F0aW9uKGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5LCBwaXhlbEluZGV4KTtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCB1dik7XFxuICAgICAgICB9XFxuI2Vsc2VcXG4gICAgdmVjNCBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCBlbGVtZW50SW5kZXgpIHtcXG4gICAgICAgIGludCBwaXhlbEluZGV4ID0gZWxlbWVudEluZGV4ICogNDtcXG4gICAgICAgIHZlYzIgbG9jYXRpb24gPSBnZXRQaXhlbExvY2F0aW9uKGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5LCBwaXhlbEluZGV4KTtcXG4gICAgICAgIHZlYzIgeCA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDAuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB5ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMS4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICB2ZWMyIHogPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigyLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHJldHVybiB2ZWM0KFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUyRCh0ZXgsIHgpKSxcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQodGV4LCB5KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKHRleCwgeikpLFxcbiAgICAgICAgICAgIDEuMFxcbiAgICAgICAgKTtcXG4gICAgfVxcbiNlbmRpZlxcbmZsb2F0IGdldERpc3BsYWNlbWVudFdlaWdodChpbnQgaW5kZXgpIHtcXG4gICAgZmxvYXQgbSA9IG1vZChmbG9hdChpbmRleCksIDQuMCk7XFxuICAgIGlmIChtIDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLng7XFxuICAgIH0gZWxzZSBpZiAobSA8IDIuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS55O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAzLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0uejtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0udztcXG4gICAgfVxcbn1cXG52ZWMzIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgdmVydGV4SW5kZXgpIHtcXG4jaWYgQ0NfTU9SUEhfUFJFQ09NUFVURURcXG4gICAgcmV0dXJuIGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCB2ZXJ0ZXhJbmRleCkucmdiO1xcbiNlbHNlXFxuICAgIHZlYzMgcmVzdWx0ID0gdmVjMygwLCAwLCAwKTtcXG4gICAgZm9yIChpbnQgaVRhcmdldCA9IDA7IGlUYXJnZXQgPCBDQ19NT1JQSF9UQVJHRVRfQ09VTlQ7ICsraVRhcmdldCkge1xcbiAgICAgICAgaW50IGRhdGFQaXhlbFN0YXJ0ID0gaW50KGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBpVGFyZ2V0KS5yKTtcXG4gICAgICAgIHJlc3VsdCArPSAoZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZSh0ZXgsIGRhdGFQaXhlbFN0YXJ0ICsgdmVydGV4SW5kZXgpLnJnYiAqIGdldERpc3BsYWNlbWVudFdlaWdodChpVGFyZ2V0KSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4jZW5kaWZcXG59XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19Ob3JtYWxEaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldE5vcm1hbERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfTm9ybWFsRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19UYW5nZW50RGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19UYW5nZW50RGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxudm9pZCBhcHBseU1vcnBoIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICAgIGludCB2ZXJ0ZXhJZCA9IGdldFZlcnRleElkKCk7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgYXR0ci5wb3NpdGlvbi54eXogPSBhdHRyLnBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgYXR0ci5ub3JtYWwueHl6ID0gYXR0ci5ub3JtYWwueHl6ICsgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIGF0dHIudGFuZ2VudC54eXogPSBhdHRyLnRhbmdlbnQueHl6ICsgZ2V0VGFuZ2VudERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxufVxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHBvc2l0aW9uLnh5eiA9IHBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGdldFZlcnRleElkKCkpO1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX1NLSU5OSU5HXFxuYXR0cmlidXRlIHZlYzQgYV9qb2ludHM7XFxuYXR0cmlidXRlIHZlYzQgYV93ZWlnaHRzO1xcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgYXR0cmlidXRlIGhpZ2hwIHZlYzQgYV9qb2ludEFuaW1JbmZvO1xcbiAgI2VuZGlmXFxuICB1bmlmb3JtIGhpZ2hwIHZlYzQgY2Nfam9pbnRUZXh0dXJlSW5mbztcXG4gIHVuaWZvcm0gaGlnaHAgdmVjNCBjY19qb2ludEFuaW1JbmZvO1xcbiAgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgY2Nfam9pbnRUZXh0dXJlO1xcbiAgI2Vsc2VcXG4gIHVuaWZvcm0gaGlnaHAgdmVjNCBjY19qb2ludHNbOTBdO1xcbiNlbmRpZlxcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MiA9IHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAzLjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MiA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjMgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDguNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDkuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMS41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgIGludCBpZHggPSBpbnQoaSk7XFxuICAgIHZlYzQgdjEgPSBjY19qb2ludHNbaWR4ICogM107XFxuICAgIHZlYzQgdjIgPSBjY19qb2ludHNbaWR4ICogMyArIDFdO1xcbiAgICB2ZWM0IHYzID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAyXTtcXG4gICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gIH1cXG4jZW5kaWZcXG5tYXQ0IHNraW5NYXRyaXggKCkge1xcbiAgcmV0dXJuIGdldEpvaW50TWF0cml4KGFfam9pbnRzLngpICogYV93ZWlnaHRzLnhcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy55KSAqIGFfd2VpZ2h0cy55XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueikgKiBhX3dlaWdodHMuelxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLncpICogYV93ZWlnaHRzLnc7XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBwb3NpdGlvbiA9IG0gKiBwb3NpdGlvbjtcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIGF0dHIucG9zaXRpb24gPSBtICogYXR0ci5wb3NpdGlvbjtcXG4gIGF0dHIubm9ybWFsID0gKG0gKiB2ZWM0KGF0dHIubm9ybWFsLCAwLjApKS54eXo7XFxuICBhdHRyLnRhbmdlbnQueHl6ID0gKG0gKiB2ZWM0KGF0dHIudGFuZ2VudC54eXosIDAuMCkpLnh5ejtcXG59XFxuI2VuZGlmXFxuI2lmIFVTRV9JTlNUQU5DSU5HXFxuICBhdHRyaWJ1dGUgdmVjNCBhX21hdFdvcmxkMDtcXG4gIGF0dHJpYnV0ZSB2ZWM0IGFfbWF0V29ybGQxO1xcbiAgYXR0cmlidXRlIHZlYzQgYV9tYXRXb3JsZDI7XFxuICAjaWYgVVNFX0xJR0hUTUFQXFxuICAgIGF0dHJpYnV0ZSB2ZWM0IGFfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbiAgI2VuZGlmXFxuI2VsaWYgVVNFX0JBVENISU5HXFxuICBhdHRyaWJ1dGUgZmxvYXQgYV9keW5fYmF0Y2hfaWQ7XFxuICB1bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRzWzEwXTtcXG4jZWxzZVxcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4jZW5kaWZcXG51bmlmb3JtIHZlYzQgdGlsaW5nT2Zmc2V0O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRMaWdodFZpZXdQcm9qO1xcbiNpZiBIQVNfU0VDT05EX1VWIHx8IFVTRV9MSUdIVE1BUFxcbiAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDE7XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMyIHZfdXY7XFxudmFyeWluZyB2ZWMyIHZfdXYxO1xcbnZhcnlpbmcgdmVjMiB2X2NsaXBfZGVwdGg7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIFN0YW5kYXJkVmVydElucHV0IEluO1xcbiAgSW4ucG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBJbi5ub3JtYWwgPSBhX25vcm1hbDtcXG4gIEluLnRhbmdlbnQgPSBhX3RhbmdlbnQ7XFxuICAjaWYgQ0NfVVNFX01PUlBIXFxuICAgIGFwcGx5TW9ycGgoSW4pO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfVVNFX1NLSU5OSU5HXFxuICAgIENDU2tpbihJbik7XFxuICAjZW5kaWZcXG4gIG1hdDQgbWF0V29ybGQsIG1hdFdvcmxkSVQ7XFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgbWF0V29ybGQgPSBtYXQ0KFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDEueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDIueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAudywgYV9tYXRXb3JsZDEudywgYV9tYXRXb3JsZDIudywgMS4wKVxcbiAgICApO1xcbiAgICBtYXRXb3JsZElUID0gbWF0V29ybGQ7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAgIG1hdFdvcmxkSVQgPSBtYXRXb3JsZDtcXG4gICNlbHNlXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGQ7XFxuICAgIG1hdFdvcmxkSVQgPSBjY19tYXRXb3JsZElUO1xcbiAgI2VuZGlmXFxuICB2ZWM0IHdvcmxkUG9zID0gbWF0V29ybGQgKiBJbi5wb3NpdGlvbjtcXG4gIHZlYzQgY2xpcFBvcyA9IGNjX21hdExpZ2h0Vmlld1Byb2ogKiB3b3JsZFBvcztcXG4gIHZfdXYgPSBhX3RleENvb3JkICogdGlsaW5nT2Zmc2V0Lnh5ICsgdGlsaW5nT2Zmc2V0Lnp3O1xcbiAgI2lmIEhBU19TRUNPTkRfVVZcXG4gICAgdl91djEgPSBhX3RleENvb3JkMSAqIHRpbGluZ09mZnNldC54eSArIHRpbGluZ09mZnNldC56dztcXG4gICNlbmRpZlxcbiAgdl9jbGlwX2RlcHRoID0gY2xpcFBvcy56dztcXG4gIHJldHVybiBjbGlwUG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCBhbGJlZG87XFxudW5pZm9ybSB2ZWM0IGFsYmVkb1NjYWxlQW5kQ3V0b2ZmO1xcbnZlYzQgcGFja0RlcHRoVG9SR0JBIChmbG9hdCBkZXB0aCkge1xcbiAgdmVjNCByZXQgPSB2ZWM0KDEuMCwgMjU1LjAsIDY1MDI1LjAsIDE2MDU4MTM3NS4wKSAqIGRlcHRoO1xcbiAgcmV0ID0gZnJhY3QocmV0KTtcXG4gIHJldCAtPSByZXQueXp3dyAqIHZlYzQoMS4wIC8gMjU1LjAsIDEuMCAvIDI1NS4wLCAxLjAgLyAyNTUuMCwgMC4wKTtcXG4gIHJldHVybiByZXQ7XFxufVxcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnZhcnlpbmcgdmVjMiB2X3V2MTtcXG52YXJ5aW5nIHZlYzIgdl9jbGlwX2RlcHRoO1xcbiNpZiBVU0VfQUxCRURPX01BUFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgYWxiZWRvTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfQUxQSEFfVEVTVFxcbiNlbmRpZlxcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IGJhc2VDb2xvciA9IGFsYmVkbztcXG4gICNpZiBVU0VfQUxCRURPX01BUFxcbiAgICBiYXNlQ29sb3IgKj0gdGV4dHVyZTJEKGFsYmVkb01hcCwgQUxCRURPX1VWKTtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTFBIQV9URVNUXFxuICAgIGlmIChiYXNlQ29sb3IuQUxQSEFfVEVTVF9DSEFOTkVMIDwgYWxiZWRvU2NhbGVBbmRDdXRvZmYudykgZGlzY2FyZDtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIHBhY2tEZXB0aFRvUkdCQSh2X2NsaXBfZGVwdGgueCAvIHZfY2xpcF9kZXB0aC55ICogMC41ICsgMC41KTtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2w0XCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxuI2lmZGVmIEdMX0VYVF9zaGFkZXJfZXhwbGljaXRfYXJpdGhtZXRpY190eXBlc19pbnQxNlxcbiNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2ludDE2OiBlbmFibGVcXG4jZW5kaWZcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgcmdiYSA9IHJnYmEgKiAyNTUuMDtcXG4gIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyNy45OSwgcmdiYVszXSkgKiAyLjA7XFxuICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjcuOTkpICsgc3RlcCgxMjguMCwgcmdiYVsyXSkgLSAxMjcuMDtcXG4gIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG59XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzMgYV9wb3NpdGlvbjtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMzIGFfbm9ybWFsO1xcbmxheW91dChsb2NhdGlvbiA9IDIpIGluIHZlYzIgYV90ZXhDb29yZDtcXG5sYXlvdXQobG9jYXRpb24gPSAzKSBpbiB2ZWM0IGFfdGFuZ2VudDtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGludCBnZXRWZXJ0ZXhJZCgpIHtcXG4gICAgICAgIHJldHVybiBnbF9WZXJ0ZXhJbmRleDtcXG4gICAgfVxcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gNCkgdW5pZm9ybSBDQ01vcnBoIHtcXG4gICAgdmVjNCBjY19kaXNwbGFjZW1lbnRXZWlnaHRzWzE1XTtcXG4gICAgdmVjNCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mbztcXG59O1xcbnZlYzIgZ2V0UGl4ZWxMb2NhdGlvbih2ZWMyIHRleHR1cmVSZXNvbHV0aW9uLCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICBmbG9hdCBwaXhlbEluZGV4RiA9IGZsb2F0KHBpeGVsSW5kZXgpO1xcbiAgICBmbG9hdCB4ID0gbW9kKHBpeGVsSW5kZXhGLCB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgZmxvYXQgeSA9IGZsb29yKHBpeGVsSW5kZXhGIC8gdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgIHJldHVybiB2ZWMyKHgsIHkpO1xcbn1cXG52ZWMyIGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24odmVjMiBsb2NhdGlvbiwgdmVjMiB0ZXh0dXJlUmVzb2x1dGlvbikge1xcbiAgICByZXR1cm4gKHZlYzIobG9jYXRpb24ueCwgbG9jYXRpb24ueSkgKyAuNSkgLyB0ZXh0dXJlUmVzb2x1dGlvbjtcXG59XFxuI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICAgICAgdmVjNCBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCBwaXhlbEluZGV4KSB7XFxuICAgICAgICAgICAgaXZlYzIgdGV4U2l6ZSA9IHRleHR1cmVTaXplKHRleCwgMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRleGVsRmV0Y2godGV4LCBpdmVjMihwaXhlbEluZGV4ICUgdGV4U2l6ZS54LCBwaXhlbEluZGV4IC8gdGV4U2l6ZS54KSwgMCk7XFxuICAgICAgICB9XFxuI2Vsc2VcXG4gICAgdmVjNCBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCBlbGVtZW50SW5kZXgpIHtcXG4gICAgICAgIGludCBwaXhlbEluZGV4ID0gZWxlbWVudEluZGV4ICogNDtcXG4gICAgICAgIHZlYzIgbG9jYXRpb24gPSBnZXRQaXhlbExvY2F0aW9uKGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5LCBwaXhlbEluZGV4KTtcXG4gICAgICAgIHZlYzIgeCA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDAuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB5ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMS4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICB2ZWMyIHogPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigyLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHJldHVybiB2ZWM0KFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUodGV4LCB4KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZSh0ZXgsIHkpKSxcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKHRleCwgeikpLFxcbiAgICAgICAgICAgIDEuMFxcbiAgICAgICAgKTtcXG4gICAgfVxcbiNlbmRpZlxcbmZsb2F0IGdldERpc3BsYWNlbWVudFdlaWdodChpbnQgaW5kZXgpIHtcXG4gICAgZmxvYXQgbSA9IG1vZChmbG9hdChpbmRleCksIDQuMCk7XFxuICAgIGlmIChtIDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLng7XFxuICAgIH0gZWxzZSBpZiAobSA8IDIuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS55O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAzLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0uejtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0udztcXG4gICAgfVxcbn1cXG52ZWMzIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgdmVydGV4SW5kZXgpIHtcXG4jaWYgQ0NfTU9SUEhfUFJFQ09NUFVURURcXG4gICAgcmV0dXJuIGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCB2ZXJ0ZXhJbmRleCkucmdiO1xcbiNlbHNlXFxuICAgIHZlYzMgcmVzdWx0ID0gdmVjMygwLCAwLCAwKTtcXG4gICAgZm9yIChpbnQgaVRhcmdldCA9IDA7IGlUYXJnZXQgPCBDQ19NT1JQSF9UQVJHRVRfQ09VTlQ7ICsraVRhcmdldCkge1xcbiAgICAgICAgaW50IGRhdGFQaXhlbFN0YXJ0ID0gaW50KGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBpVGFyZ2V0KS5yKTtcXG4gICAgICAgIHJlc3VsdCArPSAoZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZSh0ZXgsIGRhdGFQaXhlbFN0YXJ0ICsgdmVydGV4SW5kZXgpLnJnYiAqIGdldERpc3BsYWNlbWVudFdlaWdodChpVGFyZ2V0KSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4jZW5kaWZcXG59XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSA2KSB1bmlmb3JtIHNhbXBsZXIyRCBjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gNykgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSA4KSB1bmlmb3JtIHNhbXBsZXIyRCBjY19UYW5nZW50RGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19UYW5nZW50RGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxudm9pZCBhcHBseU1vcnBoIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICAgIGludCB2ZXJ0ZXhJZCA9IGdldFZlcnRleElkKCk7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgYXR0ci5wb3NpdGlvbi54eXogPSBhdHRyLnBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgYXR0ci5ub3JtYWwueHl6ID0gYXR0ci5ub3JtYWwueHl6ICsgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIGF0dHIudGFuZ2VudC54eXogPSBhdHRyLnRhbmdlbnQueHl6ICsgZ2V0VGFuZ2VudERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxufVxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHBvc2l0aW9uLnh5eiA9IHBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGdldFZlcnRleElkKCkpO1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX1NLSU5OSU5HXFxubGF5b3V0KGxvY2F0aW9uID0gNCkgaW4gdTE2dmVjNCBhX2pvaW50cztcXG5sYXlvdXQobG9jYXRpb24gPSA1KSBpbiB2ZWM0IGFfd2VpZ2h0cztcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIGxheW91dChsb2NhdGlvbiA9IDcpIGluIGhpZ2hwIHZlYzQgYV9qb2ludEFuaW1JbmZvO1xcbiAgI2VuZGlmXFxuICBsYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDMpIHVuaWZvcm0gQ0NTa2lubmluZ1RleHR1cmUge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50VGV4dHVyZUluZm87XFxuICB9O1xcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAyKSB1bmlmb3JtIENDU2tpbm5pbmdBbmltYXRpb24ge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50QW5pbUluZm87XFxuICB9O1xcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSA1KSB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBjY19qb2ludFRleHR1cmU7XFxuICAjZWxzZVxcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAzKSB1bmlmb3JtIENDU2tpbm5pbmcge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50c1szMCAqIDNdO1xcbiAgfTtcXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYyID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDMuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYyID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDUuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA2LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjMgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA4LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgOS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTEuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4jZWxzZVxcbiAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICBpbnQgaWR4ID0gaW50KGkpO1xcbiAgICB2ZWM0IHYxID0gY2Nfam9pbnRzW2lkeCAqIDNdO1xcbiAgICB2ZWM0IHYyID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAxXTtcXG4gICAgdmVjNCB2MyA9IGNjX2pvaW50c1tpZHggKiAzICsgMl07XFxuICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICB9XFxuI2VuZGlmXFxubWF0NCBza2luTWF0cml4ICgpIHtcXG4gIHJldHVybiBnZXRKb2ludE1hdHJpeChhX2pvaW50cy54KSAqIGFfd2VpZ2h0cy54XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueSkgKiBhX3dlaWdodHMueVxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnopICogYV93ZWlnaHRzLnpcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy53KSAqIGFfd2VpZ2h0cy53O1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgcG9zaXRpb24gPSBtICogcG9zaXRpb247XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBhdHRyLnBvc2l0aW9uID0gbSAqIGF0dHIucG9zaXRpb247XFxuICBhdHRyLm5vcm1hbCA9IChtICogdmVjNChhdHRyLm5vcm1hbCwgMC4wKSkueHl6O1xcbiAgYXR0ci50YW5nZW50Lnh5eiA9IChtICogdmVjNChhdHRyLnRhbmdlbnQueHl6LCAwLjApKS54eXo7XFxufVxcbiNlbmRpZlxcbiNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gOCkgaW4gdmVjNCBhX21hdFdvcmxkMDtcXG4gIGxheW91dChsb2NhdGlvbiA9IDkpIGluIHZlYzQgYV9tYXRXb3JsZDE7XFxuICBsYXlvdXQobG9jYXRpb24gPSAxMCkgaW4gdmVjNCBhX21hdFdvcmxkMjtcXG4gICNpZiBVU0VfTElHSFRNQVBcXG4gICAgbGF5b3V0KGxvY2F0aW9uID0gMTEpIGluIHZlYzQgYV9saWdodGluZ01hcFVWUGFyYW07XFxuICAjZW5kaWZcXG4jZWxpZiBVU0VfQkFUQ0hJTkdcXG4gIGxheW91dChsb2NhdGlvbiA9IDEyKSBpbiBmbG9hdCBhX2R5bl9iYXRjaF9pZDtcXG4gIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0xvY2FsQmF0Y2hlZCB7XFxuICAgIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRzWzEwXTtcXG4gIH07XFxuI2Vsc2VcXG5sYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NMb2NhbCB7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZElUO1xcbiAgaGlnaHAgdmVjNCBjY19saWdodGluZ01hcFVWUGFyYW07XFxufTtcXG4jZW5kaWZcXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDApIHVuaWZvcm0gQ29uc3RhbnRzIHtcXG4gIHZlYzQgdGlsaW5nT2Zmc2V0O1xcbiAgdmVjNCBhbGJlZG87XFxuICB2ZWM0IGFsYmVkb1NjYWxlQW5kQ3V0b2ZmO1xcbiAgdmVjNCBwYnJQYXJhbXM7XFxuICB2ZWM0IGVtaXNzaXZlO1xcbiAgdmVjNCBlbWlzc2l2ZVNjYWxlUGFyYW07XFxufTtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDEpIHVuaWZvcm0gQ0NTaGFkb3cge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFBsYW5lUHJvajtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0TGlnaHRWaWV3UHJvajtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dDb2xvcjtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dQQ0Y7XFxuICBsb3dwIHZlYzQgY2Nfc2hhZG93U2l6ZTtcXG59O1xcbiNpZiBIQVNfU0VDT05EX1VWIHx8IFVTRV9MSUdIVE1BUFxcbiAgbGF5b3V0KGxvY2F0aW9uID0gMTMpIGluIHZlYzIgYV90ZXhDb29yZDE7XFxuI2VuZGlmXFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzIgdl91djtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBvdXQgdmVjMiB2X3V2MTtcXG5sYXlvdXQobG9jYXRpb24gPSAyKSBvdXQgdmVjMiB2X2NsaXBfZGVwdGg7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIFN0YW5kYXJkVmVydElucHV0IEluO1xcbiAgSW4ucG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBJbi5ub3JtYWwgPSBhX25vcm1hbDtcXG4gIEluLnRhbmdlbnQgPSBhX3RhbmdlbnQ7XFxuICAjaWYgQ0NfVVNFX01PUlBIXFxuICAgIGFwcGx5TW9ycGgoSW4pO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfVVNFX1NLSU5OSU5HXFxuICAgIENDU2tpbihJbik7XFxuICAjZW5kaWZcXG4gIG1hdDQgbWF0V29ybGQsIG1hdFdvcmxkSVQ7XFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgbWF0V29ybGQgPSBtYXQ0KFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDEueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDIueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAudywgYV9tYXRXb3JsZDEudywgYV9tYXRXb3JsZDIudywgMS4wKVxcbiAgICApO1xcbiAgICBtYXRXb3JsZElUID0gbWF0V29ybGQ7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAgIG1hdFdvcmxkSVQgPSBtYXRXb3JsZDtcXG4gICNlbHNlXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGQ7XFxuICAgIG1hdFdvcmxkSVQgPSBjY19tYXRXb3JsZElUO1xcbiAgI2VuZGlmXFxuICB2ZWM0IHdvcmxkUG9zID0gbWF0V29ybGQgKiBJbi5wb3NpdGlvbjtcXG4gIHZlYzQgY2xpcFBvcyA9IGNjX21hdExpZ2h0Vmlld1Byb2ogKiB3b3JsZFBvcztcXG4gIHZfdXYgPSBhX3RleENvb3JkICogdGlsaW5nT2Zmc2V0Lnh5ICsgdGlsaW5nT2Zmc2V0Lnp3O1xcbiAgI2lmIEhBU19TRUNPTkRfVVZcXG4gICAgdl91djEgPSBhX3RleENvb3JkMSAqIHRpbGluZ09mZnNldC54eSArIHRpbGluZ09mZnNldC56dztcXG4gICNlbmRpZlxcbiAgdl9jbGlwX2RlcHRoID0gY2xpcFBvcy56dztcXG4gIHJldHVybiBjbGlwUG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDb25zdGFudHMge1xcbiAgdmVjNCB0aWxpbmdPZmZzZXQ7XFxuICB2ZWM0IGFsYmVkbztcXG4gIHZlYzQgYWxiZWRvU2NhbGVBbmRDdXRvZmY7XFxuICB2ZWM0IHBiclBhcmFtcztcXG4gIHZlYzQgZW1pc3NpdmU7XFxuICB2ZWM0IGVtaXNzaXZlU2NhbGVQYXJhbTtcXG59O1xcbnZlYzQgcGFja0RlcHRoVG9SR0JBIChmbG9hdCBkZXB0aCkge1xcbiAgdmVjNCByZXQgPSB2ZWM0KDEuMCwgMjU1LjAsIDY1MDI1LjAsIDE2MDU4MTM3NS4wKSAqIGRlcHRoO1xcbiAgcmV0ID0gZnJhY3QocmV0KTtcXG4gIHJldCAtPSByZXQueXp3dyAqIHZlYzQoMS4wIC8gMjU1LjAsIDEuMCAvIDI1NS4wLCAxLjAgLyAyNTUuMCwgMC4wKTtcXG4gIHJldHVybiByZXQ7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzIgdl91djtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMyIHZfdXYxO1xcbmxheW91dChsb2NhdGlvbiA9IDIpIGluIHZlYzIgdl9jbGlwX2RlcHRoO1xcbiNpZiBVU0VfQUxCRURPX01BUFxcbiAgbGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSAxKSB1bmlmb3JtIHNhbXBsZXIyRCBhbGJlZG9NYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9BTFBIQV9URVNUXFxuI2VuZGlmXFxudmVjNCBmcmFnICgpIHtcXG4gIHZlYzQgYmFzZUNvbG9yID0gYWxiZWRvO1xcbiAgI2lmIFVTRV9BTEJFRE9fTUFQXFxuICAgIGJhc2VDb2xvciAqPSB0ZXh0dXJlKGFsYmVkb01hcCwgQUxCRURPX1VWKTtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTFBIQV9URVNUXFxuICAgIGlmIChiYXNlQ29sb3IuQUxQSEFfVEVTVF9DSEFOTkVMIDwgYWxiZWRvU2NhbGVBbmRDdXRvZmYudykgZGlzY2FyZDtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIHBhY2tEZXB0aFRvUkdCQSh2X2NsaXBfZGVwdGgueCAvIHZfY2xpcF9kZXB0aC55ICogMC41ICsgMC41KTtcXG59XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ1NoYWRvd1wiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NNb3JwaFwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTa2lubmluZ1RleHR1cmVcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJDQ1NraW5uaW5nQW5pbWF0aW9uXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTa2lubmluZ1wiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiIUNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJDQ0xvY2FsQmF0Y2hlZFwiLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiVVNFX0JBVENISU5HXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NMb2NhbFwiLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiIVVTRV9CQVRDSElOR1wiXSB9XSwgXCJzYW1wbGVyc1wiOiBbeyBcIm5hbWVcIjogXCJjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHNcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiLCBcIkNDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJjY19Ob3JtYWxEaXNwbGFjZW1lbnRzXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIiwgXCJDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFwiXSB9LCB7IFwibmFtZVwiOiBcImNjX1RhbmdlbnREaXNwbGFjZW1lbnRzXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIiwgXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcIl0gfSwgeyBcIm5hbWVcIjogXCJjY19qb2ludFRleHR1cmVcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfV0gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZpbmVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX01PUlBIXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9UQVJHRVRfQ09VTlRcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzIsIDhdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfUFJFQ09NUFVURURcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9TS0lOTklOR1wiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX0lOU1RBTkNJTkdcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9CQVRDSElOR1wiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX0xJR0hUTUFQXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJIQVNfU0VDT05EX1VWXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfQUxCRURPX01BUFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQUxCRURPX1VWXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm9wdGlvbnNcIjogW1widl91dlwiLCBcInZfdXYxXCJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9BTFBIQV9URVNUXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJBTFBIQV9URVNUX0NIQU5ORUxcIiwgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwib3B0aW9uc1wiOiBbXCJhXCIsIFwiclwiXSB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImJsb2Nrc1wiOiBbXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiQ29uc3RhbnRzXCIsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDAsIFwic3RhZ2VGbGFnc1wiOiAxNywgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ0aWxpbmdPZmZzZXRcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJhbGJlZG9cIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJhbGJlZG9TY2FsZUFuZEN1dG9mZlwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInBiclBhcmFtc1wiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcImVtaXNzaXZlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH0sXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW1pc3NpdmVTY2FsZVBhcmFtXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcInNhbXBsZXJzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYWxiZWRvTWFwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0FMQkVET19NQVBcIl0sIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJiaW5kaW5nXCI6IDEgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX25vcm1hbFwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkXCIsIFwidHlwZVwiOiAxNCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAyMSwgXCJsb2NhdGlvblwiOiAyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGFuZ2VudFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3ZlcnRleElkXCIsIFwidHlwZVwiOiAxMywgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMTEsIFwibG9jYXRpb25cIjogNiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2pvaW50c1wiLCBcInR5cGVcIjogMTIsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQyLCBcImxvY2F0aW9uXCI6IDQgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV93ZWlnaHRzXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogNSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2pvaW50QW5pbUluZm9cIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCIsIFwiVVNFX0lOU1RBTkNJTkdcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDcgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9tYXRXb3JsZDBcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfSU5TVEFOQ0lOR1wiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQ0LCBcImlzSW5zdGFuY2VkXCI6IHRydWUsIFwibG9jYXRpb25cIjogOCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX21hdFdvcmxkMVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9JTlNUQU5DSU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiA5IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbWF0V29ybGQyXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDEwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbGlnaHRpbmdNYXBVVlBhcmFtXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIiwgXCJVU0VfTElHSFRNQVBcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDExIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfZHluX2JhdGNoX2lkXCIsIFwidHlwZVwiOiAxMywgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiVVNFX0JBVENISU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMTEsIFwibG9jYXRpb25cIjogMTIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZDFcIiwgXCJ0eXBlXCI6IDE0LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDIxLCBcImxvY2F0aW9uXCI6IDEzIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tdGVycmFpblwiLFxyXG4gICAgXCJfdXVpZFwiOiBcIjFkMDhlZjYyLWE1MDMtNGNlMi04YjlhLTQ2YzkwODczZjdkM1wiLFxyXG4gICAgXCJ0ZWNobmlxdWVzXCI6IFtcclxuICAgICAgeyBcIm5hbWVcIjogXCJvcGFxdWVcIiwgXCJwYXNzZXNcIjogW3sgXCJwcm9ncmFtXCI6IFwiYnVpbHRpbi10ZXJyYWlufHRlcnJhaW4tdnM6dmVydHx0ZXJyYWluLWZzOmZyYWdcIiwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJVVlNjYWxlXCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMSwgMV0sIFwidHlwZVwiOiAxNiB9LCBcImxpZ2h0TWFwVVZQYXJhbVwiOiB7IFwidmFsdWVcIjogWzAsIDAsIDAsIDBdLCBcInR5cGVcIjogMTYgfSwgXCJ3ZWlnaHRNYXBcIjogeyBcInZhbHVlXCI6IFwiYmxhY2tcIiwgXCJ0eXBlXCI6IDI4IH0sIFwiZGV0YWlsTWFwMFwiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcImRldGFpbE1hcDFcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjggfSwgXCJkZXRhaWxNYXAyXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0sIFwiZGV0YWlsTWFwM1wiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcImxpZ2h0TWFwXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0gfSB9XSB9XHJcbiAgICBdLFxyXG4gICAgXCJzaGFkZXJzXCI6IFtcclxuICAgICAge1xyXG4gICAgICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tdGVycmFpbnx0ZXJyYWluLXZzOnZlcnR8dGVycmFpbi1mczpmcmFnXCIsXHJcbiAgICAgICAgXCJoYXNoXCI6IDI5ODg1NjMzMSxcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxuICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxuZmxvYXQgTGluZWFyRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgY2FtX2RpcyA9IGRpc3RhbmNlKGNjX2NhbWVyYVBvcywgd1Bvcyk7XFxuICAgIGZsb2F0IGZvZ1N0YXJ0ID0gY2NfZm9nQmFzZS54O1xcbiAgICBmbG9hdCBmb2dFbmQgPSBjY19mb2dCYXNlLnk7XFxuICAgIHJldHVybiBjbGFtcCgoZm9nRW5kIC0gY2FtX2RpcykgLyAoZm9nRW5kIC0gZm9nU3RhcnQpLCAwLiwgMS4pO1xcbn1cXG5mbG9hdCBFeHBGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBmb2dBdHRlbiA9IGNjX2ZvZ0FkZC56O1xcbiAgICBmbG9hdCBmb2dEZW5zaXR5ID0gY2NfZm9nQmFzZS56O1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKSAvIGZvZ0F0dGVuICogNC47XFxuICAgIGZsb2F0IGYgPSBleHAoLWNhbV9kaXMgKiBmb2dEZW5zaXR5KTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbmZsb2F0IEV4cFNxdWFyZWRGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBmb2dBdHRlbiA9IGNjX2ZvZ0FkZC56O1xcbiAgICBmbG9hdCBmb2dEZW5zaXR5ID0gY2NfZm9nQmFzZS56O1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKSAvIGZvZ0F0dGVuICogNC47XFxuICAgIGZsb2F0IGYgPSBleHAoLWNhbV9kaXMgKiBjYW1fZGlzICogZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkpO1xcbiAgICByZXR1cm4gZjtcXG59XFxuZmxvYXQgTGF5ZXJlZEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IF9Gb2dUb3AgPSBjY19mb2dBZGQueDtcXG4gICAgZmxvYXQgX0ZvZ1JhbmdlID0gY2NfZm9nQWRkLnk7XFxuICAgIHZlYzMgY2FtV29ybGRQcm9qID0gY2NfY2FtZXJhUG9zLnh5ejtcXG4gICAgY2FtV29ybGRQcm9qLnkgPSAwLjtcXG4gICAgdmVjMyB3b3JsZFBvc1Byb2ogPSB3UG9zLnh5ejtcXG4gICAgd29ybGRQb3NQcm9qLnkgPSAwLjtcXG4gICAgZmxvYXQgZkRlbHRhRCA9IGRpc3RhbmNlKHdvcmxkUG9zUHJvaiwgY2FtV29ybGRQcm9qKSAvIGZvZ0F0dGVuICogMi4wO1xcbiAgICBmbG9hdCBmRGVsdGFZLCBmRGVuc2l0eUludGVncmFsO1xcbiAgICBpZiAoY2NfY2FtZXJhUG9zLnkgPiBfRm9nVG9wKSB7XFxuICAgICAgICBpZiAod1Bvcy55IDwgX0ZvZ1RvcCkge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSAoX0ZvZ1RvcCAtIHdQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjA7XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGZEZWx0YVkgKiBmRGVsdGFZICogMC41O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmRGVsdGFZID0gMC47XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IDAuO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHdQb3MueSA8IF9Gb2dUb3ApIHtcXG4gICAgICAgICAgICBmbG9hdCBmRGVsdGFBID0gKF9Gb2dUb3AgLSBjY19jYW1lcmFQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjtcXG4gICAgICAgICAgICBmbG9hdCBmRGVsdGFCID0gKF9Gb2dUb3AgLSB3UG9zLnkpIC8gX0ZvZ1JhbmdlICogMi47XFxuICAgICAgICAgICAgZkRlbHRhWSA9IGFicyhmRGVsdGFBIC0gZkRlbHRhQik7XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGFicygoZkRlbHRhQSAqIGZEZWx0YUEgKiAwLjUpIC0gKGZEZWx0YUIgKiBmRGVsdGFCICogMC41KSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSBhYnMoX0ZvZ1RvcCAtIGNjX2NhbWVyYVBvcy55KSAvIF9Gb2dSYW5nZSAqIDIuO1xcbiAgICAgICAgICAgIGZEZW5zaXR5SW50ZWdyYWwgPSBhYnMoZkRlbHRhWSAqIGZEZWx0YVkgKiAwLjUpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGZEZW5zaXR5O1xcbiAgICBpZiAoZkRlbHRhWSAhPSAwLikge1xcbiAgICAgICAgZkRlbnNpdHkgPSAoc3FydCgxLjAgKyAoKGZEZWx0YUQgLyBmRGVsdGFZKSAqIChmRGVsdGFEIC8gZkRlbHRhWSkpKSkgKiBmRGVuc2l0eUludGVncmFsO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZkRlbnNpdHkgPSAwLjtcXG4gICAgfVxcbiAgICBmbG9hdCBmID0gZXhwKC1mRGVuc2l0eSk7XFxuICAgIHJldHVybiBmO1xcbn1cXG5mbG9hdCBDQ19UUkFOU0ZFUl9GT0codmVjNCBwb3MpIHtcXG4gICAgI2lmIENDX1VTRV9GT0cgPT0gMVxcbiAgICAgICAgcmV0dXJuIExpbmVhckZvZyhwb3MpO1xcblx0I2VsaWYgQ0NfVVNFX0ZPRyA9PSAyXFxuICAgICAgICByZXR1cm4gRXhwRm9nKHBvcyk7XFxuICAgICNlbGlmIENDX1VTRV9GT0cgPT0gM1xcbiAgICAgICAgcmV0dXJuIEV4cFNxdWFyZWRGb2cocG9zKTtcXG4gICAgI2VsaWYgQ0NfVVNFX0ZPRyA9PSA0XFxuICAgICAgICByZXR1cm4gTGF5ZXJlZEZvZyhwb3MpO1xcbiAgICAjZW5kaWZcXG4gICAgcmV0dXJuIDEuO1xcbn1cXG4gIGluIHZlYzMgYV9wb3NpdGlvbjtcXG4gIGluIHZlYzMgYV9ub3JtYWw7XFxuICBpbiB2ZWMyIGFfdGV4Q29vcmQ7XFxuICBvdXQgdmVjMiB1dnc7XFxuICBvdXQgdmVjMiB1djA7XFxuICBvdXQgdmVjMiB1djE7XFxuICBvdXQgdmVjMiB1djI7XFxuICBvdXQgdmVjMiB1djM7XFxuICBvdXQgdmVjMiBsdXY7XFxuICBvdXQgdmVjMyBkaWZmdXNlO1xcbiAgb3V0IGZsb2F0IGZhY3Rvcl9mb2c7XFxuICBsYXlvdXQoc3RkMTQwKSB1bmlmb3JtIFRleENvb3JkcyB7XFxuICAgIHZlYzQgVVZTY2FsZTtcXG4gICAgdmVjNCBsaWdodE1hcFVWUGFyYW07XFxuICB9O1xcbiAgdmVjNCB2ZXJ0ICgpIHtcXG4gICAgdmVjMyB3b3JsZFBvcztcXG4gICAgd29ybGRQb3MueCA9IGNjX21hdFdvcmxkWzNdWzBdICsgYV9wb3NpdGlvbi54O1xcbiAgICB3b3JsZFBvcy55ID0gY2NfbWF0V29ybGRbM11bMV0gKyBhX3Bvc2l0aW9uLnk7XFxuICAgIHdvcmxkUG9zLnogPSBjY19tYXRXb3JsZFszXVsyXSArIGFfcG9zaXRpb24uejtcXG4gICAgdmVjNCBwb3MgPSB2ZWM0KHdvcmxkUG9zLCAxKTtcXG4gICAgcG9zID0gY2NfbWF0Vmlld1Byb2ogKiBwb3M7XFxuICAgIHV2dyA9IGFfdGV4Q29vcmQ7XFxuICAgIHV2MCA9IGFfcG9zaXRpb24ueHogKiBVVlNjYWxlLng7XFxuICAgIHV2MSA9IGFfcG9zaXRpb24ueHogKiBVVlNjYWxlLnk7XFxuICAgIHV2MiA9IGFfcG9zaXRpb24ueHogKiBVVlNjYWxlLno7XFxuICAgIHV2MyA9IGFfcG9zaXRpb24ueHogKiBVVlNjYWxlLnc7XFxuICAgIGZsb2F0IGZBbWIgPSBkb3QoYV9ub3JtYWwsIHZlYzMoMC4wLCAtMS4wLCAwLjApKSAqIDAuNSArIDAuNTtcXG4gICAgdmVjMyBhbWJEaWZmID0gbWl4KGNjX2FtYmllbnRTa3kucmdiLCBjY19hbWJpZW50R3JvdW5kLnJnYiwgZkFtYikgKiBjY19hbWJpZW50U2t5Lnc7XFxuI2lmIExJR0hUX01BUCA9PSAwXFxuICAgIHZlYzMgTCA9IG5vcm1hbGl6ZSgtY2NfbWFpbkxpdERpci54eXopO1xcbiAgICB2ZWMzIE4gPSBhX25vcm1hbDtcXG4gICAgZGlmZnVzZSA9IGFtYkRpZmYgKyB2ZWMzKGRvdChOLCBMKSkgKiBjY19tYWluTGl0Q29sb3IucmdiO1xcbiNlbHNlXFxuICAgIGRpZmZ1c2UgPSBhbWJEaWZmO1xcbiAgICBsdXYgPSBsaWdodE1hcFVWUGFyYW0ueHkgKyBhX3RleENvb3JkICogbGlnaHRNYXBVVlBhcmFtLnp3O1xcbiNlbmRpZlxcbiAgICBmYWN0b3JfZm9nID0gQ0NfVFJBTlNGRVJfRk9HKHZlYzQod29ybGRQb3MsIDEpKTtcXG4gICAgcmV0dXJuIHBvcztcXG4gIH1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG4gIGluIHZlYzIgdXZ3O1xcbiAgaW4gdmVjMiB1djA7XFxuICBpbiB2ZWMyIHV2MTtcXG4gIGluIHZlYzIgdXYyO1xcbiAgaW4gdmVjMiB1djM7XFxuICBpbiB2ZWMzIGRpZmZ1c2U7XFxuICBpbiB2ZWMyIGx1djtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHdlaWdodE1hcDtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGRldGFpbE1hcDA7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBkZXRhaWxNYXAxO1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZGV0YWlsTWFwMjtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGRldGFpbE1hcDM7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXG4gIGluIGZsb2F0IGZhY3Rvcl9mb2c7XFxudmVjNCBmcmFnICgpIHtcXG4gIHZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbiAgI2lmIExBWUVSUyA9PSAxXFxuICAgIGNvbG9yID0gdGV4dHVyZShkZXRhaWxNYXAwLCB1djApO1xcbiAgI2VsaWYgTEFZRVJTID09IDJcXG4gICAgdmVjNCB3ID0gdGV4dHVyZSh3ZWlnaHRNYXAsIHV2dyk7XFxuICAgIGNvbG9yICs9IHRleHR1cmUoZGV0YWlsTWFwMCwgdXYwKSAqIHcucjtcXG4gICAgY29sb3IgKz0gdGV4dHVyZShkZXRhaWxNYXAxLCB1djEpICogdy5nO1xcbiAgI2VsaWYgTEFZRVJTID09IDNcXG4gICAgdmVjNCB3ID0gdGV4dHVyZSh3ZWlnaHRNYXAsIHV2dyk7XFxuICAgIGNvbG9yICs9IHRleHR1cmUoZGV0YWlsTWFwMCwgdXYwKSAqIHcucjtcXG4gICAgY29sb3IgKz0gdGV4dHVyZShkZXRhaWxNYXAxLCB1djEpICogdy5nO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlKGRldGFpbE1hcDIsIHV2MikgKiB3LmI7XFxuICAjZWxpZiBMQVlFUlMgPT0gNFxcbiAgICB2ZWM0IHcgPSB0ZXh0dXJlKHdlaWdodE1hcCwgdXZ3KTtcXG4gICAgY29sb3IgKz0gdGV4dHVyZShkZXRhaWxNYXAwLCB1djApICogdy5yO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlKGRldGFpbE1hcDEsIHV2MSkgKiB3Lmc7XFxuICAgIGNvbG9yICs9IHRleHR1cmUoZGV0YWlsTWFwMiwgdXYyKSAqIHcuYjtcXG4gICAgY29sb3IgKz0gdGV4dHVyZShkZXRhaWxNYXAzLCB1djMpICogdy5hO1xcbiAgI2Vsc2VcXG4gICAgY29sb3IgPSB0ZXh0dXJlKGRldGFpbE1hcDAsIHV2MCk7XFxuICAjZW5kaWZcXG4gIHZlYzMgbGlnaHRpbmcgPSBkaWZmdXNlO1xcbiAgI2lmIExJR0hUX01BUCA9PSAxXFxuICAgIGxpZ2h0aW5nICs9IHRleHR1cmUobGlnaHRNYXAsIGx1dikucmdiO1xcbiAgI2VuZGlmXFxuICBjb2xvci5yZ2IgKj0gbGlnaHRpbmc7XFxuICBjb2xvciA9IHZlYzQobWl4KENDX0ZPUldBUkRfQUREID4gMCA/IHZlYzMoMC4wKSA6IGNjX2ZvZ0NvbG9yLnJnYiwgY29sb3IucmdiLCBmYWN0b3JfZm9nKSwgY29sb3IuYSk7XFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNvbG9yKTtcXG59XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsMVwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbnVuaWZvcm0gaGlnaHAgdmVjNCBjY19jYW1lcmFQb3M7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG5mbG9hdCBMaW5lYXJGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKTtcXG4gICAgZmxvYXQgZm9nU3RhcnQgPSBjY19mb2dCYXNlLng7XFxuICAgIGZsb2F0IGZvZ0VuZCA9IGNjX2ZvZ0Jhc2UueTtcXG4gICAgcmV0dXJuIGNsYW1wKChmb2dFbmQgLSBjYW1fZGlzKSAvIChmb2dFbmQgLSBmb2dTdGFydCksIDAuLCAxLik7XFxufVxcbmZsb2F0IEV4cEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IGZvZ0RlbnNpdHkgPSBjY19mb2dCYXNlLno7XFxuICAgIGZsb2F0IGNhbV9kaXMgPSBkaXN0YW5jZShjY19jYW1lcmFQb3MsIHdQb3MpIC8gZm9nQXR0ZW4gKiA0LjtcXG4gICAgZmxvYXQgZiA9IGV4cCgtY2FtX2RpcyAqIGZvZ0RlbnNpdHkpO1xcbiAgICByZXR1cm4gZjtcXG59XFxuZmxvYXQgRXhwU3F1YXJlZEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IGZvZ0RlbnNpdHkgPSBjY19mb2dCYXNlLno7XFxuICAgIGZsb2F0IGNhbV9kaXMgPSBkaXN0YW5jZShjY19jYW1lcmFQb3MsIHdQb3MpIC8gZm9nQXR0ZW4gKiA0LjtcXG4gICAgZmxvYXQgZiA9IGV4cCgtY2FtX2RpcyAqIGNhbV9kaXMgKiBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSk7XFxuICAgIHJldHVybiBmO1xcbn1cXG5mbG9hdCBMYXllcmVkRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgZm9nQXR0ZW4gPSBjY19mb2dBZGQuejtcXG4gICAgZmxvYXQgX0ZvZ1RvcCA9IGNjX2ZvZ0FkZC54O1xcbiAgICBmbG9hdCBfRm9nUmFuZ2UgPSBjY19mb2dBZGQueTtcXG4gICAgdmVjMyBjYW1Xb3JsZFByb2ogPSBjY19jYW1lcmFQb3MueHl6O1xcbiAgICBjYW1Xb3JsZFByb2oueSA9IDAuO1xcbiAgICB2ZWMzIHdvcmxkUG9zUHJvaiA9IHdQb3MueHl6O1xcbiAgICB3b3JsZFBvc1Byb2oueSA9IDAuO1xcbiAgICBmbG9hdCBmRGVsdGFEID0gZGlzdGFuY2Uod29ybGRQb3NQcm9qLCBjYW1Xb3JsZFByb2opIC8gZm9nQXR0ZW4gKiAyLjA7XFxuICAgIGZsb2F0IGZEZWx0YVksIGZEZW5zaXR5SW50ZWdyYWw7XFxuICAgIGlmIChjY19jYW1lcmFQb3MueSA+IF9Gb2dUb3ApIHtcXG4gICAgICAgIGlmICh3UG9zLnkgPCBfRm9nVG9wKSB7XFxuICAgICAgICAgICAgZkRlbHRhWSA9IChfRm9nVG9wIC0gd1Bvcy55KSAvIF9Gb2dSYW5nZSAqIDIuMDtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gZkRlbHRhWSAqIGZEZWx0YVkgKiAwLjU7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSAwLjtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gMC47XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAod1Bvcy55IDwgX0ZvZ1RvcCkge1xcbiAgICAgICAgICAgIGZsb2F0IGZEZWx0YUEgPSAoX0ZvZ1RvcCAtIGNjX2NhbWVyYVBvcy55KSAvIF9Gb2dSYW5nZSAqIDIuO1xcbiAgICAgICAgICAgIGZsb2F0IGZEZWx0YUIgPSAoX0ZvZ1RvcCAtIHdQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjtcXG4gICAgICAgICAgICBmRGVsdGFZID0gYWJzKGZEZWx0YUEgLSBmRGVsdGFCKTtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gYWJzKChmRGVsdGFBICogZkRlbHRhQSAqIDAuNSkgLSAoZkRlbHRhQiAqIGZEZWx0YUIgKiAwLjUpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZkRlbHRhWSA9IGFicyhfRm9nVG9wIC0gY2NfY2FtZXJhUG9zLnkpIC8gX0ZvZ1JhbmdlICogMi47XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGFicyhmRGVsdGFZICogZkRlbHRhWSAqIDAuNSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZmxvYXQgZkRlbnNpdHk7XFxuICAgIGlmIChmRGVsdGFZICE9IDAuKSB7XFxuICAgICAgICBmRGVuc2l0eSA9IChzcXJ0KDEuMCArICgoZkRlbHRhRCAvIGZEZWx0YVkpICogKGZEZWx0YUQgLyBmRGVsdGFZKSkpKSAqIGZEZW5zaXR5SW50ZWdyYWw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBmRGVuc2l0eSA9IDAuO1xcbiAgICB9XFxuICAgIGZsb2F0IGYgPSBleHAoLWZEZW5zaXR5KTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbmZsb2F0IENDX1RSQU5TRkVSX0ZPRyh2ZWM0IHBvcykge1xcbiAgICAjaWYgQ0NfVVNFX0ZPRyA9PSAxXFxuICAgICAgICByZXR1cm4gTGluZWFyRm9nKHBvcyk7XFxuXHQjZWxpZiBDQ19VU0VfRk9HID09IDJcXG4gICAgICAgIHJldHVybiBFeHBGb2cocG9zKTtcXG4gICAgI2VsaWYgQ0NfVVNFX0ZPRyA9PSAzXFxuICAgICAgICByZXR1cm4gRXhwU3F1YXJlZEZvZyhwb3MpO1xcbiAgICAjZWxpZiBDQ19VU0VfRk9HID09IDRcXG4gICAgICAgIHJldHVybiBMYXllcmVkRm9nKHBvcyk7XFxuICAgICNlbmRpZlxcbiAgICByZXR1cm4gMS47XFxufVxcbiAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG4gIGF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcbiAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG4gIHZhcnlpbmcgdmVjMiB1dnc7XFxuICB2YXJ5aW5nIHZlYzIgdXYwO1xcbiAgdmFyeWluZyB2ZWMyIHV2MTtcXG4gIHZhcnlpbmcgdmVjMiB1djI7XFxuICB2YXJ5aW5nIHZlYzIgdXYzO1xcbiAgdmFyeWluZyB2ZWMyIGx1djtcXG4gIHZhcnlpbmcgdmVjMyBkaWZmdXNlO1xcbiAgdmFyeWluZyBmbG9hdCBmYWN0b3JfZm9nO1xcbiAgdW5pZm9ybSB2ZWM0IFVWU2NhbGU7XFxudW5pZm9ybSB2ZWM0IGxpZ2h0TWFwVVZQYXJhbTtcXG4gIHZlYzQgdmVydCAoKSB7XFxuICAgIHZlYzMgd29ybGRQb3M7XFxuICAgIHdvcmxkUG9zLnggPSBjY19tYXRXb3JsZFszXVswXSArIGFfcG9zaXRpb24ueDtcXG4gICAgd29ybGRQb3MueSA9IGNjX21hdFdvcmxkWzNdWzFdICsgYV9wb3NpdGlvbi55O1xcbiAgICB3b3JsZFBvcy56ID0gY2NfbWF0V29ybGRbM11bMl0gKyBhX3Bvc2l0aW9uLno7XFxuICAgIHZlYzQgcG9zID0gdmVjNCh3b3JsZFBvcywgMSk7XFxuICAgIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgICB1dncgPSBhX3RleENvb3JkO1xcbiAgICB1djAgPSBhX3Bvc2l0aW9uLnh6ICogVVZTY2FsZS54O1xcbiAgICB1djEgPSBhX3Bvc2l0aW9uLnh6ICogVVZTY2FsZS55O1xcbiAgICB1djIgPSBhX3Bvc2l0aW9uLnh6ICogVVZTY2FsZS56O1xcbiAgICB1djMgPSBhX3Bvc2l0aW9uLnh6ICogVVZTY2FsZS53O1xcbiAgICBmbG9hdCBmQW1iID0gZG90KGFfbm9ybWFsLCB2ZWMzKDAuMCwgLTEuMCwgMC4wKSkgKiAwLjUgKyAwLjU7XFxuICAgIHZlYzMgYW1iRGlmZiA9IG1peChjY19hbWJpZW50U2t5LnJnYiwgY2NfYW1iaWVudEdyb3VuZC5yZ2IsIGZBbWIpICogY2NfYW1iaWVudFNreS53O1xcbiNpZiBMSUdIVF9NQVAgPT0gMFxcbiAgICB2ZWMzIEwgPSBub3JtYWxpemUoLWNjX21haW5MaXREaXIueHl6KTtcXG4gICAgdmVjMyBOID0gYV9ub3JtYWw7XFxuICAgIGRpZmZ1c2UgPSBhbWJEaWZmICsgdmVjMyhkb3QoTiwgTCkpICogY2NfbWFpbkxpdENvbG9yLnJnYjtcXG4jZWxzZVxcbiAgICBkaWZmdXNlID0gYW1iRGlmZjtcXG4gICAgbHV2ID0gbGlnaHRNYXBVVlBhcmFtLnh5ICsgYV90ZXhDb29yZCAqIGxpZ2h0TWFwVVZQYXJhbS56dztcXG4jZW5kaWZcXG4gICAgZmFjdG9yX2ZvZyA9IENDX1RSQU5TRkVSX0ZPRyh2ZWM0KHdvcmxkUG9zLCAxKSk7XFxuICAgIHJldHVybiBwb3M7XFxuICB9XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxuICB2YXJ5aW5nIHZlYzIgdXZ3O1xcbiAgdmFyeWluZyB2ZWMyIHV2MDtcXG4gIHZhcnlpbmcgdmVjMiB1djE7XFxuICB2YXJ5aW5nIHZlYzIgdXYyO1xcbiAgdmFyeWluZyB2ZWMyIHV2MztcXG4gIHZhcnlpbmcgdmVjMyBkaWZmdXNlO1xcbiAgdmFyeWluZyB2ZWMyIGx1djtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHdlaWdodE1hcDtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGRldGFpbE1hcDA7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBkZXRhaWxNYXAxO1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZGV0YWlsTWFwMjtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGRldGFpbE1hcDM7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXG4gIHZhcnlpbmcgZmxvYXQgZmFjdG9yX2ZvZztcXG52ZWM0IGZyYWcgKCkge1xcbiAgdmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuICAjaWYgTEFZRVJTID09IDFcXG4gICAgY29sb3IgPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMCwgdXYwKTtcXG4gICNlbGlmIExBWUVSUyA9PSAyXFxuICAgIHZlYzQgdyA9IHRleHR1cmUyRCh3ZWlnaHRNYXAsIHV2dyk7XFxuICAgIGNvbG9yICs9IHRleHR1cmUyRChkZXRhaWxNYXAwLCB1djApICogdy5yO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMSwgdXYxKSAqIHcuZztcXG4gICNlbGlmIExBWUVSUyA9PSAzXFxuICAgIHZlYzQgdyA9IHRleHR1cmUyRCh3ZWlnaHRNYXAsIHV2dyk7XFxuICAgIGNvbG9yICs9IHRleHR1cmUyRChkZXRhaWxNYXAwLCB1djApICogdy5yO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMSwgdXYxKSAqIHcuZztcXG4gICAgY29sb3IgKz0gdGV4dHVyZTJEKGRldGFpbE1hcDIsIHV2MikgKiB3LmI7XFxuICAjZWxpZiBMQVlFUlMgPT0gNFxcbiAgICB2ZWM0IHcgPSB0ZXh0dXJlMkQod2VpZ2h0TWFwLCB1dncpO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMCwgdXYwKSAqIHcucjtcXG4gICAgY29sb3IgKz0gdGV4dHVyZTJEKGRldGFpbE1hcDEsIHV2MSkgKiB3Lmc7XFxuICAgIGNvbG9yICs9IHRleHR1cmUyRChkZXRhaWxNYXAyLCB1djIpICogdy5iO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMywgdXYzKSAqIHcuYTtcXG4gICNlbHNlXFxuICAgIGNvbG9yID0gdGV4dHVyZTJEKGRldGFpbE1hcDAsIHV2MCk7XFxuICAjZW5kaWZcXG4gIHZlYzMgbGlnaHRpbmcgPSBkaWZmdXNlO1xcbiAgI2lmIExJR0hUX01BUCA9PSAxXFxuICAgIGxpZ2h0aW5nICs9IHRleHR1cmUyRChsaWdodE1hcCwgbHV2KS5yZ2I7XFxuICAjZW5kaWZcXG4gIGNvbG9yLnJnYiAqPSBsaWdodGluZztcXG4gIGNvbG9yID0gdmVjNChtaXgoQ0NfRk9SV0FSRF9BREQgPiAwID8gdmVjMygwLjApIDogY2NfZm9nQ29sb3IucmdiLCBjb2xvci5yZ2IsIGZhY3Rvcl9mb2cpLCBjb2xvci5hKTtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY29sb3IpO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xzbDRcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxubGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxuZmxvYXQgTGluZWFyRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgY2FtX2RpcyA9IGRpc3RhbmNlKGNjX2NhbWVyYVBvcywgd1Bvcyk7XFxuICAgIGZsb2F0IGZvZ1N0YXJ0ID0gY2NfZm9nQmFzZS54O1xcbiAgICBmbG9hdCBmb2dFbmQgPSBjY19mb2dCYXNlLnk7XFxuICAgIHJldHVybiBjbGFtcCgoZm9nRW5kIC0gY2FtX2RpcykgLyAoZm9nRW5kIC0gZm9nU3RhcnQpLCAwLiwgMS4pO1xcbn1cXG5mbG9hdCBFeHBGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBmb2dBdHRlbiA9IGNjX2ZvZ0FkZC56O1xcbiAgICBmbG9hdCBmb2dEZW5zaXR5ID0gY2NfZm9nQmFzZS56O1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKSAvIGZvZ0F0dGVuICogNC47XFxuICAgIGZsb2F0IGYgPSBleHAoLWNhbV9kaXMgKiBmb2dEZW5zaXR5KTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbmZsb2F0IEV4cFNxdWFyZWRGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBmb2dBdHRlbiA9IGNjX2ZvZ0FkZC56O1xcbiAgICBmbG9hdCBmb2dEZW5zaXR5ID0gY2NfZm9nQmFzZS56O1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKSAvIGZvZ0F0dGVuICogNC47XFxuICAgIGZsb2F0IGYgPSBleHAoLWNhbV9kaXMgKiBjYW1fZGlzICogZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkpO1xcbiAgICByZXR1cm4gZjtcXG59XFxuZmxvYXQgTGF5ZXJlZEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IF9Gb2dUb3AgPSBjY19mb2dBZGQueDtcXG4gICAgZmxvYXQgX0ZvZ1JhbmdlID0gY2NfZm9nQWRkLnk7XFxuICAgIHZlYzMgY2FtV29ybGRQcm9qID0gY2NfY2FtZXJhUG9zLnh5ejtcXG4gICAgY2FtV29ybGRQcm9qLnkgPSAwLjtcXG4gICAgdmVjMyB3b3JsZFBvc1Byb2ogPSB3UG9zLnh5ejtcXG4gICAgd29ybGRQb3NQcm9qLnkgPSAwLjtcXG4gICAgZmxvYXQgZkRlbHRhRCA9IGRpc3RhbmNlKHdvcmxkUG9zUHJvaiwgY2FtV29ybGRQcm9qKSAvIGZvZ0F0dGVuICogMi4wO1xcbiAgICBmbG9hdCBmRGVsdGFZLCBmRGVuc2l0eUludGVncmFsO1xcbiAgICBpZiAoY2NfY2FtZXJhUG9zLnkgPiBfRm9nVG9wKSB7XFxuICAgICAgICBpZiAod1Bvcy55IDwgX0ZvZ1RvcCkge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSAoX0ZvZ1RvcCAtIHdQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjA7XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGZEZWx0YVkgKiBmRGVsdGFZICogMC41O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmRGVsdGFZID0gMC47XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IDAuO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHdQb3MueSA8IF9Gb2dUb3ApIHtcXG4gICAgICAgICAgICBmbG9hdCBmRGVsdGFBID0gKF9Gb2dUb3AgLSBjY19jYW1lcmFQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjtcXG4gICAgICAgICAgICBmbG9hdCBmRGVsdGFCID0gKF9Gb2dUb3AgLSB3UG9zLnkpIC8gX0ZvZ1JhbmdlICogMi47XFxuICAgICAgICAgICAgZkRlbHRhWSA9IGFicyhmRGVsdGFBIC0gZkRlbHRhQik7XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGFicygoZkRlbHRhQSAqIGZEZWx0YUEgKiAwLjUpIC0gKGZEZWx0YUIgKiBmRGVsdGFCICogMC41KSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSBhYnMoX0ZvZ1RvcCAtIGNjX2NhbWVyYVBvcy55KSAvIF9Gb2dSYW5nZSAqIDIuO1xcbiAgICAgICAgICAgIGZEZW5zaXR5SW50ZWdyYWwgPSBhYnMoZkRlbHRhWSAqIGZEZWx0YVkgKiAwLjUpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGZEZW5zaXR5O1xcbiAgICBpZiAoZkRlbHRhWSAhPSAwLikge1xcbiAgICAgICAgZkRlbnNpdHkgPSAoc3FydCgxLjAgKyAoKGZEZWx0YUQgLyBmRGVsdGFZKSAqIChmRGVsdGFEIC8gZkRlbHRhWSkpKSkgKiBmRGVuc2l0eUludGVncmFsO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZkRlbnNpdHkgPSAwLjtcXG4gICAgfVxcbiAgICBmbG9hdCBmID0gZXhwKC1mRGVuc2l0eSk7XFxuICAgIHJldHVybiBmO1xcbn1cXG5mbG9hdCBDQ19UUkFOU0ZFUl9GT0codmVjNCBwb3MpIHtcXG4gICAgI2lmIENDX1VTRV9GT0cgPT0gMVxcbiAgICAgICAgcmV0dXJuIExpbmVhckZvZyhwb3MpO1xcblx0I2VsaWYgQ0NfVVNFX0ZPRyA9PSAyXFxuICAgICAgICByZXR1cm4gRXhwRm9nKHBvcyk7XFxuICAgICNlbGlmIENDX1VTRV9GT0cgPT0gM1xcbiAgICAgICAgcmV0dXJuIEV4cFNxdWFyZWRGb2cocG9zKTtcXG4gICAgI2VsaWYgQ0NfVVNFX0ZPRyA9PSA0XFxuICAgICAgICByZXR1cm4gTGF5ZXJlZEZvZyhwb3MpO1xcbiAgICAjZW5kaWZcXG4gICAgcmV0dXJuIDEuO1xcbn1cXG4gIGxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzMgYV9wb3NpdGlvbjtcXG4gIGxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzMgYV9ub3JtYWw7XFxuICBsYXlvdXQobG9jYXRpb24gPSAyKSBpbiB2ZWMyIGFfdGV4Q29vcmQ7XFxuICBsYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjMiB1dnc7XFxuICBsYXlvdXQobG9jYXRpb24gPSAxKSBvdXQgdmVjMiB1djA7XFxuICBsYXlvdXQobG9jYXRpb24gPSAyKSBvdXQgdmVjMiB1djE7XFxuICBsYXlvdXQobG9jYXRpb24gPSAzKSBvdXQgdmVjMiB1djI7XFxuICBsYXlvdXQobG9jYXRpb24gPSA0KSBvdXQgdmVjMiB1djM7XFxuICBsYXlvdXQobG9jYXRpb24gPSA1KSBvdXQgdmVjMiBsdXY7XFxuICBsYXlvdXQobG9jYXRpb24gPSA2KSBvdXQgdmVjMyBkaWZmdXNlO1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gNykgb3V0IGZsb2F0IGZhY3Rvcl9mb2c7XFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDApIHVuaWZvcm0gVGV4Q29vcmRzIHtcXG4gICAgdmVjNCBVVlNjYWxlO1xcbiAgICB2ZWM0IGxpZ2h0TWFwVVZQYXJhbTtcXG4gIH07XFxuICB2ZWM0IHZlcnQgKCkge1xcbiAgICB2ZWMzIHdvcmxkUG9zO1xcbiAgICB3b3JsZFBvcy54ID0gY2NfbWF0V29ybGRbM11bMF0gKyBhX3Bvc2l0aW9uLng7XFxuICAgIHdvcmxkUG9zLnkgPSBjY19tYXRXb3JsZFszXVsxXSArIGFfcG9zaXRpb24ueTtcXG4gICAgd29ybGRQb3MueiA9IGNjX21hdFdvcmxkWzNdWzJdICsgYV9wb3NpdGlvbi56O1xcbiAgICB2ZWM0IHBvcyA9IHZlYzQod29ybGRQb3MsIDEpO1xcbiAgICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gICAgdXZ3ID0gYV90ZXhDb29yZDtcXG4gICAgdXYwID0gYV9wb3NpdGlvbi54eiAqIFVWU2NhbGUueDtcXG4gICAgdXYxID0gYV9wb3NpdGlvbi54eiAqIFVWU2NhbGUueTtcXG4gICAgdXYyID0gYV9wb3NpdGlvbi54eiAqIFVWU2NhbGUuejtcXG4gICAgdXYzID0gYV9wb3NpdGlvbi54eiAqIFVWU2NhbGUudztcXG4gICAgZmxvYXQgZkFtYiA9IGRvdChhX25vcm1hbCwgdmVjMygwLjAsIC0xLjAsIDAuMCkpICogMC41ICsgMC41O1xcbiAgICB2ZWMzIGFtYkRpZmYgPSBtaXgoY2NfYW1iaWVudFNreS5yZ2IsIGNjX2FtYmllbnRHcm91bmQucmdiLCBmQW1iKSAqIGNjX2FtYmllbnRTa3kudztcXG4jaWYgTElHSFRfTUFQID09IDBcXG4gICAgdmVjMyBMID0gbm9ybWFsaXplKC1jY19tYWluTGl0RGlyLnh5eik7XFxuICAgIHZlYzMgTiA9IGFfbm9ybWFsO1xcbiAgICBkaWZmdXNlID0gYW1iRGlmZiArIHZlYzMoZG90KE4sIEwpKSAqIGNjX21haW5MaXRDb2xvci5yZ2I7XFxuI2Vsc2VcXG4gICAgZGlmZnVzZSA9IGFtYkRpZmY7XFxuICAgIGx1diA9IGxpZ2h0TWFwVVZQYXJhbS54eSArIGFfdGV4Q29vcmQgKiBsaWdodE1hcFVWUGFyYW0uenc7XFxuI2VuZGlmXFxuICAgIGZhY3Rvcl9mb2cgPSBDQ19UUkFOU0ZFUl9GT0codmVjNCh3b3JsZFBvcywgMSkpO1xcbiAgICByZXR1cm4gcG9zO1xcbiAgfVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxuICBsYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWMyIHV2dztcXG4gIGxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzIgdXYwO1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjMiB1djE7XFxuICBsYXlvdXQobG9jYXRpb24gPSAzKSBpbiB2ZWMyIHV2MjtcXG4gIGxheW91dChsb2NhdGlvbiA9IDQpIGluIHZlYzIgdXYzO1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gNikgaW4gdmVjMyBkaWZmdXNlO1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gNSkgaW4gdmVjMiBsdXY7XFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDEpIHVuaWZvcm0gc2FtcGxlcjJEIHdlaWdodE1hcDtcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMikgdW5pZm9ybSBzYW1wbGVyMkQgZGV0YWlsTWFwMDtcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMykgdW5pZm9ybSBzYW1wbGVyMkQgZGV0YWlsTWFwMTtcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gNCkgdW5pZm9ybSBzYW1wbGVyMkQgZGV0YWlsTWFwMjtcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gNSkgdW5pZm9ybSBzYW1wbGVyMkQgZGV0YWlsTWFwMztcXG4gIGxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gNikgdW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuICBsYXlvdXQobG9jYXRpb24gPSA3KSBpbiBmbG9hdCBmYWN0b3JfZm9nO1xcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4gICNpZiBMQVlFUlMgPT0gMVxcbiAgICBjb2xvciA9IHRleHR1cmUoZGV0YWlsTWFwMCwgdXYwKTtcXG4gICNlbGlmIExBWUVSUyA9PSAyXFxuICAgIHZlYzQgdyA9IHRleHR1cmUod2VpZ2h0TWFwLCB1dncpO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlKGRldGFpbE1hcDAsIHV2MCkgKiB3LnI7XFxuICAgIGNvbG9yICs9IHRleHR1cmUoZGV0YWlsTWFwMSwgdXYxKSAqIHcuZztcXG4gICNlbGlmIExBWUVSUyA9PSAzXFxuICAgIHZlYzQgdyA9IHRleHR1cmUod2VpZ2h0TWFwLCB1dncpO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlKGRldGFpbE1hcDAsIHV2MCkgKiB3LnI7XFxuICAgIGNvbG9yICs9IHRleHR1cmUoZGV0YWlsTWFwMSwgdXYxKSAqIHcuZztcXG4gICAgY29sb3IgKz0gdGV4dHVyZShkZXRhaWxNYXAyLCB1djIpICogdy5iO1xcbiAgI2VsaWYgTEFZRVJTID09IDRcXG4gICAgdmVjNCB3ID0gdGV4dHVyZSh3ZWlnaHRNYXAsIHV2dyk7XFxuICAgIGNvbG9yICs9IHRleHR1cmUoZGV0YWlsTWFwMCwgdXYwKSAqIHcucjtcXG4gICAgY29sb3IgKz0gdGV4dHVyZShkZXRhaWxNYXAxLCB1djEpICogdy5nO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlKGRldGFpbE1hcDIsIHV2MikgKiB3LmI7XFxuICAgIGNvbG9yICs9IHRleHR1cmUoZGV0YWlsTWFwMywgdXYzKSAqIHcuYTtcXG4gICNlbHNlXFxuICAgIGNvbG9yID0gdGV4dHVyZShkZXRhaWxNYXAwLCB1djApO1xcbiAgI2VuZGlmXFxuICB2ZWMzIGxpZ2h0aW5nID0gZGlmZnVzZTtcXG4gICNpZiBMSUdIVF9NQVAgPT0gMVxcbiAgICBsaWdodGluZyArPSB0ZXh0dXJlKGxpZ2h0TWFwLCBsdXYpLnJnYjtcXG4gICNlbmRpZlxcbiAgY29sb3IucmdiICo9IGxpZ2h0aW5nO1xcbiAgY29sb3IgPSB2ZWM0KG1peChDQ19GT1JXQVJEX0FERCA+IDAgPyB2ZWMzKDAuMCkgOiBjY19mb2dDb2xvci5yZ2IsIGNvbG9yLnJnYiwgZmFjdG9yX2ZvZyksIGNvbG9yLmEpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2xvcik7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnVpbHRpbnNcIjoge1xyXG4gICAgICAgICAgXCJnbG9iYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NHbG9iYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH0sXHJcbiAgICAgICAgICBcImxvY2Fsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDTG9jYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9GT0dcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzAsIDRdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX0ZPUldBUkRfQUREXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJMSUdIVF9NQVBcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzAsIDNdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkxBWUVSU1wiLCBcInR5cGVcIjogXCJudW1iZXJcIiwgXCJyYW5nZVwiOiBbMCwgNF0gfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJibG9ja3NcIjogW1xyXG4gICAgICAgICAge1wibmFtZVwiOiBcIlRleENvb3Jkc1wiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAwLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJVVlNjYWxlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH0sXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwibGlnaHRNYXBVVlBhcmFtXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcInNhbXBsZXJzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwid2VpZ2h0TWFwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJiaW5kaW5nXCI6IDEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZGV0YWlsTWFwMFwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMTYsIFwiYmluZGluZ1wiOiAyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImRldGFpbE1hcDFcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDE2LCBcImJpbmRpbmdcIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJkZXRhaWxNYXAyXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJiaW5kaW5nXCI6IDQgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZGV0YWlsTWFwM1wiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMTYsIFwiYmluZGluZ1wiOiA1IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImxpZ2h0TWFwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJiaW5kaW5nXCI6IDYgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX25vcm1hbFwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkXCIsIFwidHlwZVwiOiAxNCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAyMSwgXCJsb2NhdGlvblwiOiAyIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tdW5saXRcIixcclxuICAgIFwiX3V1aWRcIjogXCJhM2NkMDA5Zi0wYWIwLTQyMGQtOTI3OC1iOWZkYWI5MzliYmNcIixcclxuICAgIFwidGVjaG5pcXVlc1wiOiBbXHJcbiAgICAgIHsgXCJuYW1lXCI6IFwib3BhcXVlXCIsIFwicGFzc2VzXCI6IFt7IFwicHJvZ3JhbVwiOiBcImJ1aWx0aW4tdW5saXR8dW5saXQtdnM6dmVydHx1bmxpdC1mczpmcmFnXCIsIFwicHJvcGVydGllc1wiOiB7IFwibWFpblRleHR1cmVcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjggfSwgXCJ0aWxpbmdPZmZzZXRcIjogeyBcInZhbHVlXCI6IFsxLCAxLCAwLCAwXSwgXCJ0eXBlXCI6IDE2IH0sIFwibWFpbkNvbG9yXCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMSwgMV0sIFwidHlwZVwiOiAxNiB9LCBcImNvbG9yU2NhbGVcIjogeyBcInZhbHVlXCI6IFsxLCAxLCAxXSwgXCJ0eXBlXCI6IDE1LCBcImhhbmRsZUluZm9cIjogW1wiY29sb3JTY2FsZUFuZEN1dG9mZlwiLCAwLCAxNV0gfSwgXCJhbHBoYVRocmVzaG9sZFwiOiB7IFwidmFsdWVcIjogWzAuNV0sIFwidHlwZVwiOiAxMywgXCJoYW5kbGVJbmZvXCI6IFtcImNvbG9yU2NhbGVBbmRDdXRvZmZcIiwgMywgMTNdIH0sIFwiY29sb3JcIjogeyBcInR5cGVcIjogMTYsIFwiaGFuZGxlSW5mb1wiOiBbXCJtYWluQ29sb3JcIiwgMCwgMTZdIH0sIFwiY29sb3JTY2FsZUFuZEN1dG9mZlwiOiB7IFwidHlwZVwiOiAxNiwgXCJ2YWx1ZVwiOiBbMSwgMSwgMSwgMC41XSB9IH0gfV0gfVxyXG4gICAgXSxcclxuICAgIFwic2hhZGVyc1wiOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBcIm5hbWVcIjogXCJidWlsdGluLXVubGl0fHVubGl0LXZzOnZlcnR8dW5saXQtZnM6ZnJhZ1wiLFxyXG4gICAgICAgIFwiaGFzaFwiOiAyNzEzODYwOTg2LFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgcmdiYSA9IHJnYmEgKiAyNTUuMDtcXG4gIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyNy45OSwgcmdiYVszXSkgKiAyLjA7XFxuICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjcuOTkpICsgc3RlcCgxMjguMCwgcmdiYVsyXSkgLSAxMjcuMDtcXG4gIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG59XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmluIHZlYzMgYV9wb3NpdGlvbjtcXG5pbiB2ZWMzIGFfbm9ybWFsO1xcbmluIHZlYzIgYV90ZXhDb29yZDtcXG5pbiB2ZWM0IGFfdGFuZ2VudDtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGludCBnZXRWZXJ0ZXhJZCgpIHtcXG4gICAgICAgIHJldHVybiBnbF9WZXJ0ZXhJRDtcXG4gICAgfVxcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NNb3JwaCB7XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1sxNV07XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm87XFxufTtcXG52ZWMyIGdldFBpeGVsTG9jYXRpb24odmVjMiB0ZXh0dXJlUmVzb2x1dGlvbiwgaW50IHBpeGVsSW5kZXgpIHtcXG4gICAgZmxvYXQgcGl4ZWxJbmRleEYgPSBmbG9hdChwaXhlbEluZGV4KTtcXG4gICAgZmxvYXQgeCA9IG1vZChwaXhlbEluZGV4RiwgdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgIGZsb2F0IHkgPSBmbG9vcihwaXhlbEluZGV4RiAvIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICByZXR1cm4gdmVjMih4LCB5KTtcXG59XFxudmVjMiBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKHZlYzIgbG9jYXRpb24sIHZlYzIgdGV4dHVyZVJlc29sdXRpb24pIHtcXG4gICAgcmV0dXJuICh2ZWMyKGxvY2F0aW9uLngsIGxvY2F0aW9uLnkpICsgLjUpIC8gdGV4dHVyZVJlc29sdXRpb247XFxufVxcbiNpZiBDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICAgICAgICAgIGl2ZWMyIHRleFNpemUgPSB0ZXh0dXJlU2l6ZSh0ZXgsIDApO1xcbiAgICAgICAgICAgIHJldHVybiB0ZXhlbEZldGNoKHRleCwgaXZlYzIocGl4ZWxJbmRleCAlIHRleFNpemUueCwgcGl4ZWxJbmRleCAvIHRleFNpemUueCksIDApO1xcbiAgICAgICAgfVxcbiNlbHNlXFxuICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgZWxlbWVudEluZGV4KSB7XFxuICAgICAgICBpbnQgcGl4ZWxJbmRleCA9IGVsZW1lbnRJbmRleCAqIDQ7XFxuICAgICAgICB2ZWMyIGxvY2F0aW9uID0gZ2V0UGl4ZWxMb2NhdGlvbihjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSwgcGl4ZWxJbmRleCk7XFxuICAgICAgICB2ZWMyIHggPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigwLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHZlYzIgeSA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDEuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB6ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMi4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICByZXR1cm4gdmVjNChcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKHRleCwgeCkpLFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUodGV4LCB5KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZSh0ZXgsIHopKSxcXG4gICAgICAgICAgICAxLjBcXG4gICAgICAgICk7XFxuICAgIH1cXG4jZW5kaWZcXG5mbG9hdCBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaW50IGluZGV4KSB7XFxuICAgIGZsb2F0IG0gPSBtb2QoZmxvYXQoaW5kZXgpLCA0LjApO1xcbiAgICBpZiAobSA8IDEuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS54O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAyLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueTtcXG4gICAgfSBlbHNlIGlmIChtIDwgMy4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLno7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnc7XFxuICAgIH1cXG59XFxudmVjMyBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IHZlcnRleEluZGV4KSB7XFxuI2lmIENDX01PUlBIX1BSRUNPTVBVVEVEXFxuICAgIHJldHVybiBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgdmVydGV4SW5kZXgpLnJnYjtcXG4jZWxzZVxcbiAgICB2ZWMzIHJlc3VsdCA9IHZlYzMoMCwgMCwgMCk7XFxuICAgIGZvciAoaW50IGlUYXJnZXQgPSAwOyBpVGFyZ2V0IDwgQ0NfTU9SUEhfVEFSR0VUX0NPVU5UOyArK2lUYXJnZXQpIHtcXG4gICAgICAgIGludCBkYXRhUGl4ZWxTdGFydCA9IGludChmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgaVRhcmdldCkucik7XFxuICAgICAgICByZXN1bHQgKz0gKGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBkYXRhUGl4ZWxTdGFydCArIHZlcnRleEluZGV4KS5yZ2IgKiBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaVRhcmdldCkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuI2VuZGlmXFxufVxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfVGFuZ2VudERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0VGFuZ2VudERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfVGFuZ2VudERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgICBpbnQgdmVydGV4SWQgPSBnZXRWZXJ0ZXhJZCgpO1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIGF0dHIucG9zaXRpb24ueHl6ID0gYXR0ci5wb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGF0dHIubm9ybWFsLnh5eiA9IGF0dHIubm9ybWFsLnh5eiArIGdldE5vcm1hbERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICBhdHRyLnRhbmdlbnQueHl6ID0gYXR0ci50YW5nZW50Lnh5eiArIGdldFRhbmdlbnREaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbn1cXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBwb3NpdGlvbi54eXogPSBwb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChnZXRWZXJ0ZXhJZCgpKTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9TS0lOTklOR1xcbmluIHZlYzQgYV9qb2ludHM7XFxuaW4gdmVjNCBhX3dlaWdodHM7XFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBpbiBoaWdocCB2ZWM0IGFfam9pbnRBbmltSW5mbztcXG4gICNlbmRpZlxcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ1NraW5uaW5nVGV4dHVyZSB7XFxuICAgIGhpZ2hwIHZlYzQgY2Nfam9pbnRUZXh0dXJlSW5mbztcXG4gIH07XFxuICBsYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDU2tpbm5pbmdBbmltYXRpb24ge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50QW5pbUluZm87XFxuICB9O1xcbiAgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgY2Nfam9pbnRUZXh0dXJlO1xcbiAgI2Vsc2VcXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NTa2lubmluZyB7XFxuICAgIGhpZ2hwIHZlYzQgY2Nfam9pbnRzWzMwICogM107XFxuICB9O1xcbiNlbmRpZlxcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjIgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MyA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjIgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA0LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDYuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA3LjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MyA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDguNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA5LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMS41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgIGludCBpZHggPSBpbnQoaSk7XFxuICAgIHZlYzQgdjEgPSBjY19qb2ludHNbaWR4ICogM107XFxuICAgIHZlYzQgdjIgPSBjY19qb2ludHNbaWR4ICogMyArIDFdO1xcbiAgICB2ZWM0IHYzID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAyXTtcXG4gICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gIH1cXG4jZW5kaWZcXG5tYXQ0IHNraW5NYXRyaXggKCkge1xcbiAgcmV0dXJuIGdldEpvaW50TWF0cml4KGFfam9pbnRzLngpICogYV93ZWlnaHRzLnhcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy55KSAqIGFfd2VpZ2h0cy55XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueikgKiBhX3dlaWdodHMuelxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLncpICogYV93ZWlnaHRzLnc7XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBwb3NpdGlvbiA9IG0gKiBwb3NpdGlvbjtcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIGF0dHIucG9zaXRpb24gPSBtICogYXR0ci5wb3NpdGlvbjtcXG4gIGF0dHIubm9ybWFsID0gKG0gKiB2ZWM0KGF0dHIubm9ybWFsLCAwLjApKS54eXo7XFxuICBhdHRyLnRhbmdlbnQueHl6ID0gKG0gKiB2ZWM0KGF0dHIudGFuZ2VudC54eXosIDAuMCkpLnh5ejtcXG59XFxuI2VuZGlmXFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxuI2lmIFVTRV9JTlNUQU5DSU5HXFxuICBpbiB2ZWM0IGFfbWF0V29ybGQwO1xcbiAgaW4gdmVjNCBhX21hdFdvcmxkMTtcXG4gIGluIHZlYzQgYV9tYXRXb3JsZDI7XFxuICAjaWYgVVNFX0xJR0hUTUFQXFxuICAgIGluIHZlYzQgYV9saWdodGluZ01hcFVWUGFyYW07XFxuICAjZW5kaWZcXG4jZWxpZiBVU0VfQkFUQ0hJTkdcXG4gIGluIGZsb2F0IGFfZHluX2JhdGNoX2lkO1xcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0xvY2FsQmF0Y2hlZCB7XFxuICAgIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRzWzEwXTtcXG4gIH07XFxuI2Vsc2VcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxuI2VuZGlmXFxuZmxvYXQgTGluZWFyRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgY2FtX2RpcyA9IGRpc3RhbmNlKGNjX2NhbWVyYVBvcywgd1Bvcyk7XFxuICAgIGZsb2F0IGZvZ1N0YXJ0ID0gY2NfZm9nQmFzZS54O1xcbiAgICBmbG9hdCBmb2dFbmQgPSBjY19mb2dCYXNlLnk7XFxuICAgIHJldHVybiBjbGFtcCgoZm9nRW5kIC0gY2FtX2RpcykgLyAoZm9nRW5kIC0gZm9nU3RhcnQpLCAwLiwgMS4pO1xcbn1cXG5mbG9hdCBFeHBGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBmb2dBdHRlbiA9IGNjX2ZvZ0FkZC56O1xcbiAgICBmbG9hdCBmb2dEZW5zaXR5ID0gY2NfZm9nQmFzZS56O1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKSAvIGZvZ0F0dGVuICogNC47XFxuICAgIGZsb2F0IGYgPSBleHAoLWNhbV9kaXMgKiBmb2dEZW5zaXR5KTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbmZsb2F0IEV4cFNxdWFyZWRGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBmb2dBdHRlbiA9IGNjX2ZvZ0FkZC56O1xcbiAgICBmbG9hdCBmb2dEZW5zaXR5ID0gY2NfZm9nQmFzZS56O1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKSAvIGZvZ0F0dGVuICogNC47XFxuICAgIGZsb2F0IGYgPSBleHAoLWNhbV9kaXMgKiBjYW1fZGlzICogZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkpO1xcbiAgICByZXR1cm4gZjtcXG59XFxuZmxvYXQgTGF5ZXJlZEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IF9Gb2dUb3AgPSBjY19mb2dBZGQueDtcXG4gICAgZmxvYXQgX0ZvZ1JhbmdlID0gY2NfZm9nQWRkLnk7XFxuICAgIHZlYzMgY2FtV29ybGRQcm9qID0gY2NfY2FtZXJhUG9zLnh5ejtcXG4gICAgY2FtV29ybGRQcm9qLnkgPSAwLjtcXG4gICAgdmVjMyB3b3JsZFBvc1Byb2ogPSB3UG9zLnh5ejtcXG4gICAgd29ybGRQb3NQcm9qLnkgPSAwLjtcXG4gICAgZmxvYXQgZkRlbHRhRCA9IGRpc3RhbmNlKHdvcmxkUG9zUHJvaiwgY2FtV29ybGRQcm9qKSAvIGZvZ0F0dGVuICogMi4wO1xcbiAgICBmbG9hdCBmRGVsdGFZLCBmRGVuc2l0eUludGVncmFsO1xcbiAgICBpZiAoY2NfY2FtZXJhUG9zLnkgPiBfRm9nVG9wKSB7XFxuICAgICAgICBpZiAod1Bvcy55IDwgX0ZvZ1RvcCkge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSAoX0ZvZ1RvcCAtIHdQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjA7XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGZEZWx0YVkgKiBmRGVsdGFZICogMC41O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmRGVsdGFZID0gMC47XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IDAuO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHdQb3MueSA8IF9Gb2dUb3ApIHtcXG4gICAgICAgICAgICBmbG9hdCBmRGVsdGFBID0gKF9Gb2dUb3AgLSBjY19jYW1lcmFQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjtcXG4gICAgICAgICAgICBmbG9hdCBmRGVsdGFCID0gKF9Gb2dUb3AgLSB3UG9zLnkpIC8gX0ZvZ1JhbmdlICogMi47XFxuICAgICAgICAgICAgZkRlbHRhWSA9IGFicyhmRGVsdGFBIC0gZkRlbHRhQik7XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGFicygoZkRlbHRhQSAqIGZEZWx0YUEgKiAwLjUpIC0gKGZEZWx0YUIgKiBmRGVsdGFCICogMC41KSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSBhYnMoX0ZvZ1RvcCAtIGNjX2NhbWVyYVBvcy55KSAvIF9Gb2dSYW5nZSAqIDIuO1xcbiAgICAgICAgICAgIGZEZW5zaXR5SW50ZWdyYWwgPSBhYnMoZkRlbHRhWSAqIGZEZWx0YVkgKiAwLjUpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGZEZW5zaXR5O1xcbiAgICBpZiAoZkRlbHRhWSAhPSAwLikge1xcbiAgICAgICAgZkRlbnNpdHkgPSAoc3FydCgxLjAgKyAoKGZEZWx0YUQgLyBmRGVsdGFZKSAqIChmRGVsdGFEIC8gZkRlbHRhWSkpKSkgKiBmRGVuc2l0eUludGVncmFsO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZkRlbnNpdHkgPSAwLjtcXG4gICAgfVxcbiAgICBmbG9hdCBmID0gZXhwKC1mRGVuc2l0eSk7XFxuICAgIHJldHVybiBmO1xcbn1cXG5mbG9hdCBDQ19UUkFOU0ZFUl9GT0codmVjNCBwb3MpIHtcXG4gICAgI2lmIENDX1VTRV9GT0cgPT0gMVxcbiAgICAgICAgcmV0dXJuIExpbmVhckZvZyhwb3MpO1xcblx0I2VsaWYgQ0NfVVNFX0ZPRyA9PSAyXFxuICAgICAgICByZXR1cm4gRXhwRm9nKHBvcyk7XFxuICAgICNlbGlmIENDX1VTRV9GT0cgPT0gM1xcbiAgICAgICAgcmV0dXJuIEV4cFNxdWFyZWRGb2cocG9zKTtcXG4gICAgI2VsaWYgQ0NfVVNFX0ZPRyA9PSA0XFxuICAgICAgICByZXR1cm4gTGF5ZXJlZEZvZyhwb3MpO1xcbiAgICAjZW5kaWZcXG4gICAgcmV0dXJuIDEuO1xcbn1cXG4jaWYgVVNFX1ZFUlRFWF9DT0xPUlxcbiAgaW4gbG93cCB2ZWM0IGFfY29sb3I7XFxuICBvdXQgbG93cCB2ZWM0IHZfY29sb3I7XFxuI2VuZGlmXFxuI2lmIFVTRV9URVhUVVJFXFxuICBvdXQgdmVjMiB2X3V2O1xcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBUZXhDb29yZHMge1xcbiAgICB2ZWM0IHRpbGluZ09mZnNldDtcXG4gIH07XFxuI2VuZGlmXFxub3V0IGZsb2F0IGZhY3Rvcl9mb2c7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb247XFxuICBwb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gICNpZiBDQ19VU0VfTU9SUEhcXG4gICAgYXBwbHlNb3JwaChwb3NpdGlvbik7XFxuICAjZW5kaWZcXG4gICNpZiBDQ19VU0VfU0tJTk5JTkdcXG4gICAgQ0NTa2luKHBvc2l0aW9uKTtcXG4gICNlbmRpZlxcbiAgbWF0NCBtYXRXb3JsZDtcXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBtYXRXb3JsZCA9IG1hdDQoXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMS54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMi54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC53LCBhX21hdFdvcmxkMS53LCBhX21hdFdvcmxkMi53LCAxLjApXFxuICAgICk7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAjZWxzZVxcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX1RFWFRVUkVcXG4gICAgdl91diA9IGFfdGV4Q29vcmQgKiB0aWxpbmdPZmZzZXQueHkgKyB0aWxpbmdPZmZzZXQuenc7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuICBmYWN0b3JfZm9nID0gQ0NfVFJBTlNGRVJfRk9HKG1hdFdvcmxkICogcG9zaXRpb24pO1xcbiAgcmV0dXJuIGNjX21hdFByb2ogKiAoY2NfbWF0VmlldyAqIG1hdFdvcmxkKSAqIHBvc2l0aW9uO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxuI2lmIFVTRV9BTFBIQV9URVNUXFxuI2VuZGlmXFxuI2lmIFVTRV9URVhUVVJFXFxuICBpbiB2ZWMyIHZfdXY7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG4jZW5kaWZcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENvbnN0YW50IHtcXG4gIHZlYzQgbWFpbkNvbG9yO1xcbiAgdmVjNCBjb2xvclNjYWxlQW5kQ3V0b2ZmO1xcbn07XFxuI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gIGluIGxvd3AgdmVjNCB2X2NvbG9yO1xcbiNlbmRpZlxcbmluIGZsb2F0IGZhY3Rvcl9mb2c7XFxudmVjNCBmcmFnICgpIHtcXG4gIHZlYzQgbyA9IG1haW5Db2xvcjtcXG4gIG8ucmdiICo9IGNvbG9yU2NhbGVBbmRDdXRvZmYueHl6O1xcbiAgI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gICAgbyAqPSB2X2NvbG9yO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX1RFWFRVUkVcXG4gICAgbyAqPSB0ZXh0dXJlKG1haW5UZXh0dXJlLCB2X3V2KTtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTFBIQV9URVNUXFxuICAgIGlmIChvLkFMUEhBX1RFU1RfQ0hBTk5FTCA8IGNvbG9yU2NhbGVBbmRDdXRvZmYudykgZGlzY2FyZDtcXG4gICNlbmRpZlxcbiAgbyA9IHZlYzQobWl4KENDX0ZPUldBUkRfQUREID4gMCA/IHZlYzMoMC4wKSA6IGNjX2ZvZ0NvbG9yLnJnYiwgby5yZ2IsIGZhY3Rvcl9mb2cpLCBvLmEpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChvKTtcXG59XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsMVwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5oaWdocCBmbG9hdCBkZWNvZGUzMiAoaGlnaHAgdmVjNCByZ2JhKSB7XFxuICByZ2JhID0gcmdiYSAqIDI1NS4wO1xcbiAgaGlnaHAgZmxvYXQgU2lnbiA9IDEuMCAtIHN0ZXAoMTI3Ljk5LCByZ2JhWzNdKSAqIDIuMDtcXG4gIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gMi4wICogbW9kKHJnYmFbM10sIDEyNy45OSkgKyBzdGVwKDEyOC4wLCByZ2JhWzJdKSAtIDEyNy4wO1xcbiAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSBtb2QocmdiYVsyXSwgMTI4LjApICogNjU1MzYuMCArIHJnYmFbMV0gKiAyNTYuMCArIHJnYmFbMF0gKyA4Mzg4NjA4LjA7XFxuICByZXR1cm4gU2lnbiAqIGV4cDIoRXhwb25lbnQgLSAyMy4wKSAqIE1hbnRpc3NhO1xcbn1cXG5zdHJ1Y3QgU3RhbmRhcmRWZXJ0SW5wdXQge1xcbiAgaGlnaHAgdmVjNCBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjNCB0YW5nZW50O1xcbn07XFxuYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfdGFuZ2VudDtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX3ZlcnRleElkO1xcbiAgICBpbnQgZ2V0VmVydGV4SWQoKSB7XFxuICAgICAgICByZXR1cm4gaW50KGFfdmVydGV4SWQpO1xcbiAgICB9XFxudW5pZm9ybSB2ZWM0IGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbMTVdO1xcbnVuaWZvcm0gdmVjNCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mbztcXG52ZWMyIGdldFBpeGVsTG9jYXRpb24odmVjMiB0ZXh0dXJlUmVzb2x1dGlvbiwgaW50IHBpeGVsSW5kZXgpIHtcXG4gICAgZmxvYXQgcGl4ZWxJbmRleEYgPSBmbG9hdChwaXhlbEluZGV4KTtcXG4gICAgZmxvYXQgeCA9IG1vZChwaXhlbEluZGV4RiwgdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgIGZsb2F0IHkgPSBmbG9vcihwaXhlbEluZGV4RiAvIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICByZXR1cm4gdmVjMih4LCB5KTtcXG59XFxudmVjMiBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKHZlYzIgbG9jYXRpb24sIHZlYzIgdGV4dHVyZVJlc29sdXRpb24pIHtcXG4gICAgcmV0dXJuICh2ZWMyKGxvY2F0aW9uLngsIGxvY2F0aW9uLnkpICsgLjUpIC8gdGV4dHVyZVJlc29sdXRpb247XFxufVxcbiNpZiBDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgZWxlbWVudEluZGV4KSB7XFxuICAgICAgICAgICAgaW50IHBpeGVsSW5kZXggPSBlbGVtZW50SW5kZXg7XFxuICAgICAgICAgICAgdmVjMiBsb2NhdGlvbiA9IGdldFBpeGVsTG9jYXRpb24oY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHksIHBpeGVsSW5kZXgpO1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmUyRCh0ZXgsIHV2KTtcXG4gICAgICAgIH1cXG4jZWxzZVxcbiAgICB2ZWM0IGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IGVsZW1lbnRJbmRleCkge1xcbiAgICAgICAgaW50IHBpeGVsSW5kZXggPSBlbGVtZW50SW5kZXggKiA0O1xcbiAgICAgICAgdmVjMiBsb2NhdGlvbiA9IGdldFBpeGVsTG9jYXRpb24oY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHksIHBpeGVsSW5kZXgpO1xcbiAgICAgICAgdmVjMiB4ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMC4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICB2ZWMyIHkgPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigxLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHZlYzIgeiA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDIuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgcmV0dXJuIHZlYzQoXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKHRleCwgeCkpLFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUyRCh0ZXgsIHkpKSxcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQodGV4LCB6KSksXFxuICAgICAgICAgICAgMS4wXFxuICAgICAgICApO1xcbiAgICB9XFxuI2VuZGlmXFxuZmxvYXQgZ2V0RGlzcGxhY2VtZW50V2VpZ2h0KGludCBpbmRleCkge1xcbiAgICBmbG9hdCBtID0gbW9kKGZsb2F0KGluZGV4KSwgNC4wKTtcXG4gICAgaWYgKG0gPCAxLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueDtcXG4gICAgfSBlbHNlIGlmIChtIDwgMi4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnk7XFxuICAgIH0gZWxzZSBpZiAobSA8IDMuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS56O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS53O1xcbiAgICB9XFxufVxcbnZlYzMgZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCB2ZXJ0ZXhJbmRleCkge1xcbiNpZiBDQ19NT1JQSF9QUkVDT01QVVRFRFxcbiAgICByZXR1cm4gZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZSh0ZXgsIHZlcnRleEluZGV4KS5yZ2I7XFxuI2Vsc2VcXG4gICAgdmVjMyByZXN1bHQgPSB2ZWMzKDAsIDAsIDApO1xcbiAgICBmb3IgKGludCBpVGFyZ2V0ID0gMDsgaVRhcmdldCA8IENDX01PUlBIX1RBUkdFVF9DT1VOVDsgKytpVGFyZ2V0KSB7XFxuICAgICAgICBpbnQgZGF0YVBpeGVsU3RhcnQgPSBpbnQoZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZSh0ZXgsIGlUYXJnZXQpLnIpO1xcbiAgICAgICAgcmVzdWx0ICs9IChmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgZGF0YVBpeGVsU3RhcnQgKyB2ZXJ0ZXhJbmRleCkucmdiICogZ2V0RGlzcGxhY2VtZW50V2VpZ2h0KGlUYXJnZXQpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiNlbmRpZlxcbn1cXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX05vcm1hbERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19Ob3JtYWxEaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1RhbmdlbnREaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldFRhbmdlbnREaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1RhbmdlbnREaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gICAgaW50IHZlcnRleElkID0gZ2V0VmVydGV4SWQoKTtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBhdHRyLnBvc2l0aW9uLnh5eiA9IGF0dHIucG9zaXRpb24ueHl6ICsgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFxcbiAgICBhdHRyLm5vcm1hbC54eXogPSBhdHRyLm5vcm1hbC54eXogKyBnZXROb3JtYWxEaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgYXR0ci50YW5nZW50Lnh5eiA9IGF0dHIudGFuZ2VudC54eXogKyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG59XFxudm9pZCBhcHBseU1vcnBoIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgcG9zaXRpb24ueHl6ID0gcG9zaXRpb24ueHl6ICsgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoZ2V0VmVydGV4SWQoKSk7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbiNpZiBDQ19VU0VfU0tJTk5JTkdcXG5hdHRyaWJ1dGUgdmVjNCBhX2pvaW50cztcXG5hdHRyaWJ1dGUgdmVjNCBhX3dlaWdodHM7XFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBhdHRyaWJ1dGUgaGlnaHAgdmVjNCBhX2pvaW50QW5pbUluZm87XFxuICAjZW5kaWZcXG4gIHVuaWZvcm0gaGlnaHAgdmVjNCBjY19qb2ludFRleHR1cmVJbmZvO1xcbiAgdW5pZm9ybSBoaWdocCB2ZWM0IGNjX2pvaW50QW5pbUluZm87XFxuICB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBjY19qb2ludFRleHR1cmU7XFxuICAjZWxzZVxcbiAgdW5pZm9ybSBoaWdocCB2ZWM0IGNjX2pvaW50c1s5MF07XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoY2Nfam9pbnRBbmltSW5mby54ICogY2Nfam9pbnRUZXh0dXJlSW5mby55ICsgaSkgKyBjY19qb2ludFRleHR1cmVJbmZvLno7XFxuICAgICNlbmRpZlxcbiAgICBoaWdocCBmbG9hdCBpbnZTaXplID0gY2Nfam9pbnRUZXh0dXJlSW5mby53O1xcbiAgICBoaWdocCBmbG9hdCB5ID0gZmxvb3IoaiAqIGludlNpemUpO1xcbiAgICBoaWdocCBmbG9hdCB4ID0gaiAtIHkgKiBjY19qb2ludFRleHR1cmVJbmZvLng7XFxuICAgIHkgPSAoeSArIDAuNSkgKiBpbnZTaXplO1xcbiAgICAgIHZlYzQgdjEgPSB0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYyID0gdGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MyA9IHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbHNlXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDEyLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDEyLjAgKiAoY2Nfam9pbnRBbmltSW5mby54ICogY2Nfam9pbnRUZXh0dXJlSW5mby55ICsgaSkgKyBjY19qb2ludFRleHR1cmVJbmZvLno7XFxuICAgICNlbmRpZlxcbiAgICBoaWdocCBmbG9hdCBpbnZTaXplID0gY2Nfam9pbnRUZXh0dXJlSW5mby53O1xcbiAgICBoaWdocCBmbG9hdCB5ID0gZmxvb3IoaiAqIGludlNpemUpO1xcbiAgICBoaWdocCBmbG9hdCB4ID0gaiAtIHkgKiBjY19qb2ludFRleHR1cmVJbmZvLng7XFxuICAgIHkgPSAoeSArIDAuNSkgKiBpbnZTaXplO1xcbiAgICAgIHZlYzQgdjEgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDMuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYyID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA0LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA1LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA2LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA3LjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MyA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgOC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgOS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDExLjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2VuZGlmXFxuI2Vsc2VcXG4gIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgaW50IGlkeCA9IGludChpKTtcXG4gICAgdmVjNCB2MSA9IGNjX2pvaW50c1tpZHggKiAzXTtcXG4gICAgdmVjNCB2MiA9IGNjX2pvaW50c1tpZHggKiAzICsgMV07XFxuICAgIHZlYzQgdjMgPSBjY19qb2ludHNbaWR4ICogMyArIDJdO1xcbiAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgfVxcbiNlbmRpZlxcbm1hdDQgc2tpbk1hdHJpeCAoKSB7XFxuICByZXR1cm4gZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueCkgKiBhX3dlaWdodHMueFxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnkpICogYV93ZWlnaHRzLnlcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy56KSAqIGFfd2VpZ2h0cy56XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMudykgKiBhX3dlaWdodHMudztcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIHBvc2l0aW9uID0gbSAqIHBvc2l0aW9uO1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgYXR0ci5wb3NpdGlvbiA9IG0gKiBhdHRyLnBvc2l0aW9uO1xcbiAgYXR0ci5ub3JtYWwgPSAobSAqIHZlYzQoYXR0ci5ub3JtYWwsIDAuMCkpLnh5ejtcXG4gIGF0dHIudGFuZ2VudC54eXogPSAobSAqIHZlYzQoYXR0ci50YW5nZW50Lnh5eiwgMC4wKSkueHl6O1xcbn1cXG4jZW5kaWZcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0VmlldztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0UHJvajtcXG51bmlmb3JtIGhpZ2hwIHZlYzQgY2NfY2FtZXJhUG9zO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbiNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgYXR0cmlidXRlIHZlYzQgYV9tYXRXb3JsZDA7XFxuICBhdHRyaWJ1dGUgdmVjNCBhX21hdFdvcmxkMTtcXG4gIGF0dHJpYnV0ZSB2ZWM0IGFfbWF0V29ybGQyO1xcbiAgI2lmIFVTRV9MSUdIVE1BUFxcbiAgICBhdHRyaWJ1dGUgdmVjNCBhX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG4gICNlbmRpZlxcbiNlbGlmIFVTRV9CQVRDSElOR1xcbiAgYXR0cmlidXRlIGZsb2F0IGFfZHluX2JhdGNoX2lkO1xcbiAgdW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFdvcmxkc1sxMF07XFxuI2Vsc2VcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuI2VuZGlmXFxuZmxvYXQgTGluZWFyRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgY2FtX2RpcyA9IGRpc3RhbmNlKGNjX2NhbWVyYVBvcywgd1Bvcyk7XFxuICAgIGZsb2F0IGZvZ1N0YXJ0ID0gY2NfZm9nQmFzZS54O1xcbiAgICBmbG9hdCBmb2dFbmQgPSBjY19mb2dCYXNlLnk7XFxuICAgIHJldHVybiBjbGFtcCgoZm9nRW5kIC0gY2FtX2RpcykgLyAoZm9nRW5kIC0gZm9nU3RhcnQpLCAwLiwgMS4pO1xcbn1cXG5mbG9hdCBFeHBGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBmb2dBdHRlbiA9IGNjX2ZvZ0FkZC56O1xcbiAgICBmbG9hdCBmb2dEZW5zaXR5ID0gY2NfZm9nQmFzZS56O1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKSAvIGZvZ0F0dGVuICogNC47XFxuICAgIGZsb2F0IGYgPSBleHAoLWNhbV9kaXMgKiBmb2dEZW5zaXR5KTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbmZsb2F0IEV4cFNxdWFyZWRGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBmb2dBdHRlbiA9IGNjX2ZvZ0FkZC56O1xcbiAgICBmbG9hdCBmb2dEZW5zaXR5ID0gY2NfZm9nQmFzZS56O1xcbiAgICBmbG9hdCBjYW1fZGlzID0gZGlzdGFuY2UoY2NfY2FtZXJhUG9zLCB3UG9zKSAvIGZvZ0F0dGVuICogNC47XFxuICAgIGZsb2F0IGYgPSBleHAoLWNhbV9kaXMgKiBjYW1fZGlzICogZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkpO1xcbiAgICByZXR1cm4gZjtcXG59XFxuZmxvYXQgTGF5ZXJlZEZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGZvZ0F0dGVuID0gY2NfZm9nQWRkLno7XFxuICAgIGZsb2F0IF9Gb2dUb3AgPSBjY19mb2dBZGQueDtcXG4gICAgZmxvYXQgX0ZvZ1JhbmdlID0gY2NfZm9nQWRkLnk7XFxuICAgIHZlYzMgY2FtV29ybGRQcm9qID0gY2NfY2FtZXJhUG9zLnh5ejtcXG4gICAgY2FtV29ybGRQcm9qLnkgPSAwLjtcXG4gICAgdmVjMyB3b3JsZFBvc1Byb2ogPSB3UG9zLnh5ejtcXG4gICAgd29ybGRQb3NQcm9qLnkgPSAwLjtcXG4gICAgZmxvYXQgZkRlbHRhRCA9IGRpc3RhbmNlKHdvcmxkUG9zUHJvaiwgY2FtV29ybGRQcm9qKSAvIGZvZ0F0dGVuICogMi4wO1xcbiAgICBmbG9hdCBmRGVsdGFZLCBmRGVuc2l0eUludGVncmFsO1xcbiAgICBpZiAoY2NfY2FtZXJhUG9zLnkgPiBfRm9nVG9wKSB7XFxuICAgICAgICBpZiAod1Bvcy55IDwgX0ZvZ1RvcCkge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSAoX0ZvZ1RvcCAtIHdQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjA7XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGZEZWx0YVkgKiBmRGVsdGFZICogMC41O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmRGVsdGFZID0gMC47XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IDAuO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHdQb3MueSA8IF9Gb2dUb3ApIHtcXG4gICAgICAgICAgICBmbG9hdCBmRGVsdGFBID0gKF9Gb2dUb3AgLSBjY19jYW1lcmFQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjtcXG4gICAgICAgICAgICBmbG9hdCBmRGVsdGFCID0gKF9Gb2dUb3AgLSB3UG9zLnkpIC8gX0ZvZ1JhbmdlICogMi47XFxuICAgICAgICAgICAgZkRlbHRhWSA9IGFicyhmRGVsdGFBIC0gZkRlbHRhQik7XFxuICAgICAgICAgICAgZkRlbnNpdHlJbnRlZ3JhbCA9IGFicygoZkRlbHRhQSAqIGZEZWx0YUEgKiAwLjUpIC0gKGZEZWx0YUIgKiBmRGVsdGFCICogMC41KSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSBhYnMoX0ZvZ1RvcCAtIGNjX2NhbWVyYVBvcy55KSAvIF9Gb2dSYW5nZSAqIDIuO1xcbiAgICAgICAgICAgIGZEZW5zaXR5SW50ZWdyYWwgPSBhYnMoZkRlbHRhWSAqIGZEZWx0YVkgKiAwLjUpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGZEZW5zaXR5O1xcbiAgICBpZiAoZkRlbHRhWSAhPSAwLikge1xcbiAgICAgICAgZkRlbnNpdHkgPSAoc3FydCgxLjAgKyAoKGZEZWx0YUQgLyBmRGVsdGFZKSAqIChmRGVsdGFEIC8gZkRlbHRhWSkpKSkgKiBmRGVuc2l0eUludGVncmFsO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZkRlbnNpdHkgPSAwLjtcXG4gICAgfVxcbiAgICBmbG9hdCBmID0gZXhwKC1mRGVuc2l0eSk7XFxuICAgIHJldHVybiBmO1xcbn1cXG5mbG9hdCBDQ19UUkFOU0ZFUl9GT0codmVjNCBwb3MpIHtcXG4gICAgI2lmIENDX1VTRV9GT0cgPT0gMVxcbiAgICAgICAgcmV0dXJuIExpbmVhckZvZyhwb3MpO1xcblx0I2VsaWYgQ0NfVVNFX0ZPRyA9PSAyXFxuICAgICAgICByZXR1cm4gRXhwRm9nKHBvcyk7XFxuICAgICNlbGlmIENDX1VTRV9GT0cgPT0gM1xcbiAgICAgICAgcmV0dXJuIEV4cFNxdWFyZWRGb2cocG9zKTtcXG4gICAgI2VsaWYgQ0NfVVNFX0ZPRyA9PSA0XFxuICAgICAgICByZXR1cm4gTGF5ZXJlZEZvZyhwb3MpO1xcbiAgICAjZW5kaWZcXG4gICAgcmV0dXJuIDEuO1xcbn1cXG4jaWYgVVNFX1ZFUlRFWF9DT0xPUlxcbiAgYXR0cmlidXRlIGxvd3AgdmVjNCBhX2NvbG9yO1xcbiAgdmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXG4jZW5kaWZcXG4jaWYgVVNFX1RFWFRVUkVcXG4gIHZhcnlpbmcgdmVjMiB2X3V2O1xcbiAgdW5pZm9ybSB2ZWM0IHRpbGluZ09mZnNldDtcXG4jZW5kaWZcXG52YXJ5aW5nIGZsb2F0IGZhY3Rvcl9mb2c7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb247XFxuICBwb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gICNpZiBDQ19VU0VfTU9SUEhcXG4gICAgYXBwbHlNb3JwaChwb3NpdGlvbik7XFxuICAjZW5kaWZcXG4gICNpZiBDQ19VU0VfU0tJTk5JTkdcXG4gICAgQ0NTa2luKHBvc2l0aW9uKTtcXG4gICNlbmRpZlxcbiAgbWF0NCBtYXRXb3JsZDtcXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBtYXRXb3JsZCA9IG1hdDQoXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMS54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMi54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC53LCBhX21hdFdvcmxkMS53LCBhX21hdFdvcmxkMi53LCAxLjApXFxuICAgICk7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAjZWxzZVxcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX1RFWFRVUkVcXG4gICAgdl91diA9IGFfdGV4Q29vcmQgKiB0aWxpbmdPZmZzZXQueHkgKyB0aWxpbmdPZmZzZXQuenc7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuICBmYWN0b3JfZm9nID0gQ0NfVFJBTlNGRVJfRk9HKG1hdFdvcmxkICogcG9zaXRpb24pO1xcbiAgcmV0dXJuIGNjX21hdFByb2ogKiAoY2NfbWF0VmlldyAqIG1hdFdvcmxkKSAqIHBvc2l0aW9uO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxuI2lmIFVTRV9BTFBIQV9URVNUXFxuI2VuZGlmXFxuI2lmIFVTRV9URVhUVVJFXFxuICB2YXJ5aW5nIHZlYzIgdl91djtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbiNlbmRpZlxcbnVuaWZvcm0gdmVjNCBtYWluQ29sb3I7XFxudW5pZm9ybSB2ZWM0IGNvbG9yU2NhbGVBbmRDdXRvZmY7XFxuI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gIHZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxuI2VuZGlmXFxudmFyeWluZyBmbG9hdCBmYWN0b3JfZm9nO1xcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IG8gPSBtYWluQ29sb3I7XFxuICBvLnJnYiAqPSBjb2xvclNjYWxlQW5kQ3V0b2ZmLnh5ejtcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIG8gKj0gdl9jb2xvcjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9URVhUVVJFXFxuICAgIG8gKj0gdGV4dHVyZTJEKG1haW5UZXh0dXJlLCB2X3V2KTtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTFBIQV9URVNUXFxuICAgIGlmIChvLkFMUEhBX1RFU1RfQ0hBTk5FTCA8IGNvbG9yU2NhbGVBbmRDdXRvZmYudykgZGlzY2FyZDtcXG4gICNlbmRpZlxcbiAgbyA9IHZlYzQobWl4KENDX0ZPUldBUkRfQUREID4gMCA/IHZlYzMoMC4wKSA6IGNjX2ZvZ0NvbG9yLnJnYiwgby5yZ2IsIGZhY3Rvcl9mb2cpLCBvLmEpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChvKTtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2w0XCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxuI2lmZGVmIEdMX0VYVF9zaGFkZXJfZXhwbGljaXRfYXJpdGhtZXRpY190eXBlc19pbnQxNlxcbiNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2ludDE2OiBlbmFibGVcXG4jZW5kaWZcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgcmdiYSA9IHJnYmEgKiAyNTUuMDtcXG4gIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyNy45OSwgcmdiYVszXSkgKiAyLjA7XFxuICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjcuOTkpICsgc3RlcCgxMjguMCwgcmdiYVsyXSkgLSAxMjcuMDtcXG4gIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG59XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzMgYV9wb3NpdGlvbjtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMzIGFfbm9ybWFsO1xcbmxheW91dChsb2NhdGlvbiA9IDIpIGluIHZlYzIgYV90ZXhDb29yZDtcXG5sYXlvdXQobG9jYXRpb24gPSAzKSBpbiB2ZWM0IGFfdGFuZ2VudDtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGludCBnZXRWZXJ0ZXhJZCgpIHtcXG4gICAgICAgIHJldHVybiBnbF9WZXJ0ZXhJbmRleDtcXG4gICAgfVxcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gNCkgdW5pZm9ybSBDQ01vcnBoIHtcXG4gICAgdmVjNCBjY19kaXNwbGFjZW1lbnRXZWlnaHRzWzE1XTtcXG4gICAgdmVjNCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mbztcXG59O1xcbnZlYzIgZ2V0UGl4ZWxMb2NhdGlvbih2ZWMyIHRleHR1cmVSZXNvbHV0aW9uLCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICBmbG9hdCBwaXhlbEluZGV4RiA9IGZsb2F0KHBpeGVsSW5kZXgpO1xcbiAgICBmbG9hdCB4ID0gbW9kKHBpeGVsSW5kZXhGLCB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgZmxvYXQgeSA9IGZsb29yKHBpeGVsSW5kZXhGIC8gdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgIHJldHVybiB2ZWMyKHgsIHkpO1xcbn1cXG52ZWMyIGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24odmVjMiBsb2NhdGlvbiwgdmVjMiB0ZXh0dXJlUmVzb2x1dGlvbikge1xcbiAgICByZXR1cm4gKHZlYzIobG9jYXRpb24ueCwgbG9jYXRpb24ueSkgKyAuNSkgLyB0ZXh0dXJlUmVzb2x1dGlvbjtcXG59XFxuI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICAgICAgdmVjNCBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCBwaXhlbEluZGV4KSB7XFxuICAgICAgICAgICAgaXZlYzIgdGV4U2l6ZSA9IHRleHR1cmVTaXplKHRleCwgMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRleGVsRmV0Y2godGV4LCBpdmVjMihwaXhlbEluZGV4ICUgdGV4U2l6ZS54LCBwaXhlbEluZGV4IC8gdGV4U2l6ZS54KSwgMCk7XFxuICAgICAgICB9XFxuI2Vsc2VcXG4gICAgdmVjNCBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCBlbGVtZW50SW5kZXgpIHtcXG4gICAgICAgIGludCBwaXhlbEluZGV4ID0gZWxlbWVudEluZGV4ICogNDtcXG4gICAgICAgIHZlYzIgbG9jYXRpb24gPSBnZXRQaXhlbExvY2F0aW9uKGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5LCBwaXhlbEluZGV4KTtcXG4gICAgICAgIHZlYzIgeCA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDAuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB5ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMS4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICB2ZWMyIHogPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigyLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHJldHVybiB2ZWM0KFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUodGV4LCB4KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZSh0ZXgsIHkpKSxcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKHRleCwgeikpLFxcbiAgICAgICAgICAgIDEuMFxcbiAgICAgICAgKTtcXG4gICAgfVxcbiNlbmRpZlxcbmZsb2F0IGdldERpc3BsYWNlbWVudFdlaWdodChpbnQgaW5kZXgpIHtcXG4gICAgZmxvYXQgbSA9IG1vZChmbG9hdChpbmRleCksIDQuMCk7XFxuICAgIGlmIChtIDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLng7XFxuICAgIH0gZWxzZSBpZiAobSA8IDIuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS55O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAzLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0uejtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0udztcXG4gICAgfVxcbn1cXG52ZWMzIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgdmVydGV4SW5kZXgpIHtcXG4jaWYgQ0NfTU9SUEhfUFJFQ09NUFVURURcXG4gICAgcmV0dXJuIGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCB2ZXJ0ZXhJbmRleCkucmdiO1xcbiNlbHNlXFxuICAgIHZlYzMgcmVzdWx0ID0gdmVjMygwLCAwLCAwKTtcXG4gICAgZm9yIChpbnQgaVRhcmdldCA9IDA7IGlUYXJnZXQgPCBDQ19NT1JQSF9UQVJHRVRfQ09VTlQ7ICsraVRhcmdldCkge1xcbiAgICAgICAgaW50IGRhdGFQaXhlbFN0YXJ0ID0gaW50KGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBpVGFyZ2V0KS5yKTtcXG4gICAgICAgIHJlc3VsdCArPSAoZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZSh0ZXgsIGRhdGFQaXhlbFN0YXJ0ICsgdmVydGV4SW5kZXgpLnJnYiAqIGdldERpc3BsYWNlbWVudFdlaWdodChpVGFyZ2V0KSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4jZW5kaWZcXG59XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSA2KSB1bmlmb3JtIHNhbXBsZXIyRCBjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gNykgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSA4KSB1bmlmb3JtIHNhbXBsZXIyRCBjY19UYW5nZW50RGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19UYW5nZW50RGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxudm9pZCBhcHBseU1vcnBoIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICAgIGludCB2ZXJ0ZXhJZCA9IGdldFZlcnRleElkKCk7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgYXR0ci5wb3NpdGlvbi54eXogPSBhdHRyLnBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgYXR0ci5ub3JtYWwueHl6ID0gYXR0ci5ub3JtYWwueHl6ICsgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIGF0dHIudGFuZ2VudC54eXogPSBhdHRyLnRhbmdlbnQueHl6ICsgZ2V0VGFuZ2VudERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxufVxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHBvc2l0aW9uLnh5eiA9IHBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGdldFZlcnRleElkKCkpO1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX1NLSU5OSU5HXFxubGF5b3V0KGxvY2F0aW9uID0gNCkgaW4gdTE2dmVjNCBhX2pvaW50cztcXG5sYXlvdXQobG9jYXRpb24gPSA1KSBpbiB2ZWM0IGFfd2VpZ2h0cztcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIGxheW91dChsb2NhdGlvbiA9IDcpIGluIGhpZ2hwIHZlYzQgYV9qb2ludEFuaW1JbmZvO1xcbiAgI2VuZGlmXFxuICBsYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDMpIHVuaWZvcm0gQ0NTa2lubmluZ1RleHR1cmUge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50VGV4dHVyZUluZm87XFxuICB9O1xcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAyKSB1bmlmb3JtIENDU2tpbm5pbmdBbmltYXRpb24ge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50QW5pbUluZm87XFxuICB9O1xcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSA1KSB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBjY19qb2ludFRleHR1cmU7XFxuICAjZWxzZVxcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAzKSB1bmlmb3JtIENDU2tpbm5pbmcge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50c1szMCAqIDNdO1xcbiAgfTtcXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYyID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDMuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYyID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDUuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA2LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjMgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA4LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgOS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTEuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4jZWxzZVxcbiAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICBpbnQgaWR4ID0gaW50KGkpO1xcbiAgICB2ZWM0IHYxID0gY2Nfam9pbnRzW2lkeCAqIDNdO1xcbiAgICB2ZWM0IHYyID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAxXTtcXG4gICAgdmVjNCB2MyA9IGNjX2pvaW50c1tpZHggKiAzICsgMl07XFxuICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICB9XFxuI2VuZGlmXFxubWF0NCBza2luTWF0cml4ICgpIHtcXG4gIHJldHVybiBnZXRKb2ludE1hdHJpeChhX2pvaW50cy54KSAqIGFfd2VpZ2h0cy54XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueSkgKiBhX3dlaWdodHMueVxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnopICogYV93ZWlnaHRzLnpcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy53KSAqIGFfd2VpZ2h0cy53O1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgcG9zaXRpb24gPSBtICogcG9zaXRpb247XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBhdHRyLnBvc2l0aW9uID0gbSAqIGF0dHIucG9zaXRpb247XFxuICBhdHRyLm5vcm1hbCA9IChtICogdmVjNChhdHRyLm5vcm1hbCwgMC4wKSkueHl6O1xcbiAgYXR0ci50YW5nZW50Lnh5eiA9IChtICogdmVjNChhdHRyLnRhbmdlbnQueHl6LCAwLjApKS54eXo7XFxufVxcbiNlbmRpZlxcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxuI2lmIFVTRV9JTlNUQU5DSU5HXFxuICBsYXlvdXQobG9jYXRpb24gPSA4KSBpbiB2ZWM0IGFfbWF0V29ybGQwO1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gOSkgaW4gdmVjNCBhX21hdFdvcmxkMTtcXG4gIGxheW91dChsb2NhdGlvbiA9IDEwKSBpbiB2ZWM0IGFfbWF0V29ybGQyO1xcbiAgI2lmIFVTRV9MSUdIVE1BUFxcbiAgICBsYXlvdXQobG9jYXRpb24gPSAxMSkgaW4gdmVjNCBhX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG4gICNlbmRpZlxcbiNlbGlmIFVTRV9CQVRDSElOR1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gMTIpIGluIGZsb2F0IGFfZHluX2JhdGNoX2lkO1xcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDTG9jYWxCYXRjaGVkIHtcXG4gICAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZHNbMTBdO1xcbiAgfTtcXG4jZWxzZVxcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbiNlbmRpZlxcbmZsb2F0IExpbmVhckZvZyh2ZWM0IHBvcykge1xcbiAgICB2ZWM0IHdQb3MgPSBwb3M7XFxuICAgIGZsb2F0IGNhbV9kaXMgPSBkaXN0YW5jZShjY19jYW1lcmFQb3MsIHdQb3MpO1xcbiAgICBmbG9hdCBmb2dTdGFydCA9IGNjX2ZvZ0Jhc2UueDtcXG4gICAgZmxvYXQgZm9nRW5kID0gY2NfZm9nQmFzZS55O1xcbiAgICByZXR1cm4gY2xhbXAoKGZvZ0VuZCAtIGNhbV9kaXMpIC8gKGZvZ0VuZCAtIGZvZ1N0YXJ0KSwgMC4sIDEuKTtcXG59XFxuZmxvYXQgRXhwRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgZm9nQXR0ZW4gPSBjY19mb2dBZGQuejtcXG4gICAgZmxvYXQgZm9nRGVuc2l0eSA9IGNjX2ZvZ0Jhc2UuejtcXG4gICAgZmxvYXQgY2FtX2RpcyA9IGRpc3RhbmNlKGNjX2NhbWVyYVBvcywgd1BvcykgLyBmb2dBdHRlbiAqIDQuO1xcbiAgICBmbG9hdCBmID0gZXhwKC1jYW1fZGlzICogZm9nRGVuc2l0eSk7XFxuICAgIHJldHVybiBmO1xcbn1cXG5mbG9hdCBFeHBTcXVhcmVkRm9nKHZlYzQgcG9zKSB7XFxuICAgIHZlYzQgd1BvcyA9IHBvcztcXG4gICAgZmxvYXQgZm9nQXR0ZW4gPSBjY19mb2dBZGQuejtcXG4gICAgZmxvYXQgZm9nRGVuc2l0eSA9IGNjX2ZvZ0Jhc2UuejtcXG4gICAgZmxvYXQgY2FtX2RpcyA9IGRpc3RhbmNlKGNjX2NhbWVyYVBvcywgd1BvcykgLyBmb2dBdHRlbiAqIDQuO1xcbiAgICBmbG9hdCBmID0gZXhwKC1jYW1fZGlzICogY2FtX2RpcyAqIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5KTtcXG4gICAgcmV0dXJuIGY7XFxufVxcbmZsb2F0IExheWVyZWRGb2codmVjNCBwb3MpIHtcXG4gICAgdmVjNCB3UG9zID0gcG9zO1xcbiAgICBmbG9hdCBmb2dBdHRlbiA9IGNjX2ZvZ0FkZC56O1xcbiAgICBmbG9hdCBfRm9nVG9wID0gY2NfZm9nQWRkLng7XFxuICAgIGZsb2F0IF9Gb2dSYW5nZSA9IGNjX2ZvZ0FkZC55O1xcbiAgICB2ZWMzIGNhbVdvcmxkUHJvaiA9IGNjX2NhbWVyYVBvcy54eXo7XFxuICAgIGNhbVdvcmxkUHJvai55ID0gMC47XFxuICAgIHZlYzMgd29ybGRQb3NQcm9qID0gd1Bvcy54eXo7XFxuICAgIHdvcmxkUG9zUHJvai55ID0gMC47XFxuICAgIGZsb2F0IGZEZWx0YUQgPSBkaXN0YW5jZSh3b3JsZFBvc1Byb2osIGNhbVdvcmxkUHJvaikgLyBmb2dBdHRlbiAqIDIuMDtcXG4gICAgZmxvYXQgZkRlbHRhWSwgZkRlbnNpdHlJbnRlZ3JhbDtcXG4gICAgaWYgKGNjX2NhbWVyYVBvcy55ID4gX0ZvZ1RvcCkge1xcbiAgICAgICAgaWYgKHdQb3MueSA8IF9Gb2dUb3ApIHtcXG4gICAgICAgICAgICBmRGVsdGFZID0gKF9Gb2dUb3AgLSB3UG9zLnkpIC8gX0ZvZ1JhbmdlICogMi4wO1xcbiAgICAgICAgICAgIGZEZW5zaXR5SW50ZWdyYWwgPSBmRGVsdGFZICogZkRlbHRhWSAqIDAuNTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZkRlbHRhWSA9IDAuO1xcbiAgICAgICAgICAgIGZEZW5zaXR5SW50ZWdyYWwgPSAwLjtcXG4gICAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICh3UG9zLnkgPCBfRm9nVG9wKSB7XFxuICAgICAgICAgICAgZmxvYXQgZkRlbHRhQSA9IChfRm9nVG9wIC0gY2NfY2FtZXJhUG9zLnkpIC8gX0ZvZ1JhbmdlICogMi47XFxuICAgICAgICAgICAgZmxvYXQgZkRlbHRhQiA9IChfRm9nVG9wIC0gd1Bvcy55KSAvIF9Gb2dSYW5nZSAqIDIuO1xcbiAgICAgICAgICAgIGZEZWx0YVkgPSBhYnMoZkRlbHRhQSAtIGZEZWx0YUIpO1xcbiAgICAgICAgICAgIGZEZW5zaXR5SW50ZWdyYWwgPSBhYnMoKGZEZWx0YUEgKiBmRGVsdGFBICogMC41KSAtIChmRGVsdGFCICogZkRlbHRhQiAqIDAuNSkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmRGVsdGFZID0gYWJzKF9Gb2dUb3AgLSBjY19jYW1lcmFQb3MueSkgLyBfRm9nUmFuZ2UgKiAyLjtcXG4gICAgICAgICAgICBmRGVuc2l0eUludGVncmFsID0gYWJzKGZEZWx0YVkgKiBmRGVsdGFZICogMC41KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBmbG9hdCBmRGVuc2l0eTtcXG4gICAgaWYgKGZEZWx0YVkgIT0gMC4pIHtcXG4gICAgICAgIGZEZW5zaXR5ID0gKHNxcnQoMS4wICsgKChmRGVsdGFEIC8gZkRlbHRhWSkgKiAoZkRlbHRhRCAvIGZEZWx0YVkpKSkpICogZkRlbnNpdHlJbnRlZ3JhbDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGZEZW5zaXR5ID0gMC47XFxuICAgIH1cXG4gICAgZmxvYXQgZiA9IGV4cCgtZkRlbnNpdHkpO1xcbiAgICByZXR1cm4gZjtcXG59XFxuZmxvYXQgQ0NfVFJBTlNGRVJfRk9HKHZlYzQgcG9zKSB7XFxuICAgICNpZiBDQ19VU0VfRk9HID09IDFcXG4gICAgICAgIHJldHVybiBMaW5lYXJGb2cocG9zKTtcXG5cdCNlbGlmIENDX1VTRV9GT0cgPT0gMlxcbiAgICAgICAgcmV0dXJuIEV4cEZvZyhwb3MpO1xcbiAgICAjZWxpZiBDQ19VU0VfRk9HID09IDNcXG4gICAgICAgIHJldHVybiBFeHBTcXVhcmVkRm9nKHBvcyk7XFxuICAgICNlbGlmIENDX1VTRV9GT0cgPT0gNFxcbiAgICAgICAgcmV0dXJuIExheWVyZWRGb2cocG9zKTtcXG4gICAgI2VuZGlmXFxuICAgIHJldHVybiAxLjtcXG59XFxuI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gIGxheW91dChsb2NhdGlvbiA9IDEzKSBpbiBsb3dwIHZlYzQgYV9jb2xvcjtcXG4gIGxheW91dChsb2NhdGlvbiA9IDApIG91dCBsb3dwIHZlYzQgdl9jb2xvcjtcXG4jZW5kaWZcXG4jaWYgVVNFX1RFWFRVUkVcXG4gIGxheW91dChsb2NhdGlvbiA9IDEpIG91dCB2ZWMyIHZfdXY7XFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDApIHVuaWZvcm0gVGV4Q29vcmRzIHtcXG4gICAgdmVjNCB0aWxpbmdPZmZzZXQ7XFxuICB9O1xcbiNlbmRpZlxcbmxheW91dChsb2NhdGlvbiA9IDIpIG91dCBmbG9hdCBmYWN0b3JfZm9nO1xcbnZlYzQgdmVydCAoKSB7XFxuICB2ZWM0IHBvc2l0aW9uO1xcbiAgcG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICAjaWYgQ0NfVVNFX01PUlBIXFxuICAgIGFwcGx5TW9ycGgocG9zaXRpb24pO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfVVNFX1NLSU5OSU5HXFxuICAgIENDU2tpbihwb3NpdGlvbik7XFxuICAjZW5kaWZcXG4gIG1hdDQgbWF0V29ybGQ7XFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgbWF0V29ybGQgPSBtYXQ0KFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDEueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDIueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAudywgYV9tYXRXb3JsZDEudywgYV9tYXRXb3JsZDIudywgMS4wKVxcbiAgICApO1xcbiAgI2VsaWYgVVNFX0JBVENISU5HXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGRzW2ludChhX2R5bl9iYXRjaF9pZCldO1xcbiAgI2Vsc2VcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZDtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9URVhUVVJFXFxuICAgIHZfdXYgPSBhX3RleENvb3JkICogdGlsaW5nT2Zmc2V0Lnh5ICsgdGlsaW5nT2Zmc2V0Lnp3O1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX1ZFUlRFWF9DT0xPUlxcbiAgICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcbiAgZmFjdG9yX2ZvZyA9IENDX1RSQU5TRkVSX0ZPRyhtYXRXb3JsZCAqIHBvc2l0aW9uKTtcXG4gIHJldHVybiBjY19tYXRQcm9qICogKGNjX21hdFZpZXcgKiBtYXRXb3JsZCkgKiBwb3NpdGlvbjtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxuI2lmIFVTRV9BTFBIQV9URVNUXFxuI2VuZGlmXFxuI2lmIFVTRV9URVhUVVJFXFxuICBsYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMyIHZfdXY7XFxuICBsYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDIpIHVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbiNlbmRpZlxcbmxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMSkgdW5pZm9ybSBDb25zdGFudCB7XFxuICB2ZWM0IG1haW5Db2xvcjtcXG4gIHZlYzQgY29sb3JTY2FsZUFuZEN1dG9mZjtcXG59O1xcbiNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICBsYXlvdXQobG9jYXRpb24gPSAwKSBpbiBsb3dwIHZlYzQgdl9jb2xvcjtcXG4jZW5kaWZcXG5sYXlvdXQobG9jYXRpb24gPSAyKSBpbiBmbG9hdCBmYWN0b3JfZm9nO1xcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IG8gPSBtYWluQ29sb3I7XFxuICBvLnJnYiAqPSBjb2xvclNjYWxlQW5kQ3V0b2ZmLnh5ejtcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIG8gKj0gdl9jb2xvcjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9URVhUVVJFXFxuICAgIG8gKj0gdGV4dHVyZShtYWluVGV4dHVyZSwgdl91dik7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfQUxQSEFfVEVTVFxcbiAgICBpZiAoby5BTFBIQV9URVNUX0NIQU5ORUwgPCBjb2xvclNjYWxlQW5kQ3V0b2ZmLncpIGRpc2NhcmQ7XFxuICAjZW5kaWZcXG4gIG8gPSB2ZWM0KG1peChDQ19GT1JXQVJEX0FERCA+IDAgPyB2ZWMzKDAuMCkgOiBjY19mb2dDb2xvci5yZ2IsIG8ucmdiLCBmYWN0b3JfZm9nKSwgby5hKTtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQobyk7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnVpbHRpbnNcIjoge1xyXG4gICAgICAgICAgXCJnbG9iYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NHbG9iYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH0sXHJcbiAgICAgICAgICBcImxvY2Fsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDTW9ycGhcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiXSB9LCB7IFwibmFtZVwiOiBcIkNDU2tpbm5pbmdUZXh0dXJlXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTa2lubmluZ0FuaW1hdGlvblwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiXSB9LCB7IFwibmFtZVwiOiBcIkNDU2tpbm5pbmdcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIiFDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NMb2NhbEJhdGNoZWRcIiwgXCJkZWZpbmVzXCI6IFtcIiFVU0VfSU5TVEFOQ0lOR1wiLCBcIlVTRV9CQVRDSElOR1wiXSB9LCB7IFwibmFtZVwiOiBcIkNDTG9jYWxcIiwgXCJkZWZpbmVzXCI6IFtcIiFVU0VfSU5TVEFOQ0lOR1wiLCBcIiFVU0VfQkFUQ0hJTkdcIl0gfV0sIFwic2FtcGxlcnNcIjogW3sgXCJuYW1lXCI6IFwiY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIiwgXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXCJdIH0sIHsgXCJuYW1lXCI6IFwiY2NfTm9ybWFsRGlzcGxhY2VtZW50c1wiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCIsIFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcIl0gfSwgeyBcIm5hbWVcIjogXCJjY19UYW5nZW50RGlzcGxhY2VtZW50c1wiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCIsIFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXCJdIH0sIHsgXCJuYW1lXCI6IFwiY2Nfam9pbnRUZXh0dXJlXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCJdIH1dIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9NT1JQSFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0NPVU5UXCIsIFwidHlwZVwiOiBcIm51bWJlclwiLCBcInJhbmdlXCI6IFsyLCA4XSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1BSRUNPTVBVVEVEXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9JTlNUQU5DSU5HXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfQkFUQ0hJTkdcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9MSUdIVE1BUFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0ZPR1wiLCBcInR5cGVcIjogXCJudW1iZXJcIiwgXCJyYW5nZVwiOiBbMCwgNF0gfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfRk9SV0FSRF9BRERcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9WRVJURVhfQ09MT1JcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9URVhUVVJFXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfSERSXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfQUxQSEFfVEVTVFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQUxQSEFfVEVTVF9DSEFOTkVMXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm9wdGlvbnNcIjogW1wiYVwiLCBcInJcIiwgXCJnXCIsIFwiYlwiXSB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImJsb2Nrc1wiOiBbXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiVGV4Q29vcmRzXCIsIFwiZGVmaW5lc1wiOiBbXCJVU0VfVEVYVFVSRVwiXSwgXCJiaW5kaW5nXCI6IDAsIFwic3RhZ2VGbGFnc1wiOiAxLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInRpbGluZ09mZnNldFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJDb25zdGFudFwiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAxLCBcInN0YWdlRmxhZ3NcIjogMTYsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwibWFpbkNvbG9yXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH0sXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwiY29sb3JTY2FsZUFuZEN1dG9mZlwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJzYW1wbGVyc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIm1haW5UZXh0dXJlXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX1RFWFRVUkVcIl0sIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJiaW5kaW5nXCI6IDIgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX25vcm1hbFwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkXCIsIFwidHlwZVwiOiAxNCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAyMSwgXCJsb2NhdGlvblwiOiAyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGFuZ2VudFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3ZlcnRleElkXCIsIFwidHlwZVwiOiAxMywgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMTEsIFwibG9jYXRpb25cIjogNiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2pvaW50c1wiLCBcInR5cGVcIjogMTIsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQyLCBcImxvY2F0aW9uXCI6IDQgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV93ZWlnaHRzXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogNSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2pvaW50QW5pbUluZm9cIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCIsIFwiVVNFX0lOU1RBTkNJTkdcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDcgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9tYXRXb3JsZDBcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfSU5TVEFOQ0lOR1wiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQ0LCBcImlzSW5zdGFuY2VkXCI6IHRydWUsIFwibG9jYXRpb25cIjogOCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX21hdFdvcmxkMVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9JTlNUQU5DSU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiA5IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbWF0V29ybGQyXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDEwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbGlnaHRpbmdNYXBVVlBhcmFtXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIiwgXCJVU0VfTElHSFRNQVBcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDExIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfZHluX2JhdGNoX2lkXCIsIFwidHlwZVwiOiAxMywgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiVVNFX0JBVENISU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMTEsIFwibG9jYXRpb25cIjogMTIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9jb2xvclwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9WRVJURVhfQ09MT1JcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJsb2NhdGlvblwiOiAxMyB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJwaXBlbGluZS9wbGFuYXItc2hhZG93XCIsXHJcbiAgICBcIl91dWlkXCI6IFwiOTM2MWZkOTAtYmE1Mi00Zjg0LWFhOTMtNmU4NzhmZDU3NmNhXCIsXHJcbiAgICBcInRlY2huaXF1ZXNcIjogW1xyXG4gICAgICB7IFwicGFzc2VzXCI6IFt7IFwicGhhc2VcIjogXCJwbGFuYXJTaGFkb3dcIiwgXCJibGVuZFN0YXRlXCI6IHsgXCJ0YXJnZXRzXCI6IFt7IFwiYmxlbmRcIjogdHJ1ZSwgXCJibGVuZFNyY1wiOiAyLCBcImJsZW5kRHN0XCI6IDQsIFwiYmxlbmREc3RBbHBoYVwiOiA0IH1dIH0sIFwicHJvZ3JhbVwiOiBcInBpcGVsaW5lL3BsYW5hci1zaGFkb3d8cGxhbmFyLXNoYWRvdy12czp2ZXJ0fHBsYW5hci1zaGFkb3ctZnM6ZnJhZ1wiLCBcImRlcHRoU3RlbmNpbFN0YXRlXCI6IHsgXCJkZXB0aFRlc3RcIjogdHJ1ZSwgXCJkZXB0aFdyaXRlXCI6IGZhbHNlLCBcInN0ZW5jaWxUZXN0RnJvbnRcIjogdHJ1ZSwgXCJzdGVuY2lsRnVuY0Zyb250XCI6IDUsIFwic3RlbmNpbFBhc3NPcEZyb250XCI6IDIsIFwic3RlbmNpbFJlZkJhY2tcIjogMTI4LCBcInN0ZW5jaWxSZWZGcm9udFwiOiAxMjgsIFwic3RlbmNpbFJlYWRNYXNrQmFja1wiOiAxMjgsIFwic3RlbmNpbFJlYWRNYXNrRnJvbnRcIjogMTI4LCBcInN0ZW5jaWxXcml0ZU1hc2tCYWNrXCI6IDEyOCwgXCJzdGVuY2lsV3JpdGVNYXNrRnJvbnRcIjogMTI4IH0gfV0gfVxyXG4gICAgXSxcclxuICAgIFwic2hhZGVyc1wiOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBcIm5hbWVcIjogXCJwaXBlbGluZS9wbGFuYXItc2hhZG93fHBsYW5hci1zaGFkb3ctdnM6dmVydHxwbGFuYXItc2hhZG93LWZzOmZyYWdcIixcclxuICAgICAgICBcImhhc2hcIjogODcwNDM2MzE1LFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgcmdiYSA9IHJnYmEgKiAyNTUuMDtcXG4gIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyNy45OSwgcmdiYVszXSkgKiAyLjA7XFxuICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjcuOTkpICsgc3RlcCgxMjguMCwgcmdiYVsyXSkgLSAxMjcuMDtcXG4gIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG59XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmluIHZlYzMgYV9wb3NpdGlvbjtcXG5pbiB2ZWMzIGFfbm9ybWFsO1xcbmluIHZlYzIgYV90ZXhDb29yZDtcXG5pbiB2ZWM0IGFfdGFuZ2VudDtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGludCBnZXRWZXJ0ZXhJZCgpIHtcXG4gICAgICAgIHJldHVybiBnbF9WZXJ0ZXhJRDtcXG4gICAgfVxcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NNb3JwaCB7XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1sxNV07XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm87XFxufTtcXG52ZWMyIGdldFBpeGVsTG9jYXRpb24odmVjMiB0ZXh0dXJlUmVzb2x1dGlvbiwgaW50IHBpeGVsSW5kZXgpIHtcXG4gICAgZmxvYXQgcGl4ZWxJbmRleEYgPSBmbG9hdChwaXhlbEluZGV4KTtcXG4gICAgZmxvYXQgeCA9IG1vZChwaXhlbEluZGV4RiwgdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgIGZsb2F0IHkgPSBmbG9vcihwaXhlbEluZGV4RiAvIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICByZXR1cm4gdmVjMih4LCB5KTtcXG59XFxudmVjMiBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKHZlYzIgbG9jYXRpb24sIHZlYzIgdGV4dHVyZVJlc29sdXRpb24pIHtcXG4gICAgcmV0dXJuICh2ZWMyKGxvY2F0aW9uLngsIGxvY2F0aW9uLnkpICsgLjUpIC8gdGV4dHVyZVJlc29sdXRpb247XFxufVxcbiNpZiBDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICAgICAgICAgIGl2ZWMyIHRleFNpemUgPSB0ZXh0dXJlU2l6ZSh0ZXgsIDApO1xcbiAgICAgICAgICAgIHJldHVybiB0ZXhlbEZldGNoKHRleCwgaXZlYzIocGl4ZWxJbmRleCAlIHRleFNpemUueCwgcGl4ZWxJbmRleCAvIHRleFNpemUueCksIDApO1xcbiAgICAgICAgfVxcbiNlbHNlXFxuICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgZWxlbWVudEluZGV4KSB7XFxuICAgICAgICBpbnQgcGl4ZWxJbmRleCA9IGVsZW1lbnRJbmRleCAqIDQ7XFxuICAgICAgICB2ZWMyIGxvY2F0aW9uID0gZ2V0UGl4ZWxMb2NhdGlvbihjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSwgcGl4ZWxJbmRleCk7XFxuICAgICAgICB2ZWMyIHggPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigwLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHZlYzIgeSA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDEuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB6ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMi4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICByZXR1cm4gdmVjNChcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKHRleCwgeCkpLFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUodGV4LCB5KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZSh0ZXgsIHopKSxcXG4gICAgICAgICAgICAxLjBcXG4gICAgICAgICk7XFxuICAgIH1cXG4jZW5kaWZcXG5mbG9hdCBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaW50IGluZGV4KSB7XFxuICAgIGZsb2F0IG0gPSBtb2QoZmxvYXQoaW5kZXgpLCA0LjApO1xcbiAgICBpZiAobSA8IDEuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS54O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAyLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueTtcXG4gICAgfSBlbHNlIGlmIChtIDwgMy4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLno7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnc7XFxuICAgIH1cXG59XFxudmVjMyBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IHZlcnRleEluZGV4KSB7XFxuI2lmIENDX01PUlBIX1BSRUNPTVBVVEVEXFxuICAgIHJldHVybiBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgdmVydGV4SW5kZXgpLnJnYjtcXG4jZWxzZVxcbiAgICB2ZWMzIHJlc3VsdCA9IHZlYzMoMCwgMCwgMCk7XFxuICAgIGZvciAoaW50IGlUYXJnZXQgPSAwOyBpVGFyZ2V0IDwgQ0NfTU9SUEhfVEFSR0VUX0NPVU5UOyArK2lUYXJnZXQpIHtcXG4gICAgICAgIGludCBkYXRhUGl4ZWxTdGFydCA9IGludChmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgaVRhcmdldCkucik7XFxuICAgICAgICByZXN1bHQgKz0gKGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBkYXRhUGl4ZWxTdGFydCArIHZlcnRleEluZGV4KS5yZ2IgKiBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaVRhcmdldCkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuI2VuZGlmXFxufVxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfVGFuZ2VudERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0VGFuZ2VudERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfVGFuZ2VudERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgICBpbnQgdmVydGV4SWQgPSBnZXRWZXJ0ZXhJZCgpO1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIGF0dHIucG9zaXRpb24ueHl6ID0gYXR0ci5wb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGF0dHIubm9ybWFsLnh5eiA9IGF0dHIubm9ybWFsLnh5eiArIGdldE5vcm1hbERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICBhdHRyLnRhbmdlbnQueHl6ID0gYXR0ci50YW5nZW50Lnh5eiArIGdldFRhbmdlbnREaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbn1cXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBwb3NpdGlvbi54eXogPSBwb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChnZXRWZXJ0ZXhJZCgpKTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9TS0lOTklOR1xcbmluIHZlYzQgYV9qb2ludHM7XFxuaW4gdmVjNCBhX3dlaWdodHM7XFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBpbiBoaWdocCB2ZWM0IGFfam9pbnRBbmltSW5mbztcXG4gICNlbmRpZlxcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ1NraW5uaW5nVGV4dHVyZSB7XFxuICAgIGhpZ2hwIHZlYzQgY2Nfam9pbnRUZXh0dXJlSW5mbztcXG4gIH07XFxuICBsYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDU2tpbm5pbmdBbmltYXRpb24ge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50QW5pbUluZm87XFxuICB9O1xcbiAgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgY2Nfam9pbnRUZXh0dXJlO1xcbiAgI2Vsc2VcXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NTa2lubmluZyB7XFxuICAgIGhpZ2hwIHZlYzQgY2Nfam9pbnRzWzMwICogM107XFxuICB9O1xcbiNlbmRpZlxcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjIgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MyA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjIgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA0LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDYuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA3LjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MyA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDguNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA5LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMS41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgIGludCBpZHggPSBpbnQoaSk7XFxuICAgIHZlYzQgdjEgPSBjY19qb2ludHNbaWR4ICogM107XFxuICAgIHZlYzQgdjIgPSBjY19qb2ludHNbaWR4ICogMyArIDFdO1xcbiAgICB2ZWM0IHYzID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAyXTtcXG4gICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gIH1cXG4jZW5kaWZcXG5tYXQ0IHNraW5NYXRyaXggKCkge1xcbiAgcmV0dXJuIGdldEpvaW50TWF0cml4KGFfam9pbnRzLngpICogYV93ZWlnaHRzLnhcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy55KSAqIGFfd2VpZ2h0cy55XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueikgKiBhX3dlaWdodHMuelxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLncpICogYV93ZWlnaHRzLnc7XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBwb3NpdGlvbiA9IG0gKiBwb3NpdGlvbjtcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIGF0dHIucG9zaXRpb24gPSBtICogYXR0ci5wb3NpdGlvbjtcXG4gIGF0dHIubm9ybWFsID0gKG0gKiB2ZWM0KGF0dHIubm9ybWFsLCAwLjApKS54eXo7XFxuICBhdHRyLnRhbmdlbnQueHl6ID0gKG0gKiB2ZWM0KGF0dHIudGFuZ2VudC54eXosIDAuMCkpLnh5ejtcXG59XFxuI2VuZGlmXFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxuI2lmIFVTRV9JTlNUQU5DSU5HXFxuICBpbiB2ZWM0IGFfbWF0V29ybGQwO1xcbiAgaW4gdmVjNCBhX21hdFdvcmxkMTtcXG4gIGluIHZlYzQgYV9tYXRXb3JsZDI7XFxuICAjaWYgVVNFX0xJR0hUTUFQXFxuICAgIGluIHZlYzQgYV9saWdodGluZ01hcFVWUGFyYW07XFxuICAjZW5kaWZcXG4jZWxpZiBVU0VfQkFUQ0hJTkdcXG4gIGluIGZsb2F0IGFfZHluX2JhdGNoX2lkO1xcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0xvY2FsQmF0Y2hlZCB7XFxuICAgIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRzWzEwXTtcXG4gIH07XFxuI2Vsc2VcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxuI2VuZGlmXFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ1NoYWRvdyB7XFxuICBoaWdocCBtYXQ0IGNjX21hdExpZ2h0UGxhbmVQcm9qO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFZpZXdQcm9qO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd0NvbG9yO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd1BDRjtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dTaXplO1xcbn07XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb247XFxuICBwb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gICNpZiBDQ19VU0VfTU9SUEhcXG4gICAgYXBwbHlNb3JwaChwb3NpdGlvbik7XFxuICAjZW5kaWZcXG4gICNpZiBDQ19VU0VfU0tJTk5JTkdcXG4gICAgQ0NTa2luKHBvc2l0aW9uKTtcXG4gICNlbmRpZlxcbiAgbWF0NCBtYXRXb3JsZDtcXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBtYXRXb3JsZCA9IG1hdDQoXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMS54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMi54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC53LCBhX21hdFdvcmxkMS53LCBhX21hdFdvcmxkMi53LCAxLjApXFxuICAgICk7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAjZWxzZVxcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkO1xcbiAgI2VuZGlmXFxuICBwb3NpdGlvbiA9IGNjX21hdFByb2ogKiAoY2NfbWF0VmlldyAqIGNjX21hdExpZ2h0UGxhbmVQcm9qICogbWF0V29ybGQpICogcG9zaXRpb247XFxuICBwb3NpdGlvbi56IC09IDAuMDAwMTtcXG4gIHJldHVybiBwb3NpdGlvbjtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NTaGFkb3cge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFBsYW5lUHJvajtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0TGlnaHRWaWV3UHJvajtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dDb2xvcjtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dQQ0Y7XFxuICBsb3dwIHZlYzQgY2Nfc2hhZG93U2l6ZTtcXG59O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudmVjNCBmcmFnICgpIHtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY2Nfc2hhZG93Q29sb3IpO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmhpZ2hwIGZsb2F0IGRlY29kZTMyIChoaWdocCB2ZWM0IHJnYmEpIHtcXG4gIHJnYmEgPSByZ2JhICogMjU1LjA7XFxuICBoaWdocCBmbG9hdCBTaWduID0gMS4wIC0gc3RlcCgxMjcuOTksIHJnYmFbM10pICogMi4wO1xcbiAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVszXSwgMTI3Ljk5KSArIHN0ZXAoMTI4LjAsIHJnYmFbMl0pIC0gMTI3LjA7XFxuICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IG1vZChyZ2JhWzJdLCAxMjguMCkgKiA2NTUzNi4wICsgcmdiYVsxXSAqIDI1Ni4wICsgcmdiYVswXSArIDgzODg2MDguMDtcXG4gIHJldHVybiBTaWduICogZXhwMihFeHBvbmVudCAtIDIzLjApICogTWFudGlzc2E7XFxufVxcbnN0cnVjdCBTdGFuZGFyZFZlcnRJbnB1dCB7XFxuICBoaWdocCB2ZWM0IHBvc2l0aW9uO1xcbiAgdmVjMyBub3JtYWw7XFxuICB2ZWM0IHRhbmdlbnQ7XFxufTtcXG5hdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYV90YW5nZW50O1xcbiNpZiBDQ19VU0VfTU9SUEhcXG4gICAgYXR0cmlidXRlIGZsb2F0IGFfdmVydGV4SWQ7XFxuICAgIGludCBnZXRWZXJ0ZXhJZCgpIHtcXG4gICAgICAgIHJldHVybiBpbnQoYV92ZXJ0ZXhJZCk7XFxuICAgIH1cXG51bmlmb3JtIHZlYzQgY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1sxNV07XFxudW5pZm9ybSB2ZWM0IGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvO1xcbnZlYzIgZ2V0UGl4ZWxMb2NhdGlvbih2ZWMyIHRleHR1cmVSZXNvbHV0aW9uLCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICBmbG9hdCBwaXhlbEluZGV4RiA9IGZsb2F0KHBpeGVsSW5kZXgpO1xcbiAgICBmbG9hdCB4ID0gbW9kKHBpeGVsSW5kZXhGLCB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgZmxvYXQgeSA9IGZsb29yKHBpeGVsSW5kZXhGIC8gdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgIHJldHVybiB2ZWMyKHgsIHkpO1xcbn1cXG52ZWMyIGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24odmVjMiBsb2NhdGlvbiwgdmVjMiB0ZXh0dXJlUmVzb2x1dGlvbikge1xcbiAgICByZXR1cm4gKHZlYzIobG9jYXRpb24ueCwgbG9jYXRpb24ueSkgKyAuNSkgLyB0ZXh0dXJlUmVzb2x1dGlvbjtcXG59XFxuI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICAgICAgdmVjNCBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCBlbGVtZW50SW5kZXgpIHtcXG4gICAgICAgICAgICBpbnQgcGl4ZWxJbmRleCA9IGVsZW1lbnRJbmRleDtcXG4gICAgICAgICAgICB2ZWMyIGxvY2F0aW9uID0gZ2V0UGl4ZWxMb2NhdGlvbihjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSwgcGl4ZWxJbmRleCk7XFxuICAgICAgICAgICAgdmVjMiB1diA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24sIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZTJEKHRleCwgdXYpO1xcbiAgICAgICAgfVxcbiNlbHNlXFxuICAgIHZlYzQgZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgZWxlbWVudEluZGV4KSB7XFxuICAgICAgICBpbnQgcGl4ZWxJbmRleCA9IGVsZW1lbnRJbmRleCAqIDQ7XFxuICAgICAgICB2ZWMyIGxvY2F0aW9uID0gZ2V0UGl4ZWxMb2NhdGlvbihjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSwgcGl4ZWxJbmRleCk7XFxuICAgICAgICB2ZWMyIHggPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigwLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHZlYzIgeSA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDEuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB6ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMi4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICByZXR1cm4gdmVjNChcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQodGV4LCB4KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKHRleCwgeSkpLFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUyRCh0ZXgsIHopKSxcXG4gICAgICAgICAgICAxLjBcXG4gICAgICAgICk7XFxuICAgIH1cXG4jZW5kaWZcXG5mbG9hdCBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaW50IGluZGV4KSB7XFxuICAgIGZsb2F0IG0gPSBtb2QoZmxvYXQoaW5kZXgpLCA0LjApO1xcbiAgICBpZiAobSA8IDEuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS54O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAyLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueTtcXG4gICAgfSBlbHNlIGlmIChtIDwgMy4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLno7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnc7XFxuICAgIH1cXG59XFxudmVjMyBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IHZlcnRleEluZGV4KSB7XFxuI2lmIENDX01PUlBIX1BSRUNPTVBVVEVEXFxuICAgIHJldHVybiBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgdmVydGV4SW5kZXgpLnJnYjtcXG4jZWxzZVxcbiAgICB2ZWMzIHJlc3VsdCA9IHZlYzMoMCwgMCwgMCk7XFxuICAgIGZvciAoaW50IGlUYXJnZXQgPSAwOyBpVGFyZ2V0IDwgQ0NfTU9SUEhfVEFSR0VUX0NPVU5UOyArK2lUYXJnZXQpIHtcXG4gICAgICAgIGludCBkYXRhUGl4ZWxTdGFydCA9IGludChmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHRleCwgaVRhcmdldCkucik7XFxuICAgICAgICByZXN1bHQgKz0gKGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBkYXRhUGl4ZWxTdGFydCArIHZlcnRleEluZGV4KS5yZ2IgKiBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaVRhcmdldCkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuI2VuZGlmXFxufVxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfVGFuZ2VudERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0VGFuZ2VudERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfVGFuZ2VudERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgICBpbnQgdmVydGV4SWQgPSBnZXRWZXJ0ZXhJZCgpO1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIGF0dHIucG9zaXRpb24ueHl6ID0gYXR0ci5wb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGF0dHIubm9ybWFsLnh5eiA9IGF0dHIubm9ybWFsLnh5eiArIGdldE5vcm1hbERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICBhdHRyLnRhbmdlbnQueHl6ID0gYXR0ci50YW5nZW50Lnh5eiArIGdldFRhbmdlbnREaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbn1cXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBwb3NpdGlvbi54eXogPSBwb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChnZXRWZXJ0ZXhJZCgpKTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9TS0lOTklOR1xcbmF0dHJpYnV0ZSB2ZWM0IGFfam9pbnRzO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfd2VpZ2h0cztcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIGF0dHJpYnV0ZSBoaWdocCB2ZWM0IGFfam9pbnRBbmltSW5mbztcXG4gICNlbmRpZlxcbiAgdW5pZm9ybSBoaWdocCB2ZWM0IGNjX2pvaW50VGV4dHVyZUluZm87XFxuICB1bmlmb3JtIGhpZ2hwIHZlYzQgY2Nfam9pbnRBbmltSW5mbztcXG4gIHVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGNjX2pvaW50VGV4dHVyZTtcXG4gICNlbHNlXFxuICB1bmlmb3JtIGhpZ2hwIHZlYzQgY2Nfam9pbnRzWzkwXTtcXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjIgPSB0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMS41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYzID0gdGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjIgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDQuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDUuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDYuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDcuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYzID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA4LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA5LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTEuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4jZWxzZVxcbiAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICBpbnQgaWR4ID0gaW50KGkpO1xcbiAgICB2ZWM0IHYxID0gY2Nfam9pbnRzW2lkeCAqIDNdO1xcbiAgICB2ZWM0IHYyID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAxXTtcXG4gICAgdmVjNCB2MyA9IGNjX2pvaW50c1tpZHggKiAzICsgMl07XFxuICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICB9XFxuI2VuZGlmXFxubWF0NCBza2luTWF0cml4ICgpIHtcXG4gIHJldHVybiBnZXRKb2ludE1hdHJpeChhX2pvaW50cy54KSAqIGFfd2VpZ2h0cy54XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueSkgKiBhX3dlaWdodHMueVxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnopICogYV93ZWlnaHRzLnpcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy53KSAqIGFfd2VpZ2h0cy53O1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgcG9zaXRpb24gPSBtICogcG9zaXRpb247XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBhdHRyLnBvc2l0aW9uID0gbSAqIGF0dHIucG9zaXRpb247XFxuICBhdHRyLm5vcm1hbCA9IChtICogdmVjNChhdHRyLm5vcm1hbCwgMC4wKSkueHl6O1xcbiAgYXR0ci50YW5nZW50Lnh5eiA9IChtICogdmVjNChhdHRyLnRhbmdlbnQueHl6LCAwLjApKS54eXo7XFxufVxcbiNlbmRpZlxcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRQcm9qO1xcbiNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgYXR0cmlidXRlIHZlYzQgYV9tYXRXb3JsZDA7XFxuICBhdHRyaWJ1dGUgdmVjNCBhX21hdFdvcmxkMTtcXG4gIGF0dHJpYnV0ZSB2ZWM0IGFfbWF0V29ybGQyO1xcbiAgI2lmIFVTRV9MSUdIVE1BUFxcbiAgICBhdHRyaWJ1dGUgdmVjNCBhX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG4gICNlbmRpZlxcbiNlbGlmIFVTRV9CQVRDSElOR1xcbiAgYXR0cmlidXRlIGZsb2F0IGFfZHluX2JhdGNoX2lkO1xcbiAgdW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFdvcmxkc1sxMF07XFxuI2Vsc2VcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuI2VuZGlmXFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdExpZ2h0UGxhbmVQcm9qO1xcbnZlYzQgdmVydCAoKSB7XFxuICB2ZWM0IHBvc2l0aW9uO1xcbiAgcG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICAjaWYgQ0NfVVNFX01PUlBIXFxuICAgIGFwcGx5TW9ycGgocG9zaXRpb24pO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfVVNFX1NLSU5OSU5HXFxuICAgIENDU2tpbihwb3NpdGlvbik7XFxuICAjZW5kaWZcXG4gIG1hdDQgbWF0V29ybGQ7XFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgbWF0V29ybGQgPSBtYXQ0KFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDEueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDIueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAudywgYV9tYXRXb3JsZDEudywgYV9tYXRXb3JsZDIudywgMS4wKVxcbiAgICApO1xcbiAgI2VsaWYgVVNFX0JBVENISU5HXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGRzW2ludChhX2R5bl9iYXRjaF9pZCldO1xcbiAgI2Vsc2VcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZDtcXG4gICNlbmRpZlxcbiAgcG9zaXRpb24gPSBjY19tYXRQcm9qICogKGNjX21hdFZpZXcgKiBjY19tYXRMaWdodFBsYW5lUHJvaiAqIG1hdFdvcmxkKSAqIHBvc2l0aW9uO1xcbiAgcG9zaXRpb24ueiAtPSAwLjAwMDE7XFxuICByZXR1cm4gcG9zaXRpb247XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIGxvd3AgdmVjNCBjY19zaGFkb3dDb2xvcjtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbnZlYzQgZnJhZyAoKSB7XFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNjX3NoYWRvd0NvbG9yKTtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2w0XCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxuI2lmZGVmIEdMX0VYVF9zaGFkZXJfZXhwbGljaXRfYXJpdGhtZXRpY190eXBlc19pbnQxNlxcbiNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2ludDE2OiBlbmFibGVcXG4jZW5kaWZcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgcmdiYSA9IHJnYmEgKiAyNTUuMDtcXG4gIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyNy45OSwgcmdiYVszXSkgKiAyLjA7XFxuICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjcuOTkpICsgc3RlcCgxMjguMCwgcmdiYVsyXSkgLSAxMjcuMDtcXG4gIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG59XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzMgYV9wb3NpdGlvbjtcXG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMzIGFfbm9ybWFsO1xcbmxheW91dChsb2NhdGlvbiA9IDIpIGluIHZlYzIgYV90ZXhDb29yZDtcXG5sYXlvdXQobG9jYXRpb24gPSAzKSBpbiB2ZWM0IGFfdGFuZ2VudDtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGludCBnZXRWZXJ0ZXhJZCgpIHtcXG4gICAgICAgIHJldHVybiBnbF9WZXJ0ZXhJbmRleDtcXG4gICAgfVxcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gNCkgdW5pZm9ybSBDQ01vcnBoIHtcXG4gICAgdmVjNCBjY19kaXNwbGFjZW1lbnRXZWlnaHRzWzE1XTtcXG4gICAgdmVjNCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mbztcXG59O1xcbnZlYzIgZ2V0UGl4ZWxMb2NhdGlvbih2ZWMyIHRleHR1cmVSZXNvbHV0aW9uLCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICBmbG9hdCBwaXhlbEluZGV4RiA9IGZsb2F0KHBpeGVsSW5kZXgpO1xcbiAgICBmbG9hdCB4ID0gbW9kKHBpeGVsSW5kZXhGLCB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgZmxvYXQgeSA9IGZsb29yKHBpeGVsSW5kZXhGIC8gdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgIHJldHVybiB2ZWMyKHgsIHkpO1xcbn1cXG52ZWMyIGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24odmVjMiBsb2NhdGlvbiwgdmVjMiB0ZXh0dXJlUmVzb2x1dGlvbikge1xcbiAgICByZXR1cm4gKHZlYzIobG9jYXRpb24ueCwgbG9jYXRpb24ueSkgKyAuNSkgLyB0ZXh0dXJlUmVzb2x1dGlvbjtcXG59XFxuI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICAgICAgdmVjNCBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCBwaXhlbEluZGV4KSB7XFxuICAgICAgICAgICAgaXZlYzIgdGV4U2l6ZSA9IHRleHR1cmVTaXplKHRleCwgMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRleGVsRmV0Y2godGV4LCBpdmVjMihwaXhlbEluZGV4ICUgdGV4U2l6ZS54LCBwaXhlbEluZGV4IC8gdGV4U2l6ZS54KSwgMCk7XFxuICAgICAgICB9XFxuI2Vsc2VcXG4gICAgdmVjNCBmZXRjaFZlYzNBcnJheUZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCBlbGVtZW50SW5kZXgpIHtcXG4gICAgICAgIGludCBwaXhlbEluZGV4ID0gZWxlbWVudEluZGV4ICogNDtcXG4gICAgICAgIHZlYzIgbG9jYXRpb24gPSBnZXRQaXhlbExvY2F0aW9uKGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5LCBwaXhlbEluZGV4KTtcXG4gICAgICAgIHZlYzIgeCA9IGdldFBpeGVsQ29vcmRGcm9tTG9jYXRpb24obG9jYXRpb24gKyB2ZWMyKDAuMCwgMC4wKSwgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueHkpO1xcbiAgICAgICAgdmVjMiB5ID0gZ2V0UGl4ZWxDb29yZEZyb21Mb2NhdGlvbihsb2NhdGlvbiArIHZlYzIoMS4wLCAwLjApLCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54eSk7XFxuICAgICAgICB2ZWMyIHogPSBnZXRQaXhlbENvb3JkRnJvbUxvY2F0aW9uKGxvY2F0aW9uICsgdmVjMigyLjAsIDAuMCksIGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnh5KTtcXG4gICAgICAgIHJldHVybiB2ZWM0KFxcbiAgICAgICAgICAgIGRlY29kZTMyKHRleHR1cmUodGV4LCB4KSksXFxuICAgICAgICAgICAgZGVjb2RlMzIodGV4dHVyZSh0ZXgsIHkpKSxcXG4gICAgICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKHRleCwgeikpLFxcbiAgICAgICAgICAgIDEuMFxcbiAgICAgICAgKTtcXG4gICAgfVxcbiNlbmRpZlxcbmZsb2F0IGdldERpc3BsYWNlbWVudFdlaWdodChpbnQgaW5kZXgpIHtcXG4gICAgZmxvYXQgbSA9IG1vZChmbG9hdChpbmRleCksIDQuMCk7XFxuICAgIGlmIChtIDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLng7XFxuICAgIH0gZWxzZSBpZiAobSA8IDIuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS55O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAzLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0uejtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0udztcXG4gICAgfVxcbn1cXG52ZWMzIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgdmVydGV4SW5kZXgpIHtcXG4jaWYgQ0NfTU9SUEhfUFJFQ09NUFVURURcXG4gICAgcmV0dXJuIGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCB2ZXJ0ZXhJbmRleCkucmdiO1xcbiNlbHNlXFxuICAgIHZlYzMgcmVzdWx0ID0gdmVjMygwLCAwLCAwKTtcXG4gICAgZm9yIChpbnQgaVRhcmdldCA9IDA7IGlUYXJnZXQgPCBDQ19NT1JQSF9UQVJHRVRfQ09VTlQ7ICsraVRhcmdldCkge1xcbiAgICAgICAgaW50IGRhdGFQaXhlbFN0YXJ0ID0gaW50KGZldGNoVmVjM0FycmF5RnJvbVRleHR1cmUodGV4LCBpVGFyZ2V0KS5yKTtcXG4gICAgICAgIHJlc3VsdCArPSAoZmV0Y2hWZWMzQXJyYXlGcm9tVGV4dHVyZSh0ZXgsIGRhdGFQaXhlbFN0YXJ0ICsgdmVydGV4SW5kZXgpLnJnYiAqIGdldERpc3BsYWNlbWVudFdlaWdodChpVGFyZ2V0KSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4jZW5kaWZcXG59XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSA2KSB1bmlmb3JtIHNhbXBsZXIyRCBjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gNykgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSA4KSB1bmlmb3JtIHNhbXBsZXIyRCBjY19UYW5nZW50RGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19UYW5nZW50RGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxudm9pZCBhcHBseU1vcnBoIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICAgIGludCB2ZXJ0ZXhJZCA9IGdldFZlcnRleElkKCk7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgYXR0ci5wb3NpdGlvbi54eXogPSBhdHRyLnBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgYXR0ci5ub3JtYWwueHl6ID0gYXR0ci5ub3JtYWwueHl6ICsgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIGF0dHIudGFuZ2VudC54eXogPSBhdHRyLnRhbmdlbnQueHl6ICsgZ2V0VGFuZ2VudERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxufVxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHBvc2l0aW9uLnh5eiA9IHBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGdldFZlcnRleElkKCkpO1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX1NLSU5OSU5HXFxubGF5b3V0KGxvY2F0aW9uID0gNCkgaW4gdTE2dmVjNCBhX2pvaW50cztcXG5sYXlvdXQobG9jYXRpb24gPSA1KSBpbiB2ZWM0IGFfd2VpZ2h0cztcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIGxheW91dChsb2NhdGlvbiA9IDcpIGluIGhpZ2hwIHZlYzQgYV9qb2ludEFuaW1JbmZvO1xcbiAgI2VuZGlmXFxuICBsYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDMpIHVuaWZvcm0gQ0NTa2lubmluZ1RleHR1cmUge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50VGV4dHVyZUluZm87XFxuICB9O1xcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAyKSB1bmlmb3JtIENDU2tpbm5pbmdBbmltYXRpb24ge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50QW5pbUluZm87XFxuICB9O1xcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSA1KSB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBjY19qb2ludFRleHR1cmU7XFxuICAjZWxzZVxcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAzKSB1bmlmb3JtIENDU2tpbm5pbmcge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50c1szMCAqIDNdO1xcbiAgfTtcXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYyID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDMuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYyID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDUuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA2LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjMgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA4LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgOS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTEuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4jZWxzZVxcbiAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICBpbnQgaWR4ID0gaW50KGkpO1xcbiAgICB2ZWM0IHYxID0gY2Nfam9pbnRzW2lkeCAqIDNdO1xcbiAgICB2ZWM0IHYyID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAxXTtcXG4gICAgdmVjNCB2MyA9IGNjX2pvaW50c1tpZHggKiAzICsgMl07XFxuICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICB9XFxuI2VuZGlmXFxubWF0NCBza2luTWF0cml4ICgpIHtcXG4gIHJldHVybiBnZXRKb2ludE1hdHJpeChhX2pvaW50cy54KSAqIGFfd2VpZ2h0cy54XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueSkgKiBhX3dlaWdodHMueVxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnopICogYV93ZWlnaHRzLnpcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy53KSAqIGFfd2VpZ2h0cy53O1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgcG9zaXRpb24gPSBtICogcG9zaXRpb247XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBhdHRyLnBvc2l0aW9uID0gbSAqIGF0dHIucG9zaXRpb247XFxuICBhdHRyLm5vcm1hbCA9IChtICogdmVjNChhdHRyLm5vcm1hbCwgMC4wKSkueHl6O1xcbiAgYXR0ci50YW5nZW50Lnh5eiA9IChtICogdmVjNChhdHRyLnRhbmdlbnQueHl6LCAwLjApKS54eXo7XFxufVxcbiNlbmRpZlxcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxuI2lmIFVTRV9JTlNUQU5DSU5HXFxuICBsYXlvdXQobG9jYXRpb24gPSA4KSBpbiB2ZWM0IGFfbWF0V29ybGQwO1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gOSkgaW4gdmVjNCBhX21hdFdvcmxkMTtcXG4gIGxheW91dChsb2NhdGlvbiA9IDEwKSBpbiB2ZWM0IGFfbWF0V29ybGQyO1xcbiAgI2lmIFVTRV9MSUdIVE1BUFxcbiAgICBsYXlvdXQobG9jYXRpb24gPSAxMSkgaW4gdmVjNCBhX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG4gICNlbmRpZlxcbiNlbGlmIFVTRV9CQVRDSElOR1xcbiAgbGF5b3V0KGxvY2F0aW9uID0gMTIpIGluIGZsb2F0IGFfZHluX2JhdGNoX2lkO1xcbiAgbGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDTG9jYWxCYXRjaGVkIHtcXG4gICAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZHNbMTBdO1xcbiAgfTtcXG4jZWxzZVxcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMCkgdW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbiNlbmRpZlxcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMSkgdW5pZm9ybSBDQ1NoYWRvdyB7XFxuICBoaWdocCBtYXQ0IGNjX21hdExpZ2h0UGxhbmVQcm9qO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFZpZXdQcm9qO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd0NvbG9yO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd1BDRjtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dTaXplO1xcbn07XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb247XFxuICBwb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gICNpZiBDQ19VU0VfTU9SUEhcXG4gICAgYXBwbHlNb3JwaChwb3NpdGlvbik7XFxuICAjZW5kaWZcXG4gICNpZiBDQ19VU0VfU0tJTk5JTkdcXG4gICAgQ0NTa2luKHBvc2l0aW9uKTtcXG4gICNlbmRpZlxcbiAgbWF0NCBtYXRXb3JsZDtcXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBtYXRXb3JsZCA9IG1hdDQoXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMS54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMi54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC53LCBhX21hdFdvcmxkMS53LCBhX21hdFdvcmxkMi53LCAxLjApXFxuICAgICk7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAjZWxzZVxcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkO1xcbiAgI2VuZGlmXFxuICBwb3NpdGlvbiA9IGNjX21hdFByb2ogKiAoY2NfbWF0VmlldyAqIGNjX21hdExpZ2h0UGxhbmVQcm9qICogbWF0V29ybGQpICogcG9zaXRpb247XFxuICBwb3NpdGlvbi56IC09IDAuMDAwMTtcXG4gIHJldHVybiBwb3NpdGlvbjtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMSkgdW5pZm9ybSBDQ1NoYWRvdyB7XFxuICBoaWdocCBtYXQ0IGNjX21hdExpZ2h0UGxhbmVQcm9qO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFZpZXdQcm9qO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd0NvbG9yO1xcbiAgbG93cCB2ZWM0IGNjX3NoYWRvd1BDRjtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dTaXplO1xcbn07XFxubGF5b3V0KHNldCA9IDAsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbnZlYzQgZnJhZyAoKSB7XFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNjX3NoYWRvd0NvbG9yKTtcXG59XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfSwgeyBcIm5hbWVcIjogXCJDQ1NoYWRvd1wiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NNb3JwaFwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTa2lubmluZ1RleHR1cmVcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJDQ1NraW5uaW5nQW5pbWF0aW9uXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTa2lubmluZ1wiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiIUNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJDQ0xvY2FsQmF0Y2hlZFwiLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiVVNFX0JBVENISU5HXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NMb2NhbFwiLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiIVVTRV9CQVRDSElOR1wiXSB9XSwgXCJzYW1wbGVyc1wiOiBbeyBcIm5hbWVcIjogXCJjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHNcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiLCBcIkNDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJjY19Ob3JtYWxEaXNwbGFjZW1lbnRzXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIiwgXCJDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFwiXSB9LCB7IFwibmFtZVwiOiBcImNjX1RhbmdlbnREaXNwbGFjZW1lbnRzXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIiwgXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcIl0gfSwgeyBcIm5hbWVcIjogXCJjY19qb2ludFRleHR1cmVcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfV0gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZpbmVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX01PUlBIXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9UQVJHRVRfQ09VTlRcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzIsIDhdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfUFJFQ09NUFVURURcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9TS0lOTklOR1wiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX0lOU1RBTkNJTkdcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9CQVRDSElOR1wiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX0xJR0hUTUFQXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfSERSXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImJsb2Nrc1wiOiBbXSxcclxuICAgICAgICBcInNhbXBsZXJzXCI6IFtdLFxyXG4gICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcG9zaXRpb25cIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9ub3JtYWxcIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZFwiLCBcInR5cGVcIjogMTQsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMjEsIFwibG9jYXRpb25cIjogMiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RhbmdlbnRcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQ0LCBcImxvY2F0aW9uXCI6IDMgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV92ZXJ0ZXhJZFwiLCBcInR5cGVcIjogMTMsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDExLCBcImxvY2F0aW9uXCI6IDYgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9qb2ludHNcIiwgXCJ0eXBlXCI6IDEyLCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0MiwgXCJsb2NhdGlvblwiOiA0IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfd2VpZ2h0c1wiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQ0LCBcImxvY2F0aW9uXCI6IDUgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9qb2ludEFuaW1JbmZvXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiLCBcIlVTRV9JTlNUQU5DSU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiA3IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbWF0V29ybGQwXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIl0sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiA0NCwgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDggfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9tYXRXb3JsZDFcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfSU5TVEFOQ0lOR1wiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDQ0LCBcImlzSW5zdGFuY2VkXCI6IHRydWUsIFwibG9jYXRpb25cIjogOSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX21hdFdvcmxkMlwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9JTlNUQU5DSU5HXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiAxMCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2xpZ2h0aW5nTWFwVVZQYXJhbVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9JTlNUQU5DSU5HXCIsIFwiVVNFX0xJR0hUTUFQXCJdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiAxMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2R5bl9iYXRjaF9pZFwiLCBcInR5cGVcIjogMTMsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIiFVU0VfSU5TVEFOQ0lOR1wiLCBcIlVTRV9CQVRDSElOR1wiXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDExLCBcImxvY2F0aW9uXCI6IDEyIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcInBpcGVsaW5lL3NreWJveFwiLFxyXG4gICAgXCJfdXVpZFwiOiBcIjUxMWQyNjMzLTA5YTctNGJkZC1hYzQyLWY3NzgwMzIxMjRiM1wiLFxyXG4gICAgXCJ0ZWNobmlxdWVzXCI6IFtcclxuICAgICAgeyBcInBhc3Nlc1wiOiBbeyBcInJhc3Rlcml6ZXJTdGF0ZVwiOiB7IFwiY3VsbE1vZGVcIjogMCB9LCBcInByb2dyYW1cIjogXCJwaXBlbGluZS9za3lib3h8c2t5LXZzOnZlcnR8c2t5LWZzOmZyYWdcIiwgXCJwcmlvcml0eVwiOiAyNDUsIFwiZGVwdGhTdGVuY2lsU3RhdGVcIjogeyBcImRlcHRoVGVzdFwiOiB0cnVlLCBcImRlcHRoV3JpdGVcIjogZmFsc2UgfSB9XSB9XHJcbiAgICBdLFxyXG4gICAgXCJzaGFkZXJzXCI6IFtcclxuICAgICAge1xyXG4gICAgICAgIFwibmFtZVwiOiBcInBpcGVsaW5lL3NreWJveHxza3ktdnM6dmVydHxza3ktZnM6ZnJhZ1wiLFxyXG4gICAgICAgIFwiaGFzaFwiOiA2MjkzNzk0MjAsXHJcbiAgICAgICAgXCJnbHNsM1wiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG5zdHJ1Y3QgU3RhbmRhcmRWZXJ0SW5wdXQge1xcbiAgaGlnaHAgdmVjNCBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjNCB0YW5nZW50O1xcbn07XFxuaW4gdmVjMyBhX3Bvc2l0aW9uO1xcbmluIHZlYzMgYV9ub3JtYWw7XFxuaW4gdmVjMiBhX3RleENvb3JkO1xcbmluIHZlYzQgYV90YW5nZW50O1xcbm91dCBtZWRpdW1wIHZlYzQgdmlld0RpcjtcXG52ZWM0IHZlcnQgKCkge1xcbiAgdmlld0RpciA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gIG1hdDQgbWF0Vmlld1JvdE9ubHkgPSBtYXQ0KG1hdDMoY2NfbWF0VmlldykpO1xcbiAgdmVjNCBwb3MgPSBtYXRWaWV3Um90T25seSAqIHZpZXdEaXI7XFxuICB2ZWMyIGYgPSBjY19tYXRQcm9qWzNdWzNdID4gMC4wID8gdmVjMig0LjgsIDIuNCkgOiB2ZWMyKGNjX21hdFByb2pbMV1bMV0pO1xcbiAgcG9zLnh5ICo9IHZlYzIoY2NfbWF0UHJvalswXVswXSAvIGNjX21hdFByb2pbMV1bMV0gKiBjY19jYW1lcmFQb3MudywgMS4wKSAqIGY7XFxuICBwb3MuencgPSB2ZWMyKC0wLjk5OTk5ICogcG9zLnosIC1wb3Mueik7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxudW5pZm9ybSBzYW1wbGVyQ3ViZSBjY19lbnZpcm9ubWVudDtcXG52ZWMzIHVucGFja1JHQkUgKHZlYzQgcmdiZSkge1xcbiAgcmV0dXJuIHJnYmUucmdiICogcG93KDIuMCwgcmdiZS5hICogMjU1LjAgLSAxMjguMCk7XFxufVxcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjMyBBQ0VTVG9uZU1hcCAodmVjMyBjb2xvcikge1xcbiAgY29sb3IgPSBtaW4oY29sb3IsIHZlYzMoOC4wKSk7XFxuICBjb25zdCBmbG9hdCBBID0gMi41MTtcXG4gIGNvbnN0IGZsb2F0IEIgPSAwLjAzO1xcbiAgY29uc3QgZmxvYXQgQyA9IDIuNDM7XFxuICBjb25zdCBmbG9hdCBEID0gMC41OTtcXG4gIGNvbnN0IGZsb2F0IEUgPSAwLjE0O1xcbiAgcmV0dXJuIChjb2xvciAqIChBICogY29sb3IgKyBCKSkgLyAoY29sb3IgKiAoQyAqIGNvbG9yICsgRCkgKyBFKTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiAhQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBzcXJ0KEFDRVNUb25lTWFwKGNvbG9yLnJnYikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbmluIG1lZGl1bXAgdmVjNCB2aWV3RGlyO1xcbnZlYzQgZnJhZyAoKSB7XFxuICAjaWYgVVNFX1JHQkVfQ1VCRU1BUFxcbiAgICB2ZWMzIGMgPSB1bnBhY2tSR0JFKHRleHR1cmUoY2NfZW52aXJvbm1lbnQsIHZpZXdEaXIueHl6KSk7XFxuICAjZWxzZVxcbiAgICB2ZWMzIGMgPSBTUkdCVG9MaW5lYXIodGV4dHVyZShjY19lbnZpcm9ubWVudCwgdmlld0Rpci54eXopLnJnYik7XFxuICAjZW5kaWZcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQodmVjNChjICogY2NfYW1iaWVudFNreS53LCAxLjApKTtcXG59XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsMVwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0VmlldztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0UHJvajtcXG51bmlmb3JtIGhpZ2hwIHZlYzQgY2NfY2FtZXJhUG9zO1xcbnN0cnVjdCBTdGFuZGFyZFZlcnRJbnB1dCB7XFxuICBoaWdocCB2ZWM0IHBvc2l0aW9uO1xcbiAgdmVjMyBub3JtYWw7XFxuICB2ZWM0IHRhbmdlbnQ7XFxufTtcXG5hdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYV90YW5nZW50O1xcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZpZXdEaXI7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZpZXdEaXIgPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBtYXQ0IG1hdFZpZXdSb3RPbmx5ID0gbWF0NChtYXQzKGNjX21hdFZpZXcpKTtcXG4gIHZlYzQgcG9zID0gbWF0Vmlld1JvdE9ubHkgKiB2aWV3RGlyO1xcbiAgdmVjMiBmID0gY2NfbWF0UHJvalszXVszXSA+IDAuMCA/IHZlYzIoNC44LCAyLjQpIDogdmVjMihjY19tYXRQcm9qWzFdWzFdKTtcXG4gIHBvcy54eSAqPSB2ZWMyKGNjX21hdFByb2pbMF1bMF0gLyBjY19tYXRQcm9qWzFdWzFdICogY2NfY2FtZXJhUG9zLncsIDEuMCkgKiBmO1xcbiAgcG9zLnp3ID0gdmVjMigtMC45OTk5OSAqIHBvcy56LCAtcG9zLnopO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxudW5pZm9ybSBzYW1wbGVyQ3ViZSBjY19lbnZpcm9ubWVudDtcXG52ZWMzIHVucGFja1JHQkUgKHZlYzQgcmdiZSkge1xcbiAgcmV0dXJuIHJnYmUucmdiICogcG93KDIuMCwgcmdiZS5hICogMjU1LjAgLSAxMjguMCk7XFxufVxcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjMyBBQ0VTVG9uZU1hcCAodmVjMyBjb2xvcikge1xcbiAgY29sb3IgPSBtaW4oY29sb3IsIHZlYzMoOC4wKSk7XFxuICBjb25zdCBmbG9hdCBBID0gMi41MTtcXG4gIGNvbnN0IGZsb2F0IEIgPSAwLjAzO1xcbiAgY29uc3QgZmxvYXQgQyA9IDIuNDM7XFxuICBjb25zdCBmbG9hdCBEID0gMC41OTtcXG4gIGNvbnN0IGZsb2F0IEUgPSAwLjE0O1xcbiAgcmV0dXJuIChjb2xvciAqIChBICogY29sb3IgKyBCKSkgLyAoY29sb3IgKiAoQyAqIGNvbG9yICsgRCkgKyBFKTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiAhQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBzcXJ0KEFDRVNUb25lTWFwKGNvbG9yLnJnYikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbnZhcnlpbmcgbWVkaXVtcCB2ZWM0IHZpZXdEaXI7XFxudmVjNCBmcmFnICgpIHtcXG4gICNpZiBVU0VfUkdCRV9DVUJFTUFQXFxuICAgIHZlYzMgYyA9IHVucGFja1JHQkUodGV4dHVyZUN1YmUoY2NfZW52aXJvbm1lbnQsIHZpZXdEaXIueHl6KSk7XFxuICAjZWxzZVxcbiAgICB2ZWMzIGMgPSBTUkdCVG9MaW5lYXIodGV4dHVyZUN1YmUoY2NfZW52aXJvbm1lbnQsIHZpZXdEaXIueHl6KS5yZ2IpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KHZlYzQoYyAqIGNjX2FtYmllbnRTa3kudywgMS4wKSk7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsNFwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbnN0cnVjdCBTdGFuZGFyZFZlcnRJbnB1dCB7XFxuICBoaWdocCB2ZWM0IHBvc2l0aW9uO1xcbiAgdmVjMyBub3JtYWw7XFxuICB2ZWM0IHRhbmdlbnQ7XFxufTtcXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWMzIGFfcG9zaXRpb247XFxubGF5b3V0KGxvY2F0aW9uID0gMSkgaW4gdmVjMyBhX25vcm1hbDtcXG5sYXlvdXQobG9jYXRpb24gPSAyKSBpbiB2ZWMyIGFfdGV4Q29vcmQ7XFxubGF5b3V0KGxvY2F0aW9uID0gMykgaW4gdmVjNCBhX3RhbmdlbnQ7XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IG1lZGl1bXAgdmVjNCB2aWV3RGlyO1xcbnZlYzQgdmVydCAoKSB7XFxuICB2aWV3RGlyID0gdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xcbiAgbWF0NCBtYXRWaWV3Um90T25seSA9IG1hdDQobWF0MyhjY19tYXRWaWV3KSk7XFxuICB2ZWM0IHBvcyA9IG1hdFZpZXdSb3RPbmx5ICogdmlld0RpcjtcXG4gIHZlYzIgZiA9IGNjX21hdFByb2pbM11bM10gPiAwLjAgPyB2ZWMyKDQuOCwgMi40KSA6IHZlYzIoY2NfbWF0UHJvalsxXVsxXSk7XFxuICBwb3MueHkgKj0gdmVjMihjY19tYXRQcm9qWzBdWzBdIC8gY2NfbWF0UHJvalsxXVsxXSAqIGNjX2NhbWVyYVBvcy53LCAxLjApICogZjtcXG4gIHBvcy56dyA9IHZlYzIoLTAuOTk5OTkgKiBwb3MueiwgLXBvcy56KTtcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dCYXNlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0FkZDtcXG59O1xcbmxheW91dChzZXQgPSAwLCBiaW5kaW5nID0gMykgdW5pZm9ybSBzYW1wbGVyQ3ViZSBjY19lbnZpcm9ubWVudDtcXG52ZWMzIHVucGFja1JHQkUgKHZlYzQgcmdiZSkge1xcbiAgcmV0dXJuIHJnYmUucmdiICogcG93KDIuMCwgcmdiZS5hICogMjU1LjAgLSAxMjguMCk7XFxufVxcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjMyBBQ0VTVG9uZU1hcCAodmVjMyBjb2xvcikge1xcbiAgY29sb3IgPSBtaW4oY29sb3IsIHZlYzMoOC4wKSk7XFxuICBjb25zdCBmbG9hdCBBID0gMi41MTtcXG4gIGNvbnN0IGZsb2F0IEIgPSAwLjAzO1xcbiAgY29uc3QgZmxvYXQgQyA9IDIuNDM7XFxuICBjb25zdCBmbG9hdCBEID0gMC41OTtcXG4gIGNvbnN0IGZsb2F0IEUgPSAwLjE0O1xcbiAgcmV0dXJuIChjb2xvciAqIChBICogY29sb3IgKyBCKSkgLyAoY29sb3IgKiAoQyAqIGNvbG9yICsgRCkgKyBFKTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiAhQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBzcXJ0KEFDRVNUb25lTWFwKGNvbG9yLnJnYikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIGluIG1lZGl1bXAgdmVjNCB2aWV3RGlyO1xcbnZlYzQgZnJhZyAoKSB7XFxuICAjaWYgVVNFX1JHQkVfQ1VCRU1BUFxcbiAgICB2ZWMzIGMgPSB1bnBhY2tSR0JFKHRleHR1cmUoY2NfZW52aXJvbm1lbnQsIHZpZXdEaXIueHl6KSk7XFxuICAjZWxzZVxcbiAgICB2ZWMzIGMgPSBTUkdCVG9MaW5lYXIodGV4dHVyZShjY19lbnZpcm9ubWVudCwgdmlld0Rpci54eXopLnJnYik7XFxuICAjZW5kaWZcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQodmVjNChjICogY2NfYW1iaWVudFNreS53LCAxLjApKTtcXG59XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW3sgXCJuYW1lXCI6IFwiY2NfZW52aXJvbm1lbnRcIiwgXCJkZWZpbmVzXCI6IFtdIH1dIH0sXHJcbiAgICAgICAgICBcImxvY2Fsc1wiOiB7IFwiYmxvY2tzXCI6IFtdLCBcInNhbXBsZXJzXCI6IFtdIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9JQkxcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzAsIDJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9SR0JFX0NVQkVNQVBcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW10sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX25vcm1hbFwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkXCIsIFwidHlwZVwiOiAxNCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwic3RhZ2VGbGFnc1wiOiAxLCBcImZvcm1hdFwiOiAyMSwgXCJsb2NhdGlvblwiOiAyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGFuZ2VudFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogMyB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJ1dGlsL3Byb2ZpbGVyXCIsXHJcbiAgICBcIl91dWlkXCI6IFwiODcxYzNiNmMtNzM3OS00MTlkLWJkYTMtNzk0YjIzOWFiOTBkXCIsXHJcbiAgICBcInRlY2huaXF1ZXNcIjogW1xyXG4gICAgICB7IFwicGFzc2VzXCI6IFt7IFwiYmxlbmRTdGF0ZVwiOiB7IFwidGFyZ2V0c1wiOiBbeyBcImJsZW5kXCI6IHRydWUsIFwiYmxlbmRTcmNcIjogMiwgXCJibGVuZERzdFwiOiA0LCBcImJsZW5kRHN0QWxwaGFcIjogNCB9XSB9LCBcInJhc3Rlcml6ZXJTdGF0ZVwiOiB7IFwiY3VsbE1vZGVcIjogMCB9LCBcInByb2dyYW1cIjogXCJ1dGlsL3Byb2ZpbGVyfHByb2ZpbGVyLXZzOnZlcnR8cHJvZmlsZXItZnM6ZnJhZ1wiLCBcImRlcHRoU3RlbmNpbFN0YXRlXCI6IHsgXCJkZXB0aFRlc3RcIjogZmFsc2UsIFwiZGVwdGhXcml0ZVwiOiBmYWxzZSB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwidXRpbC9wcm9maWxlcnxwcm9maWxlci12czp2ZXJ0fHByb2ZpbGVyLWZzOmZyYWdcIixcclxuICAgICAgICBcImhhc2hcIjogNDAyMTM3NjgxOCxcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxuaW4gdmVjMyBhX3Bvc2l0aW9uO1xcbmluIHZlYzQgYV9jb2xvcjtcXG5vdXQgdmVjMiB2X3V2O1xcbmxheW91dChzdGQxNDApIHVuaWZvcm0gQ29uc3RhbnRzIHtcXG4gIHZlYzQgb2Zmc2V0O1xcbn07XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBQZXJGcmFtZUluZm8ge1xcbiAgdmVjNCBkaWdpdHNbOCAqIDEwIC8gNF07XFxufTtcXG5mbG9hdCBnZXRDb21wb25lbnQodmVjNCB2LCBmbG9hdCBpKSB7XFxuICBpZiAoaSA8IDEuMCkgeyByZXR1cm4gdi54OyB9XFxuICBlbHNlIGlmIChpIDwgMi4wKSB7IHJldHVybiB2Lnk7IH1cXG4gIGVsc2UgaWYgKGkgPCAzLjApIHsgcmV0dXJuIHYuejsgfVxcbiAgZWxzZSB7IHJldHVybiB2Lnc7IH1cXG59XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBwb3NpdGlvbi54ICo9IGNjX3NjcmVlblNpemUueSAqIGNjX3NjcmVlblNpemUuejtcXG4gIHBvc2l0aW9uLnh5ICs9IG9mZnNldC54eTtcXG4gIHZfdXYgPSBhX2NvbG9yLnh5O1xcbiAgaWYgKGFfY29sb3IueiA+PSAwLjApIHtcXG4gICAgZmxvYXQgbiA9IGdldENvbXBvbmVudChkaWdpdHNbaW50KGFfY29sb3IueildLCBhX2NvbG9yLncpO1xcbiAgICB2X3V2ICs9IHZlYzIob2Zmc2V0LnogKiBuLCAwLjApO1xcbiAgfVxcbiAgcmV0dXJuIHBvc2l0aW9uO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0NvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2ZvZ0Jhc2U7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQWRkO1xcbn07XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG5pbiB2ZWMyIHZfdXY7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFpblRleHR1cmU7XFxudmVjNCBmcmFnICgpIHtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQodGV4dHVyZShtYWluVGV4dHVyZSwgdl91dikpO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG5hdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfdXY7XFxudW5pZm9ybSB2ZWM0IG9mZnNldDtcXG51bmlmb3JtIHZlYzQgZGlnaXRzWzIwXTtcXG5mbG9hdCBnZXRDb21wb25lbnQodmVjNCB2LCBmbG9hdCBpKSB7XFxuICBpZiAoaSA8IDEuMCkgeyByZXR1cm4gdi54OyB9XFxuICBlbHNlIGlmIChpIDwgMi4wKSB7IHJldHVybiB2Lnk7IH1cXG4gIGVsc2UgaWYgKGkgPCAzLjApIHsgcmV0dXJuIHYuejsgfVxcbiAgZWxzZSB7IHJldHVybiB2Lnc7IH1cXG59XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBwb3NpdGlvbi54ICo9IGNjX3NjcmVlblNpemUueSAqIGNjX3NjcmVlblNpemUuejtcXG4gIHBvc2l0aW9uLnh5ICs9IG9mZnNldC54eTtcXG4gIHZfdXYgPSBhX2NvbG9yLnh5O1xcbiAgaWYgKGFfY29sb3IueiA+PSAwLjApIHtcXG4gICAgZmxvYXQgbiA9IGdldENvbXBvbmVudChkaWdpdHNbaW50KGFfY29sb3IueildLCBhX2NvbG9yLncpO1xcbiAgICB2X3V2ICs9IHZlYzIob2Zmc2V0LnogKiBuLCAwLjApO1xcbiAgfVxcbiAgcmV0dXJuIHBvc2l0aW9uO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG52YXJ5aW5nIHZlYzIgdl91djtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG52ZWM0IGZyYWcgKCkge1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dCh0ZXh0dXJlMkQobWFpblRleHR1cmUsIHZfdXYpKTtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2w0XCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHNldCA9IDAsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWMzIGFfcG9zaXRpb247XFxubGF5b3V0KGxvY2F0aW9uID0gMSkgaW4gdmVjNCBhX2NvbG9yO1xcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWMyIHZfdXY7XFxubGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENvbnN0YW50cyB7XFxuICB2ZWM0IG9mZnNldDtcXG59O1xcbmxheW91dChzZXQgPSAxLCBiaW5kaW5nID0gMSkgdW5pZm9ybSBQZXJGcmFtZUluZm8ge1xcbiAgdmVjNCBkaWdpdHNbOCAqIDEwIC8gNF07XFxufTtcXG5mbG9hdCBnZXRDb21wb25lbnQodmVjNCB2LCBmbG9hdCBpKSB7XFxuICBpZiAoaSA8IDEuMCkgeyByZXR1cm4gdi54OyB9XFxuICBlbHNlIGlmIChpIDwgMi4wKSB7IHJldHVybiB2Lnk7IH1cXG4gIGVsc2UgaWYgKGkgPCAzLjApIHsgcmV0dXJuIHYuejsgfVxcbiAgZWxzZSB7IHJldHVybiB2Lnc7IH1cXG59XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBwb3NpdGlvbi54ICo9IGNjX3NjcmVlblNpemUueSAqIGNjX3NjcmVlblNpemUuejtcXG4gIHBvc2l0aW9uLnh5ICs9IG9mZnNldC54eTtcXG4gIHZfdXYgPSBhX2NvbG9yLnh5O1xcbiAgaWYgKGFfY29sb3IueiA+PSAwLjApIHtcXG4gICAgZmxvYXQgbiA9IGdldENvbXBvbmVudChkaWdpdHNbaW50KGFfY29sb3IueildLCBhX2NvbG9yLncpO1xcbiAgICB2X3V2ICs9IHZlYzIob2Zmc2V0LnogKiBuLCAwLjApO1xcbiAgfVxcbiAgcmV0dXJuIHBvc2l0aW9uO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KHNldCA9IDAsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQ29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfZm9nQmFzZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19mb2dBZGQ7XFxufTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzIgdl91djtcXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDIpIHVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbnZlYzQgZnJhZyAoKSB7XFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KHRleHR1cmUobWFpblRleHR1cmUsIHZfdXYpKTtcXG59XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW10sIFwic2FtcGxlcnNcIjogW10gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZpbmVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0hEUlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJibG9ja3NcIjogW1xyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkNvbnN0YW50c1wiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAwLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJvZmZzZXRcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX0sXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiUGVyRnJhbWVJbmZvXCIsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDEsIFwic3RhZ2VGbGFnc1wiOiAxLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcImRpZ2l0c1wiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMjAgfVxyXG4gICAgICAgICAgXX1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGV4dHVyZVwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMTYsIFwiYmluZGluZ1wiOiAyIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcG9zaXRpb25cIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9jb2xvclwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogNDQsIFwibG9jYXRpb25cIjogMSB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJ1dGlsL3NwbGFzaC1zY3JlZW5cIixcclxuICAgIFwiX3V1aWRcIjogXCI5NzBiMDU5OC1iY2IwLTQ3MTQtOTFmYi0yZTgxNDQwZGNjZDhcIixcclxuICAgIFwidGVjaG5pcXVlc1wiOiBbXHJcbiAgICAgIHsgXCJwYXNzZXNcIjogW3sgXCJibGVuZFN0YXRlXCI6IHsgXCJ0YXJnZXRzXCI6IFt7IFwiYmxlbmRcIjogdHJ1ZSwgXCJibGVuZFNyY1wiOiAyLCBcImJsZW5kRHN0XCI6IDQsIFwiYmxlbmREc3RBbHBoYVwiOiA0IH1dIH0sIFwicmFzdGVyaXplclN0YXRlXCI6IHsgXCJjdWxsTW9kZVwiOiAwIH0sIFwicHJvZ3JhbVwiOiBcInV0aWwvc3BsYXNoLXNjcmVlbnxzcGxhc2gtc2NyZWVuLXZzOnZlcnR8c3BsYXNoLXNjcmVlbi1mczpmcmFnXCIsIFwiZGVwdGhTdGVuY2lsU3RhdGVcIjogeyBcImRlcHRoVGVzdFwiOiBmYWxzZSwgXCJkZXB0aFdyaXRlXCI6IGZhbHNlIH0gfV0gfVxyXG4gICAgXSxcclxuICAgIFwic2hhZGVyc1wiOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBcIm5hbWVcIjogXCJ1dGlsL3NwbGFzaC1zY3JlZW58c3BsYXNoLXNjcmVlbi12czp2ZXJ0fHNwbGFzaC1zY3JlZW4tZnM6ZnJhZ1wiLFxyXG4gICAgICAgIFwiaGFzaFwiOiAyMTA2OTAxMDUzLFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5pbiB2ZWMyIGFfcG9zaXRpb247XFxuaW4gdmVjMiBhX3RleENvb3JkO1xcbm91dCB2ZWMyIHZfdXY7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAwLCAxKTtcXG4gIHZfdXYgPSBhX3RleENvb3JkO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmluIHZlYzIgdl91djtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIHNwbGFzaEZyYWcge1xcbiAgZmxvYXQgdV9wcmVjZW50O1xcbn07XFxudmVjNCBmcmFnICgpIHtcXG4gIHZlYzQgY29sb3IgPSB0ZXh0dXJlKG1haW5UZXh0dXJlLCB2X3V2KTtcXG4gIGZsb2F0IHByZWNlbnQgPSBjbGFtcCh1X3ByZWNlbnQsIDAuMCwgMS4wKTtcXG4gIGNvbG9yLnh5eiAqPSBwcmVjZW50O1xcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnZlYzQgdmVydCAoKSB7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbiwgMCwgMSk7XFxuICB2X3V2ID0gYV90ZXhDb29yZDtcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzIgdl91djtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IHVfcHJlY2VudDtcXG52ZWM0IGZyYWcgKCkge1xcbiAgdmVjNCBjb2xvciA9IHRleHR1cmUyRChtYWluVGV4dHVyZSwgdl91dik7XFxuICBmbG9hdCBwcmVjZW50ID0gY2xhbXAodV9wcmVjZW50LCAwLjAsIDEuMCk7XFxuICBjb2xvci54eXogKj0gcHJlY2VudDtcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2w0XCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMiBhX3Bvc2l0aW9uO1xcbmxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzIgYV90ZXhDb29yZDtcXG5sYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjMiB2X3V2O1xcbnZlYzQgdmVydCAoKSB7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbiwgMCwgMSk7XFxuICB2X3V2ID0gYV90ZXhDb29yZDtcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWMyIHZfdXY7XFxubGF5b3V0KHNldCA9IDEsIGJpbmRpbmcgPSAxKSB1bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDApIHVuaWZvcm0gc3BsYXNoRnJhZyB7XFxuICBmbG9hdCB1X3ByZWNlbnQ7XFxufTtcXG52ZWM0IGZyYWcgKCkge1xcbiAgdmVjNCBjb2xvciA9IHRleHR1cmUobWFpblRleHR1cmUsIHZfdXYpO1xcbiAgZmxvYXQgcHJlY2VudCA9IGNsYW1wKHVfcHJlY2VudCwgMC4wLCAxLjApO1xcbiAgY29sb3IueHl6ICo9IHByZWNlbnQ7XFxuICByZXR1cm4gY29sb3I7XFxufVxcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnVpbHRpbnNcIjoge1xyXG4gICAgICAgICAgXCJnbG9iYWxzXCI6IHsgXCJibG9ja3NcIjogW10sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW10sIFwic2FtcGxlcnNcIjogW10gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZpbmVzXCI6IFtdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJzcGxhc2hGcmFnXCIsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDAsIFwic3RhZ2VGbGFnc1wiOiAxNiwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ1X3ByZWNlbnRcIiwgXCJ0eXBlXCI6IDEzLCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGV4dHVyZVwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMTYsIFwiYmluZGluZ1wiOiAxIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcG9zaXRpb25cIiwgXCJ0eXBlXCI6IDE0LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJzdGFnZUZsYWdzXCI6IDEsIFwiZm9ybWF0XCI6IDIxLCBcImxvY2F0aW9uXCI6IDAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZFwiLCBcInR5cGVcIjogMTQsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcInN0YWdlRmxhZ3NcIjogMSwgXCJmb3JtYXRcIjogMjEsIFwibG9jYXRpb25cIjogMSB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfVxyXG5dO1xyXG4iXX0=