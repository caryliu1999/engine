(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "./js.js", "../default-constants.js", "../global-exports.js", "../platform/debug.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("./js.js"), require("../default-constants.js"), require("../global-exports.js"), require("../platform/debug.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.js, global.defaultConstants, global.globalExports, global.debug);
    global.misc = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _js, _defaultConstants, _globalExports, _debug) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.propertyDefine = propertyDefine;
  _exports.pushToMap = pushToMap;
  _exports.contains = contains;
  _exports.isDomNode = isDomNode;
  _exports.callInNextTick = callInNextTick;
  _exports.tryCatchFunctor_EDITOR = tryCatchFunctor_EDITOR;
  _exports.isPlainEmptyObj_DEV = isPlainEmptyObj_DEV;
  _exports.cloneable_DEV = cloneable_DEV;
  _exports.BASE64_VALUES = _exports.BUILTIN_CLASSID_RE = void 0;

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  var BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
  _exports.BUILTIN_CLASSID_RE = BUILTIN_CLASSID_RE;
  var BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  var values = new Array(123); // max char code in base64Keys

  for (var i = 0; i < 123; ++i) {
    values[i] = 64;
  } // fill with placeholder('=') index


  for (var _i = 0; _i < 64; ++_i) {
    values[BASE64_KEYS.charCodeAt(_i)] = _i;
  } // decoded value indexed by base64 char code


  var BASE64_VALUES = values;
  /**
   * misc utilities
   * @class misc
   * @static
   */

  /**
   * @method propertyDefine
   * @param {Function} ctor
   * @param {Array} sameNameGetSets
   * @param {Object} diffNameGetSets
   */

  _exports.BASE64_VALUES = BASE64_VALUES;

  function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
    function define(np, propName, getter, setter) {
      var pd = Object.getOwnPropertyDescriptor(np, propName);

      if (pd) {
        if (pd.get) {
          np[getter] = pd.get;
        }

        if (pd.set && setter) {
          np[setter] = pd.set;
        }
      } else {
        var getterFunc = np[getter];

        if (_defaultConstants.DEV && !getterFunc) {
          var clsName = _globalExports.legacyCC.Class._isCCClass(ctor) && (0, _js.getClassName)(ctor) || ctor.name || '(anonymous class)';
          (0, _debug.warnID)(5700, propName, getter, clsName);
        } else {
          (0, _js.getset)(np, propName, getterFunc, np[setter]);
        }
      }
    }

    var propName,
        np = ctor.prototype;

    for (var _i2 = 0; _i2 < sameNameGetSets.length; _i2++) {
      propName = sameNameGetSets[_i2];
      var suffix = propName[0].toUpperCase() + propName.slice(1);
      define(np, propName, 'get' + suffix, 'set' + suffix);
    }

    for (propName in diffNameGetSets) {
      var gs = diffNameGetSets[propName];
      define(np, propName, gs[0], gs[1]);
    }
  } // set value to map, if key exists, push to array


  function pushToMap(map, key, value, pushFront) {
    var exists = map[key];

    if (exists) {
      if (Array.isArray(exists)) {
        if (pushFront) {
          exists.push(exists[0]);
          exists[0] = value;
        } else {
          exists.push(value);
        }
      } else {
        map[key] = pushFront ? [value, exists] : [exists, value];
      }
    } else {
      map[key] = value;
    }
  }

  function contains(refNode, otherNode) {
    if (typeof refNode.contains === 'function') {
      return refNode.contains(otherNode);
    } else if (typeof refNode.compareDocumentPosition === 'function') {
      return !!(refNode.compareDocumentPosition(otherNode) & 16);
    } else {
      var node = otherNode.parentNode;

      if (node) {
        do {
          if (node === refNode) {
            return true;
          } else {
            node = node.parentNode;
          }
        } while (node !== null);
      }

      return false;
    }
  }

  function isDomNode(obj) {
    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && typeof Node === 'function') {
      // If "TypeError: Right-hand side of 'instanceof' is not callback" is thrown,
      // it should because window.Node was overwritten.
      return obj instanceof Node;
    } else {
      return obj && _typeof(obj) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
    }
  }

  function callInNextTick(callback, p1, p2) {
    if (_defaultConstants.EDITOR) {
      if (callback) {
        // @ts-ignore
        process.nextTick(function () {
          callback(p1, p2);
        });
      }
    } else {
      if (callback) {
        setTimeout(function () {
          callback(p1, p2);
        }, 0);
      }
    }
  } // use anonymous function here to ensure it will not being hoisted without EDITOR


  function tryCatchFunctor_EDITOR(funcName) {
    return Function('target', 'try {\n' + '  target.' + funcName + '();\n' + '}\n' + 'catch (e) {\n' + '  cc._throw(e);\n' + '}');
  }

  function isPlainEmptyObj_DEV(obj) {
    if (!obj || obj.constructor !== Object) {
      return false;
    } // jshint ignore: start


    for (var k in obj) {
      return false;
    } // jshint ignore: end


    return true;
  }

  function cloneable_DEV(obj) {
    return obj && typeof obj.clone === 'function' && (obj.constructor && obj.constructor.prototype.hasOwnProperty('clone') || obj.hasOwnProperty('clone'));
  } // if (TEST) {
  //     // editor mocks using in unit tests
  //     if (typeof Editor === 'undefined') {
  //         window.Editor = {
  //             UuidUtils: {
  //                 NonUuidMark: '.',
  //                 uuid () {
  //                     return '' + ((new Date()).getTime() + Math.random());
  //                 },
  //             },
  //         };
  //     }
  // }


  _globalExports.legacyCC.misc = {
    BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
    BASE64_VALUES: BASE64_VALUES,
    propertyDefine: propertyDefine,
    pushToMap: pushToMap,
    contains: contains,
    isDomNode: isDomNode,
    callInNextTick: callInNextTick,
    tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
    isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
    cloneable_DEV: cloneable_DEV
  };
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImU6L2QwMDQ1MjUyMC9HaXRodWIvZW5naW5lL2NvY29zL2NvcmUvdXRpbHMvbWlzYy50cyJdLCJuYW1lcyI6WyJCVUlMVElOX0NMQVNTSURfUkUiLCJCQVNFNjRfS0VZUyIsInZhbHVlcyIsIkFycmF5IiwiaSIsImNoYXJDb2RlQXQiLCJCQVNFNjRfVkFMVUVTIiwicHJvcGVydHlEZWZpbmUiLCJjdG9yIiwic2FtZU5hbWVHZXRTZXRzIiwiZGlmZk5hbWVHZXRTZXRzIiwiZGVmaW5lIiwibnAiLCJwcm9wTmFtZSIsImdldHRlciIsInNldHRlciIsInBkIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwic2V0IiwiZ2V0dGVyRnVuYyIsIkRFViIsImNsc05hbWUiLCJsZWdhY3lDQyIsIkNsYXNzIiwiX2lzQ0NDbGFzcyIsIm5hbWUiLCJwcm90b3R5cGUiLCJsZW5ndGgiLCJzdWZmaXgiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiZ3MiLCJwdXNoVG9NYXAiLCJtYXAiLCJrZXkiLCJ2YWx1ZSIsInB1c2hGcm9udCIsImV4aXN0cyIsImlzQXJyYXkiLCJwdXNoIiwiY29udGFpbnMiLCJyZWZOb2RlIiwib3RoZXJOb2RlIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJub2RlIiwicGFyZW50Tm9kZSIsImlzRG9tTm9kZSIsIm9iaiIsIndpbmRvdyIsIk5vZGUiLCJub2RlVHlwZSIsIm5vZGVOYW1lIiwiY2FsbEluTmV4dFRpY2siLCJjYWxsYmFjayIsInAxIiwicDIiLCJFRElUT1IiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJzZXRUaW1lb3V0IiwidHJ5Q2F0Y2hGdW5jdG9yX0VESVRPUiIsImZ1bmNOYW1lIiwiRnVuY3Rpb24iLCJpc1BsYWluRW1wdHlPYmpfREVWIiwiY29uc3RydWN0b3IiLCJrIiwiY2xvbmVhYmxlX0RFViIsImNsb25lIiwiaGFzT3duUHJvcGVydHkiLCJtaXNjIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7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QUFRLEVBQVJBLFFBTFk7QUFNWk0sSUFBQUEsU0FBUyxFQUFUQSxTQU5ZO0FBT1pNLElBQUFBLGNBQWMsRUFBZEEsY0FQWTtBQVFaUSxJQUFBQSxzQkFBc0IsRUFBdEJBLHNCQVJZO0FBU1pHLElBQUFBLG1CQUFtQixFQUFuQkEsbUJBVFk7QUFVWkcsSUFBQUEsYUFBYSxFQUFiQTtBQVZZLEdBQWhCIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuIENvcHlyaWdodCAoYykgMjAxMy0yMDE2IENodWtvbmcgVGVjaG5vbG9naWVzIEluYy5cclxuIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLlxyXG5cclxuIGh0dHA6Ly93d3cuY29jb3MuY29tXHJcblxyXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBlbmdpbmUgc291cmNlIGNvZGUgKHRoZSBcIlNvZnR3YXJlXCIpLCBhIGxpbWl0ZWQsXHJcbiAgd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxyXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcclxuICBub3QgdXNlIENvY29zIENyZWF0b3Igc29mdHdhcmUgZm9yIGRldmVsb3Bpbmcgb3RoZXIgc29mdHdhcmUgb3IgdG9vbHMgdGhhdCdzXHJcbiAgdXNlZCBmb3IgZGV2ZWxvcGluZyBnYW1lcy4gWW91IGFyZSBub3QgZ3JhbnRlZCB0byBwdWJsaXNoLCBkaXN0cmlidXRlLFxyXG4gIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxyXG5cclxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXHJcbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxyXG5cclxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gVEhFIFNPRlRXQVJFLlxyXG4qL1xyXG5cclxuIC8vIHRzbGludDpkaXNhYmxlXHJcblxyXG5pbXBvcnQgeyBnZXRDbGFzc05hbWUsIGdldHNldCB9IGZyb20gJy4vanMnO1xyXG5pbXBvcnQgeyBFRElUT1IsIERFViB9IGZyb20gJ2ludGVybmFsOmNvbnN0YW50cyc7XHJcbmltcG9ydCB7IGxlZ2FjeUNDIH0gZnJvbSAnLi4vZ2xvYmFsLWV4cG9ydHMnO1xyXG5pbXBvcnQgeyB3YXJuSUQgfSBmcm9tICcuLi9wbGF0Zm9ybS9kZWJ1Zyc7XHJcblxyXG5leHBvcnQgY29uc3QgQlVJTFRJTl9DTEFTU0lEX1JFID0gL14oPzpjY3xkcmFnb25Cb25lc3xzcHxjY3NnKVxcLi4rLztcclxuXHJcbmNvbnN0IEJBU0U2NF9LRVlTID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcclxuY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KDEyMyk7IC8vIG1heCBjaGFyIGNvZGUgaW4gYmFzZTY0S2V5c1xyXG5mb3IgKGxldCBpID0gMDsgaSA8IDEyMzsgKytpKSB7IHZhbHVlc1tpXSA9IDY0OyB9IC8vIGZpbGwgd2l0aCBwbGFjZWhvbGRlcignPScpIGluZGV4XHJcbmZvciAobGV0IGkgPSAwOyBpIDwgNjQ7ICsraSkgeyB2YWx1ZXNbQkFTRTY0X0tFWVMuY2hhckNvZGVBdChpKV0gPSBpOyB9XHJcblxyXG4vLyBkZWNvZGVkIHZhbHVlIGluZGV4ZWQgYnkgYmFzZTY0IGNoYXIgY29kZVxyXG5leHBvcnQgY29uc3QgQkFTRTY0X1ZBTFVFUyA9IHZhbHVlcztcclxuXHJcbi8qKlxyXG4gKiBtaXNjIHV0aWxpdGllc1xyXG4gKiBAY2xhc3MgbWlzY1xyXG4gKiBAc3RhdGljXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgcHJvcGVydHlEZWZpbmVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3RvclxyXG4gKiBAcGFyYW0ge0FycmF5fSBzYW1lTmFtZUdldFNldHNcclxuICogQHBhcmFtIHtPYmplY3R9IGRpZmZOYW1lR2V0U2V0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5RGVmaW5lIChjdG9yLCBzYW1lTmFtZUdldFNldHMsIGRpZmZOYW1lR2V0U2V0cykge1xyXG4gICAgZnVuY3Rpb24gZGVmaW5lIChucCwgcHJvcE5hbWUsIGdldHRlciwgc2V0dGVyKSB7XHJcbiAgICAgICAgY29uc3QgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5wLCBwcm9wTmFtZSk7XHJcbiAgICAgICAgaWYgKHBkKSB7XHJcbiAgICAgICAgICAgIGlmIChwZC5nZXQpIHsgbnBbZ2V0dGVyXSA9IHBkLmdldDsgfVxyXG4gICAgICAgICAgICBpZiAocGQuc2V0ICYmIHNldHRlcikgeyBucFtzZXR0ZXJdID0gcGQuc2V0OyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBnZXR0ZXJGdW5jID0gbnBbZ2V0dGVyXTtcclxuICAgICAgICAgICAgaWYgKERFViAmJiAhZ2V0dGVyRnVuYykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xzTmFtZSA9IChsZWdhY3lDQy5DbGFzcy5faXNDQ0NsYXNzKGN0b3IpICYmIGdldENsYXNzTmFtZShjdG9yKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBjdG9yLm5hbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAnKGFub255bW91cyBjbGFzcyknO1xyXG4gICAgICAgICAgICAgICAgd2FybklEKDU3MDAsIHByb3BOYW1lLCBnZXR0ZXIsIGNsc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2V0c2V0KG5wLCBwcm9wTmFtZSwgZ2V0dGVyRnVuYywgbnBbc2V0dGVyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgcHJvcE5hbWUsIG5wID0gY3Rvci5wcm90b3R5cGU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbWVOYW1lR2V0U2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHByb3BOYW1lID0gc2FtZU5hbWVHZXRTZXRzW2ldO1xyXG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IHByb3BOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wTmFtZS5zbGljZSgxKTtcclxuICAgICAgICBkZWZpbmUobnAsIHByb3BOYW1lLCAnZ2V0JyArIHN1ZmZpeCwgJ3NldCcgKyBzdWZmaXgpO1xyXG4gICAgfVxyXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkaWZmTmFtZUdldFNldHMpIHtcclxuICAgICAgICBjb25zdCBncyA9IGRpZmZOYW1lR2V0U2V0c1twcm9wTmFtZV07XHJcbiAgICAgICAgZGVmaW5lKG5wLCBwcm9wTmFtZSwgZ3NbMF0sIGdzWzFdKTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gc2V0IHZhbHVlIHRvIG1hcCwgaWYga2V5IGV4aXN0cywgcHVzaCB0byBhcnJheVxyXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRvTWFwIChtYXAsIGtleSwgdmFsdWUsIHB1c2hGcm9udCkge1xyXG4gICAgY29uc3QgZXhpc3RzID0gbWFwW2tleV07XHJcbiAgICBpZiAoZXhpc3RzKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RzKSkge1xyXG4gICAgICAgICAgICBpZiAocHVzaEZyb250KSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdHMucHVzaChleGlzdHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgZXhpc3RzWzBdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcFtrZXldID0gKHB1c2hGcm9udCA/IFt2YWx1ZSwgZXhpc3RzXSA6IFtleGlzdHMsIHZhbHVlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbWFwW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zIChyZWZOb2RlLCBvdGhlck5vZGUpIHtcclxuICAgIGlmICh0eXBlb2YgcmVmTm9kZS5jb250YWlucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiByZWZOb2RlLmNvbnRhaW5zKG90aGVyTm9kZSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWZOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHJlZk5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKSAmIDE2KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBvdGhlck5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gcmVmTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNEb21Ob2RlIChvYmopIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIElmIFwiVHlwZUVycm9yOiBSaWdodC1oYW5kIHNpZGUgb2YgJ2luc3RhbmNlb2YnIGlzIG5vdCBjYWxsYmFja1wiIGlzIHRocm93bixcclxuICAgICAgICAvLyBpdCBzaG91bGQgYmVjYXVzZSB3aW5kb3cuTm9kZSB3YXMgb3ZlcndyaXR0ZW4uXHJcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE5vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gb2JqICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBvYmoubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsbEluTmV4dFRpY2sgKGNhbGxiYWNrLCBwMT86IGFueSwgcDI/OiBhbnkpIHtcclxuICAgIGlmIChFRElUT1IpIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHAxLCBwMik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHAxLCBwMik7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLy8gdXNlIGFub255bW91cyBmdW5jdGlvbiBoZXJlIHRvIGVuc3VyZSBpdCB3aWxsIG5vdCBiZWluZyBob2lzdGVkIHdpdGhvdXQgRURJVE9SXHJcbmV4cG9ydCBmdW5jdGlvbiB0cnlDYXRjaEZ1bmN0b3JfRURJVE9SIChmdW5jTmFtZSkge1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCd0YXJnZXQnLFxyXG4gICAgICAgICd0cnkge1xcbicgK1xyXG4gICAgICAgICcgIHRhcmdldC4nICsgZnVuY05hbWUgKyAnKCk7XFxuJyArXHJcbiAgICAgICAgJ31cXG4nICtcclxuICAgICAgICAnY2F0Y2ggKGUpIHtcXG4nICtcclxuICAgICAgICAnICBjYy5fdGhyb3coZSk7XFxuJyArXHJcbiAgICAgICAgJ30nKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5FbXB0eU9ial9ERVYgKG9iaikge1xyXG4gICAgaWYgKCFvYmogfHwgb2JqLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBqc2hpbnQgaWdub3JlOiBzdGFydFxyXG4gICAgZm9yIChjb25zdCBrIGluIG9iaikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIGpzaGludCBpZ25vcmU6IGVuZFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZWFibGVfREVWIChvYmopIHtcclxuICAgIHJldHVybiBvYmogJiZcclxuICAgICAgICB0eXBlb2Ygb2JqLmNsb25lID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgKChvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnY2xvbmUnKSkgfHwgb2JqLmhhc093blByb3BlcnR5KCdjbG9uZScpKTtcclxufVxyXG5cclxuLy8gaWYgKFRFU1QpIHtcclxuLy8gICAgIC8vIGVkaXRvciBtb2NrcyB1c2luZyBpbiB1bml0IHRlc3RzXHJcbi8vICAgICBpZiAodHlwZW9mIEVkaXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuLy8gICAgICAgICB3aW5kb3cuRWRpdG9yID0ge1xyXG4vLyAgICAgICAgICAgICBVdWlkVXRpbHM6IHtcclxuLy8gICAgICAgICAgICAgICAgIE5vblV1aWRNYXJrOiAnLicsXHJcbi8vICAgICAgICAgICAgICAgICB1dWlkICgpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycgKyAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIE1hdGgucmFuZG9tKCkpO1xyXG4vLyAgICAgICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgfVxyXG4vLyB9XHJcblxyXG5sZWdhY3lDQy5taXNjID0ge1xyXG4gICAgQlVJTFRJTl9DTEFTU0lEX1JFLFxyXG4gICAgQkFTRTY0X1ZBTFVFUyxcclxuICAgIHByb3BlcnR5RGVmaW5lLFxyXG4gICAgcHVzaFRvTWFwLFxyXG4gICAgY29udGFpbnMsXHJcbiAgICBpc0RvbU5vZGUsXHJcbiAgICBjYWxsSW5OZXh0VGljayxcclxuICAgIHRyeUNhdGNoRnVuY3Rvcl9FRElUT1IsXHJcbiAgICBpc1BsYWluRW1wdHlPYmpfREVWLFxyXG4gICAgY2xvbmVhYmxlX0RFVixcclxufTtcclxuIl19