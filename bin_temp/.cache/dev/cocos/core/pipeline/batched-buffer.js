(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../gfx/index.js", "../gfx/buffer.js", "../gfx/input-assembler.js", "../math/index.js", "./define.js", "../renderer/core/memory-pools.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../gfx/index.js"), require("../gfx/buffer.js"), require("../gfx/input-assembler.js"), require("../math/index.js"), require("./define.js"), require("../renderer/core/memory-pools.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.index, global.buffer, global.inputAssembler, global.index, global.define, global.memoryPools);
    global.batchedBuffer = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _index, _buffer, _inputAssembler, _index2, _define, _memoryPools) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.BatchedBuffer = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var BatchedBuffer = /*#__PURE__*/function () {
    _createClass(BatchedBuffer, null, [{
      key: "get",
      value: function get(pass) {
        var extraKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var buffers = BatchedBuffer._buffers;
        if (!buffers.has(pass)) buffers.set(pass, {});
        var record = buffers.get(pass);
        return record[extraKey] || (record[extraKey] = new BatchedBuffer(pass));
      }
    }]);

    function BatchedBuffer(pass) {
      _classCallCheck(this, BatchedBuffer);

      this.batches = [];
      this.dynamicOffsets = [];
      this._device = void 0;
      this._device = pass.device;
    }

    _createClass(BatchedBuffer, [{
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < this.batches.length; ++i) {
          var batch = this.batches[i];

          for (var j = 0; j < batch.vbs.length; ++j) {
            batch.vbs[j].destroy();
          }

          batch.vbIdx.destroy();
          batch.ia.destroy();
          batch.ubo.destroy();
        }

        this.batches.length = 0;
      }
    }, {
      key: "merge",
      value: function merge(subModel, passIdx, ro) {
        var flatBuffers = subModel.subMesh.flatBuffers;

        if (flatBuffers.length === 0) {
          return;
        }

        var vbSize = 0;
        var vbIdxSize = 0;
        var vbCount = flatBuffers[0].count;

        var hPass = _memoryPools.SubModelPool.get(subModel.handle, _memoryPools.SubModelView.PASS_0 + passIdx);

        var hShader = _memoryPools.SubModelPool.get(subModel.handle, _memoryPools.SubModelView.SHADER_0 + passIdx);

        var descriptorSet = subModel.descriptorSet;
        var isBatchExist = false;

        for (var i = 0; i < this.batches.length; ++i) {
          var batch = this.batches[i];

          if (batch.vbs.length === flatBuffers.length && batch.mergeCount < _define.UBOLocalBatched.BATCHING_COUNT) {
            isBatchExist = true;

            for (var j = 0; j < batch.vbs.length; ++j) {
              var vb = batch.vbs[j];

              if (vb.stride !== flatBuffers[j].stride) {
                isBatchExist = false;
                break;
              }
            }

            if (isBatchExist) {
              for (var _j = 0; _j < batch.vbs.length; ++_j) {
                var flatBuff = flatBuffers[_j];
                var batchVB = batch.vbs[_j];
                var vbBuf = batch.vbDatas[_j];
                vbSize = (vbCount + batch.vbCount) * flatBuff.stride;

                if (vbSize > batchVB.size) {
                  batchVB.resize(vbSize);
                  batch.vbDatas[_j] = new Uint8Array(vbSize);

                  batch.vbDatas[_j].set(vbBuf);
                }

                batch.vbDatas[_j].set(flatBuff.buffer, batch.vbCount * flatBuff.stride);
              }

              var vbIdxBuf = batch.vbIdxData;
              vbIdxSize = (vbCount + batch.vbCount) * 4;

              if (vbIdxSize > batch.vbIdx.size) {
                batch.vbIdx.resize(vbIdxSize);
                batch.vbIdxData = new Float32Array(vbIdxSize / Float32Array.BYTES_PER_ELEMENT);
                batch.vbIdxData.set(vbIdxBuf);
                vbIdxBuf = batch.vbIdxData;
              }

              var start = batch.vbCount;
              var end = start + vbCount;
              var mergeCount = batch.mergeCount;

              if (vbIdxBuf[start] !== mergeCount || vbIdxBuf[end - 1] !== mergeCount) {
                for (var _j2 = start; _j2 < end; _j2++) {
                  vbIdxBuf[_j2] = mergeCount + 0.1; // guard against underflow
                }
              } // update world matrix


              _index2.Mat4.toArray(batch.uboData, ro.model.transform.worldMatrix, _define.UBOLocalBatched.MAT_WORLDS_OFFSET + batch.mergeCount * 16);

              if (!batch.mergeCount) {
                descriptorSet.bindBuffer(_define.UBOLocalBatched.BINDING, batch.ubo);
                descriptorSet.update();
                batch.hPass = hPass;
                batch.hShader = hShader;
                batch.descriptorSet = descriptorSet;
              }

              ++batch.mergeCount;
              batch.vbCount += vbCount;
              batch.ia.vertexCount += vbCount;
              return;
            }
          }
        } // Create a new batch


        var vbs = [];
        var vbDatas = [];
        var totalVBs = [];

        for (var _i = 0; _i < flatBuffers.length; ++_i) {
          var _flatBuff = flatBuffers[_i];

          var newVB = this._device.createBuffer(new _buffer.GFXBufferInfo(_index.GFXBufferUsageBit.VERTEX | _index.GFXBufferUsageBit.TRANSFER_DST, _index.GFXMemoryUsageBit.HOST | _index.GFXMemoryUsageBit.DEVICE, _flatBuff.count * _flatBuff.stride, _flatBuff.stride));

          newVB.update(_flatBuff.buffer.buffer);
          vbs.push(newVB);
          vbDatas.push(new Uint8Array(newVB.size));
          totalVBs.push(newVB);
        }

        var vbIdx = this._device.createBuffer(new _buffer.GFXBufferInfo(_index.GFXBufferUsageBit.VERTEX | _index.GFXBufferUsageBit.TRANSFER_DST, _index.GFXMemoryUsageBit.HOST | _index.GFXMemoryUsageBit.DEVICE, vbCount * 4, 4));

        var vbIdxData = new Float32Array(vbCount);
        vbIdxData.fill(0);
        vbIdx.update(vbIdxData);
        totalVBs.push(vbIdx);
        var attributes = subModel.inputAssembler.attributes;
        var attrs = new Array(attributes.length + 1);

        for (var a = 0; a < attributes.length; ++a) {
          attrs[a] = attributes[a];
        }

        attrs[attributes.length] = new _inputAssembler.GFXAttribute('a_dyn_batch_id', _index.GFXFormat.R32F, false, flatBuffers.length);
        var iaInfo = new _inputAssembler.GFXInputAssemblerInfo(attrs, totalVBs);

        var ia = this._device.createInputAssembler(iaInfo);

        var ubo = this._device.createBuffer(new _buffer.GFXBufferInfo(_index.GFXBufferUsageBit.UNIFORM | _index.GFXBufferUsageBit.TRANSFER_DST, _index.GFXMemoryUsageBit.HOST | _index.GFXMemoryUsageBit.DEVICE, _define.UBOLocalBatched.SIZE, _define.UBOLocalBatched.SIZE));

        descriptorSet.bindBuffer(_define.UBOLocalBatched.BINDING, ubo);
        descriptorSet.update();
        var uboData = new Float32Array(_define.UBOLocalBatched.COUNT);

        _index2.Mat4.toArray(uboData, ro.model.transform.worldMatrix, _define.UBOLocalBatched.MAT_WORLDS_OFFSET);

        this.batches.push({
          mergeCount: 1,
          vbs: vbs,
          vbDatas: vbDatas,
          vbIdx: vbIdx,
          vbIdxData: vbIdxData,
          vbCount: vbCount,
          ia: ia,
          ubo: ubo,
          uboData: uboData,
          hPass: hPass,
          hShader: hShader,
          descriptorSet: descriptorSet
        });
      }
    }, {
      key: "clear",
      value: function clear() {
        for (var i = 0; i < this.batches.length; ++i) {
          var batch = this.batches[i];
          batch.vbCount = 0;
          batch.mergeCount = 0;
          batch.ia.vertexCount = 0;
        }
      }
    }]);

    return BatchedBuffer;
  }();

  _exports.BatchedBuffer = BatchedBuffer;
  BatchedBuffer._buffers = new Map();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImU6L2QwMDQ1MjUyMC9HaXRodWIvZW5naW5lL2NvY29zL2NvcmUvcGlwZWxpbmUvYmF0Y2hlZC1idWZmZXIudHMiXSwibmFtZXMiOlsiQmF0Y2hlZEJ1ZmZlciIsInBhc3MiLCJleHRyYUtleSIsImJ1ZmZlcnMiLCJfYnVmZmVycyIsImhhcyIsInNldCIsInJlY29yZCIsImdldCIsImJhdGNoZXMiLCJkeW5hbWljT2Zmc2V0cyIsIl9kZXZpY2UiLCJkZXZpY2UiLCJpIiwibGVuZ3RoIiwiYmF0Y2giLCJqIiwidmJzIiwiZGVzdHJveSIsInZiSWR4IiwiaWEiLCJ1Ym8iLCJzdWJNb2RlbCIsInBhc3NJZHgiLCJybyIsImZsYXRCdWZmZXJzIiwic3ViTWVzaCIsInZiU2l6ZSIsInZiSWR4U2l6ZSIsInZiQ291bnQiLCJjb3VudCIsImhQYXNzIiwiU3ViTW9kZWxQb29sIiwiaGFuZGxlIiwiU3ViTW9kZWxWaWV3IiwiUEFTU18wIiwiaFNoYWRlciIsIlNIQURFUl8wIiwiZGVzY3JpcHRvclNldCIsImlzQmF0Y2hFeGlzdCIsIm1lcmdlQ291bnQiLCJVQk9Mb2NhbEJhdGNoZWQiLCJCQVRDSElOR19DT1VOVCIsInZiIiwic3RyaWRlIiwiZmxhdEJ1ZmYiLCJiYXRjaFZCIiwidmJCdWYiLCJ2YkRhdGFzIiwic2l6ZSIsInJlc2l6ZSIsIlVpbnQ4QXJyYXkiLCJidWZmZXIiLCJ2YklkeEJ1ZiIsInZiSWR4RGF0YSIsIkZsb2F0MzJBcnJheSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwic3RhcnQiLCJlbmQiLCJNYXQ0IiwidG9BcnJheSIsInVib0RhdGEiLCJtb2RlbCIsInRyYW5zZm9ybSIsIndvcmxkTWF0cml4IiwiTUFUX1dPUkxEU19PRkZTRVQiLCJiaW5kQnVmZmVyIiwiQklORElORyIsInVwZGF0ZSIsInZlcnRleENvdW50IiwidG90YWxWQnMiLCJuZXdWQiIsImNyZWF0ZUJ1ZmZlciIsIkdGWEJ1ZmZlckluZm8iLCJHRlhCdWZmZXJVc2FnZUJpdCIsIlZFUlRFWCIsIlRSQU5TRkVSX0RTVCIsIkdGWE1lbW9yeVVzYWdlQml0IiwiSE9TVCIsIkRFVklDRSIsInB1c2giLCJmaWxsIiwiYXR0cmlidXRlcyIsImlucHV0QXNzZW1ibGVyIiwiYXR0cnMiLCJBcnJheSIsImEiLCJHRlhBdHRyaWJ1dGUiLCJHRlhGb3JtYXQiLCJSMzJGIiwiaWFJbmZvIiwiR0ZYSW5wdXRBc3NlbWJsZXJJbmZvIiwiY3JlYXRlSW5wdXRBc3NlbWJsZXIiLCJVTklGT1JNIiwiU0laRSIsIkNPVU5UIiwiTWFwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQTRCYUEsYTs7OzBCQUlVQyxJLEVBQTBCO0FBQUEsWUFBZEMsUUFBYyx1RUFBSCxDQUFHO0FBQ3pDLFlBQU1DLE9BQU8sR0FBR0gsYUFBYSxDQUFDSSxRQUE5QjtBQUNBLFlBQUksQ0FBQ0QsT0FBTyxDQUFDRSxHQUFSLENBQVlKLElBQVosQ0FBTCxFQUF3QkUsT0FBTyxDQUFDRyxHQUFSLENBQVlMLElBQVosRUFBa0IsRUFBbEI7QUFDeEIsWUFBTU0sTUFBTSxHQUFHSixPQUFPLENBQUNLLEdBQVIsQ0FBWVAsSUFBWixDQUFmO0FBQ0EsZUFBT00sTUFBTSxDQUFDTCxRQUFELENBQU4sS0FBcUJLLE1BQU0sQ0FBQ0wsUUFBRCxDQUFOLEdBQW1CLElBQUlGLGFBQUosQ0FBa0JDLElBQWxCLENBQXhDLENBQVA7QUFDSDs7O0FBTUQsMkJBQWFBLElBQWIsRUFBeUI7QUFBQTs7QUFBQSxXQUpsQlEsT0FJa0IsR0FKUSxFQUlSO0FBQUEsV0FIbEJDLGNBR2tCLEdBSFMsRUFHVDtBQUFBLFdBRmpCQyxPQUVpQjtBQUNyQixXQUFLQSxPQUFMLEdBQWVWLElBQUksQ0FBQ1csTUFBcEI7QUFDSDs7OztnQ0FFaUI7QUFDZCxhQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS0osT0FBTCxDQUFhSyxNQUFqQyxFQUF5QyxFQUFFRCxDQUEzQyxFQUE4QztBQUMxQyxjQUFNRSxLQUFLLEdB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T0FBTixHQUFnQixDQUFoQjtBQUNBZCxVQUFBQSxLQUFLLENBQUN5QixVQUFOLEdBQW1CLENBQW5CO0FBQ0F6QixVQUFBQSxLQUFLLENBQUNLLEVBQU4sQ0FBU2lELFdBQVQsR0FBdUIsQ0FBdkI7QUFDSDtBQUNKOzs7Ozs7O0FBMUtRckUsRUFBQUEsYSxDQUVNSSxRLEdBQVcsSUFBSTRGLEdBQUosRSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgR0ZYQnVmZmVyVXNhZ2VCaXQsIEdGWEZvcm1hdCwgR0ZYTWVtb3J5VXNhZ2VCaXQsIEdGWERldmljZSwgR0ZYRGVzY3JpcHRvclNldCB9IGZyb20gJy4uL2dmeCc7XHJcbmltcG9ydCB7IEdGWEJ1ZmZlciwgR0ZYQnVmZmVySW5mbyB9IGZyb20gJy4uL2dmeC9idWZmZXInO1xyXG5pbXBvcnQgeyBHRlhJbnB1dEFzc2VtYmxlciwgR0ZYSW5wdXRBc3NlbWJsZXJJbmZvLCBHRlhBdHRyaWJ1dGUgfSBmcm9tICcuLi9nZngvaW5wdXQtYXNzZW1ibGVyJztcclxuaW1wb3J0IHsgTWF0NCB9IGZyb20gJy4uL21hdGgnO1xyXG5pbXBvcnQgeyBTdWJNb2RlbCB9IGZyb20gJy4uL3JlbmRlcmVyL3NjZW5lL3N1Ym1vZGVsJztcclxuaW1wb3J0IHsgSVJlbmRlck9iamVjdCwgVUJPTG9jYWxCYXRjaGVkIH0gZnJvbSAnLi9kZWZpbmUnO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSAnLi4vcmVuZGVyZXInO1xyXG5pbXBvcnQgeyBTdWJNb2RlbFBvb2wsIFN1Yk1vZGVsVmlldywgUGFzc0hhbmRsZSwgU2hhZGVySGFuZGxlIH0gZnJvbSAnLi4vcmVuZGVyZXIvY29yZS9tZW1vcnktcG9vbHMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQmF0Y2hlZEl0ZW0ge1xyXG4gICAgdmJzOiBHRlhCdWZmZXJbXTtcclxuICAgIHZiRGF0YXM6IFVpbnQ4QXJyYXlbXTtcclxuICAgIHZiSWR4OiBHRlhCdWZmZXI7XHJcbiAgICB2YklkeERhdGE6IEZsb2F0MzJBcnJheTtcclxuICAgIHZiQ291bnQ6IG51bWJlcjtcclxuICAgIG1lcmdlQ291bnQ6IG51bWJlcjtcclxuICAgIGlhOiBHRlhJbnB1dEFzc2VtYmxlcjtcclxuICAgIHVibzogR0ZYQnVmZmVyO1xyXG4gICAgdWJvRGF0YTogRmxvYXQzMkFycmF5O1xyXG4gICAgZGVzY3JpcHRvclNldDogR0ZYRGVzY3JpcHRvclNldDtcclxuICAgIGhQYXNzOiBQYXNzSGFuZGxlO1xyXG4gICAgaFNoYWRlcjogU2hhZGVySGFuZGxlO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQmF0Y2hlZEJ1ZmZlciB7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2J1ZmZlcnMgPSBuZXcgTWFwPFBhc3MsIFJlY29yZDxudW1iZXIsIEJhdGNoZWRCdWZmZXI+PigpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IChwYXNzOiBQYXNzLCBleHRyYUtleSA9IDApIHtcclxuICAgICAgICBjb25zdCBidWZmZXJzID0gQmF0Y2hlZEJ1ZmZlci5fYnVmZmVycztcclxuICAgICAgICBpZiAoIWJ1ZmZlcnMuaGFzKHBhc3MpKSBidWZmZXJzLnNldChwYXNzLCB7fSk7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkID0gYnVmZmVycy5nZXQocGFzcykhO1xyXG4gICAgICAgIHJldHVybiByZWNvcmRbZXh0cmFLZXldIHx8IChyZWNvcmRbZXh0cmFLZXldID0gbmV3IEJhdGNoZWRCdWZmZXIocGFzcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiYXRjaGVzOiBJQmF0Y2hlZEl0ZW1bXSA9IFtdO1xyXG4gICAgcHVibGljIGR5bmFtaWNPZmZzZXRzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBfZGV2aWNlOiBHRlhEZXZpY2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKHBhc3M6IFBhc3MpIHtcclxuICAgICAgICB0aGlzLl9kZXZpY2UgPSBwYXNzLmRldmljZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVzdHJveSAoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmF0Y2gudmJzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC52YnNbal0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhdGNoLnZiSWR4LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgYmF0Y2guaWEuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICBiYXRjaC51Ym8uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJhdGNoZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbWVyZ2UgKHN1Yk1vZGVsOiBTdWJNb2RlbCwgcGFzc0lkeDogbnVtYmVyLCBybzogSVJlbmRlck9iamVjdCkge1xyXG4gICAgICAgIGNvbnN0IGZsYXRCdWZmZXJzID0gc3ViTW9kZWwuc3ViTWVzaC5mbGF0QnVmZmVycztcclxuICAgICAgICBpZiAoZmxhdEJ1ZmZlcnMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGxldCB2YlNpemUgPSAwO1xyXG4gICAgICAgIGxldCB2YklkeFNpemUgPSAwO1xyXG4gICAgICAgIGNvbnN0IHZiQ291bnQgPSBmbGF0QnVmZmVyc1swXS5jb3VudDtcclxuICAgICAgICBjb25zdCBoUGFzcyA9IFN1Yk1vZGVsUG9vbC5nZXQoc3ViTW9kZWwuaGFuZGxlLCBTdWJNb2RlbFZpZXcuUEFTU18wICsgcGFzc0lkeCkgYXMgUGFzc0hhbmRsZTtcclxuICAgICAgICBjb25zdCBoU2hhZGVyID0gU3ViTW9kZWxQb29sLmdldChzdWJNb2RlbC5oYW5kbGUsIFN1Yk1vZGVsVmlldy5TSEFERVJfMCArIHBhc3NJZHgpIGFzIFNoYWRlckhhbmRsZTtcclxuICAgICAgICBjb25zdCBkZXNjcmlwdG9yU2V0ID0gc3ViTW9kZWwuZGVzY3JpcHRvclNldDtcclxuICAgICAgICBsZXQgaXNCYXRjaEV4aXN0ID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChiYXRjaC52YnMubGVuZ3RoID09PSBmbGF0QnVmZmVycy5sZW5ndGggJiYgYmF0Y2gubWVyZ2VDb3VudCA8IFVCT0xvY2FsQmF0Y2hlZC5CQVRDSElOR19DT1VOVCkge1xyXG4gICAgICAgICAgICAgICAgaXNCYXRjaEV4aXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmF0Y2gudmJzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmIgPSBiYXRjaC52YnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZiLnN0cmlkZSAhPT0gZmxhdEJ1ZmZlcnNbal0uc3RyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQmF0Y2hFeGlzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQmF0Y2hFeGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmF0Y2gudmJzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYXRCdWZmID0gZmxhdEJ1ZmZlcnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoVkIgPSBiYXRjaC52YnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZiQnVmID0gYmF0Y2gudmJEYXRhc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmJTaXplID0gKHZiQ291bnQgKyBiYXRjaC52YkNvdW50KSAqIGZsYXRCdWZmLnN0cmlkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZiU2l6ZSA+IGJhdGNoVkIuc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hWQi5yZXNpemUodmJTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoLnZiRGF0YXNbal0gPSBuZXcgVWludDhBcnJheSh2YlNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2gudmJEYXRhc1tqXS5zZXQodmJCdWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoLnZiRGF0YXNbal0uc2V0KGZsYXRCdWZmLmJ1ZmZlciwgYmF0Y2gudmJDb3VudCAqIGZsYXRCdWZmLnN0cmlkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmJJZHhCdWYgPSBiYXRjaC52YklkeERhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmJJZHhTaXplID0gKHZiQ291bnQgKyBiYXRjaC52YkNvdW50KSAqIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZiSWR4U2l6ZSA+IGJhdGNoLnZiSWR4LnNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2gudmJJZHgucmVzaXplKHZiSWR4U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoLnZiSWR4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodmJJZHhTaXplIC8gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2gudmJJZHhEYXRhLnNldCh2YklkeEJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZiSWR4QnVmID0gYmF0Y2gudmJJZHhEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBiYXRjaC52YkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgdmJDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXJnZUNvdW50ID0gYmF0Y2gubWVyZ2VDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmJJZHhCdWZbc3RhcnRdICE9PSBtZXJnZUNvdW50IHx8IHZiSWR4QnVmW2VuZCAtIDFdICE9PSBtZXJnZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydDsgaiA8IGVuZDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YklkeEJ1ZltqXSA9IG1lcmdlQ291bnQgKyAwLjE7IC8vIGd1YXJkIGFnYWluc3QgdW5kZXJmbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB3b3JsZCBtYXRyaXhcclxuICAgICAgICAgICAgICAgICAgICBNYXQ0LnRvQXJyYXkoYmF0Y2gudWJvRGF0YSwgcm8ubW9kZWwudHJhbnNmb3JtLndvcmxkTWF0cml4LCBVQk9Mb2NhbEJhdGNoZWQuTUFUX1dPUkxEU19PRkZTRVQgKyBiYXRjaC5tZXJnZUNvdW50ICogMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmF0Y2gubWVyZ2VDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yU2V0LmJpbmRCdWZmZXIoVUJPTG9jYWxCYXRjaGVkLkJJTkRJTkcsIGJhdGNoLnVibyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JTZXQudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoLmhQYXNzID0gaFBhc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoLmhTaGFkZXIgPSBoU2hhZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaC5kZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvclNldDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICsrYmF0Y2gubWVyZ2VDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaC52YkNvdW50ICs9IHZiQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2guaWEudmVydGV4Q291bnQgKz0gdmJDb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYmF0Y2hcclxuICAgICAgICBjb25zdCB2YnM6IEdGWEJ1ZmZlcltdID0gW107XHJcbiAgICAgICAgY29uc3QgdmJEYXRhczogVWludDhBcnJheVtdID0gW107XHJcbiAgICAgICAgY29uc3QgdG90YWxWQnM6IEdGWEJ1ZmZlcltdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbGF0QnVmZmVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBmbGF0QnVmZiA9IGZsYXRCdWZmZXJzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWQiA9IHRoaXMuX2RldmljZS5jcmVhdGVCdWZmZXIobmV3IEdGWEJ1ZmZlckluZm8oXHJcbiAgICAgICAgICAgICAgICBHRlhCdWZmZXJVc2FnZUJpdC5WRVJURVggfCBHRlhCdWZmZXJVc2FnZUJpdC5UUkFOU0ZFUl9EU1QsXHJcbiAgICAgICAgICAgICAgICBHRlhNZW1vcnlVc2FnZUJpdC5IT1NUIHwgR0ZYTWVtb3J5VXNhZ2VCaXQuREVWSUNFLFxyXG4gICAgICAgICAgICAgICAgZmxhdEJ1ZmYuY291bnQgKiBmbGF0QnVmZi5zdHJpZGUsXHJcbiAgICAgICAgICAgICAgICBmbGF0QnVmZi5zdHJpZGUsXHJcbiAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICBuZXdWQi51cGRhdGUoZmxhdEJ1ZmYuYnVmZmVyLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHZicy5wdXNoKG5ld1ZCKTtcclxuICAgICAgICAgICAgdmJEYXRhcy5wdXNoKG5ldyBVaW50OEFycmF5KG5ld1ZCLnNpemUpKTtcclxuICAgICAgICAgICAgdG90YWxWQnMucHVzaChuZXdWQik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB2YklkeCA9IHRoaXMuX2RldmljZS5jcmVhdGVCdWZmZXIobmV3IEdGWEJ1ZmZlckluZm8oXHJcbiAgICAgICAgICAgIEdGWEJ1ZmZlclVzYWdlQml0LlZFUlRFWCB8IEdGWEJ1ZmZlclVzYWdlQml0LlRSQU5TRkVSX0RTVCxcclxuICAgICAgICAgICAgR0ZYTWVtb3J5VXNhZ2VCaXQuSE9TVCB8IEdGWE1lbW9yeVVzYWdlQml0LkRFVklDRSxcclxuICAgICAgICAgICAgdmJDb3VudCAqIDQsXHJcbiAgICAgICAgICAgIDQsXHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgY29uc3QgdmJJZHhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh2YkNvdW50KTtcclxuICAgICAgICB2YklkeERhdGEuZmlsbCgwKTtcclxuICAgICAgICB2YklkeC51cGRhdGUodmJJZHhEYXRhKTtcclxuICAgICAgICB0b3RhbFZCcy5wdXNoKHZiSWR4KTtcclxuXHJcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHN1Yk1vZGVsLmlucHV0QXNzZW1ibGVyIS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEFycmF5PEdGWEF0dHJpYnV0ZT4oYXR0cmlidXRlcy5sZW5ndGggKyAxKTtcclxuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2EpIHtcclxuICAgICAgICAgICAgYXR0cnNbYV0gPSBhdHRyaWJ1dGVzW2FdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhdHRyc1thdHRyaWJ1dGVzLmxlbmd0aF0gPSBuZXcgR0ZYQXR0cmlidXRlKCdhX2R5bl9iYXRjaF9pZCcsIEdGWEZvcm1hdC5SMzJGLCBmYWxzZSwgZmxhdEJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgY29uc3QgaWFJbmZvID0gbmV3IEdGWElucHV0QXNzZW1ibGVySW5mbyhhdHRycywgdG90YWxWQnMpO1xyXG4gICAgICAgIGNvbnN0IGlhID0gdGhpcy5fZGV2aWNlLmNyZWF0ZUlucHV0QXNzZW1ibGVyKGlhSW5mbyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVibyA9IHRoaXMuX2RldmljZS5jcmVhdGVCdWZmZXIobmV3IEdGWEJ1ZmZlckluZm8oXHJcbiAgICAgICAgICAgIEdGWEJ1ZmZlclVzYWdlQml0LlVOSUZPUk0gfCBHRlhCdWZmZXJVc2FnZUJpdC5UUkFOU0ZFUl9EU1QsXHJcbiAgICAgICAgICAgIEdGWE1lbW9yeVVzYWdlQml0LkhPU1QgfCBHRlhNZW1vcnlVc2FnZUJpdC5ERVZJQ0UsXHJcbiAgICAgICAgICAgIFVCT0xvY2FsQmF0Y2hlZC5TSVpFLFxyXG4gICAgICAgICAgICBVQk9Mb2NhbEJhdGNoZWQuU0laRSxcclxuICAgICAgICApKTtcclxuXHJcbiAgICAgICAgZGVzY3JpcHRvclNldC5iaW5kQnVmZmVyKFVCT0xvY2FsQmF0Y2hlZC5CSU5ESU5HLCB1Ym8pO1xyXG4gICAgICAgIGRlc2NyaXB0b3JTZXQudXBkYXRlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVib0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFVCT0xvY2FsQmF0Y2hlZC5DT1VOVCk7XHJcbiAgICAgICAgTWF0NC50b0FycmF5KHVib0RhdGEsIHJvLm1vZGVsLnRyYW5zZm9ybS53b3JsZE1hdHJpeCwgVUJPTG9jYWxCYXRjaGVkLk1BVF9XT1JMRFNfT0ZGU0VUKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYXRjaGVzLnB1c2goe1xyXG4gICAgICAgICAgICBtZXJnZUNvdW50OiAxLFxyXG4gICAgICAgICAgICB2YnMsIHZiRGF0YXMsIHZiSWR4LCB2YklkeERhdGEsIHZiQ291bnQsIGlhLCB1Ym8sIHVib0RhdGEsIGhQYXNzLCBoU2hhZGVyLCBkZXNjcmlwdG9yU2V0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGVhciAoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaV07XHJcbiAgICAgICAgICAgIGJhdGNoLnZiQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBiYXRjaC5tZXJnZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgYmF0Y2guaWEudmVydGV4Q291bnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=