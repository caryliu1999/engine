// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.
// reference: 'moving frostbite to pbr' & UE4 BRDF.usf

#include <cc-global>
#include <cc-shadow>

#if CC_USE_IBL
  #include <cc-environment>
  #include <unpack>
  #include <texture-lod>
#endif

#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
  #include <lightingmap-fs>
#endif

#include <common>
#include <gamma>

#include <lighting>

//#if CC_RECEIVE_SHADOW
  #include <cc-shadow-map-fs>
//#endif

vec4 DealLightShading (StandardSurface s, float fogFractor) {
  // Calculate diffuse & specular
  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);
  vec3 diffuseContrib = diffuse / PI;
  vec3 N = normalize(s.normal);
  vec3 V = normalize(cc_cameraPos.xyz - s.position);
  float NV = max(abs(dot(N, V)), 0.001);
  specular = BRDFApprox(specular, s.roughness, NV);
  vec3 finalColor = vec3(0.0);
  vec4 result = vec4(0.0);

  for (int i = 0; i < LIGHTS_PER_PASS; i++) {
    if (i >= LIGHTS_CNT) break;
    vec3 SLU = cc_lightPos[i].xyz - s.position;
    vec3 SL = normalize(SLU);
    vec3 SH = normalize(SL + V);
    float SNL = max(dot(N, SL), 0.001);
    float SNH = max(dot(N, SH), 0.0);
    float distSqr = dot(SLU, SLU);
    float litRadius = cc_lightSizeRangeAngle[i].x;
    float litRadiusSqr = litRadius * litRadius;
    float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));
    float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);
    attRadiusSqrInv *= attRadiusSqrInv;
    float att = GetDistAtt(distSqr, attRadiusSqrInv);
    vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);
    if (cc_lightPos[i].w > 0.0) {
      float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);
      float cosOuter = cc_lightSizeRangeAngle[i].z;
      float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);
      float litAngleOffset = -cosOuter * litAngleScale;
      att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);
    }

    finalColor = SNL * cc_lightColor[i].rgb * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);
    finalColor = finalColor * s.occlusion;
    result += CCFragOutput(vec4(mix(vec3(0.0), finalColor, fogFractor), 0.0));
  }

  return result;
}

vec4 DealMainLightShading (StandardSurface s, float fogFractor) {
  // Calculate diffuse & specular
  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);
  vec3 N = normalize(s.normal);
  vec3 V = normalize(cc_cameraPos.xyz - s.position);
  float NV = max(abs(dot(N, V)), 0.001);
  specular = BRDFApprox(specular, s.roughness, NV);
  vec3 L = normalize(-cc_mainLitDir.xyz);
  vec3 H = normalize(L+V);
  float NH = max(dot(N, H), 0.0);
  float NL = max(dot(N, L), 0.001);
  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
    vec4 lightmap = texture(cc_lightingMap, v_luv);
    finalColor = lightmap.a * lightmap.rgb + (1.0 - lightmap.a) * finalColor;
  #endif
  vec3 diffuseContrib = diffuse / PI;
  // Cook-Torrance Microfacet Specular BRDF
  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
  finalColor *= (diffuseContrib + specularContrib);
  float fAmb = 0.5 - N.y * 0.5;
  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
  finalColor += (ambDiff.rgb * diffuse);
  #if CC_USE_IBL
    vec3 R = normalize(reflect(-V, N));
    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
    #if CC_USE_IBL == IBL_RGBE
      vec3 env = unpackRGBE(envmap);
    #else
      vec3 env = SRGBToLinear(envmap.rgb);
    #endif
    finalColor += env * cc_ambientSky.w * specular;
  #endif
  finalColor = finalColor * s.occlusion;
  #if CC_USE_HDR
    s.emissive *= cc_exposure.w;
  #endif
  finalColor += s.emissive;

  #if CC_RECEIVE_SHADOW
    vec4 v_shadowPos = cc_matLightViewProj * vec4(s.position, 1.0);
    float pcf = cc_shadowInfo.z + 0.001;
    float shadowAttenuation = 0.0;
    if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(v_shadowPos);
    else if (3.0 > pcf && pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(v_shadowPos);
    else if (2.0 > pcf && pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(v_shadowPos);
    else shadowAttenuation = CCGetShadowFactorX1(v_shadowPos);
    vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);
    finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);
  #endif

  vec4 ret = vec4(finalColor, s.albedo.a);
  //ret = vec4(mix(cc_fogColor.rgb, ret.rgb, fogFractor), ret.a);
  return CCFragOutput(ret);
}

vec4 CCDeferredShading(StandardSurface s, float fogFractor) {
  // part 1 : the main light - direct light
  vec4 retColor = vec4(0,0,0,0);
  retColor += DealMainLightShading(s, fogFractor);

  // part 2 : other lights, dot or sphere light
  //retColor += DealLightShading(s, fogFractor);
  return retColor;
}